#!/usr/bin/env perl
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-

# parse.pl: Common parsing stuff for the ximian-setup-tools backends.
#
# Copyright (C) 2000-2001 Ximian, Inc.
#
# Authors: Hans Petter Jansson <hpj@ximian.com>
#          Arturo Espinosa <arturo@ximian.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.


require "___scriptsdir___/util.pl";
require "___scriptsdir___/file.pl";
require "___scriptsdir___/debug.pl";


sub xst_parse_replace_hash_values
{
  my ($cp, $hash) = @_;
  my ($j, $replace_key, $value);

  foreach $j (@$cp)
  {
    while ($j =~ /%(.*)%/)
    {
      $replace_key = $1;
      if (exists $$hash{$replace_key}) 
      {
        $value = $$hash{$replace_key};
        $j =~ s/%$replace_key%/$value/g;
      }
      else
      {
        &xst_debug_print_line ("Warning: xst_parse_replace_hash_values: key $replace_key doesn't exist.");
        last;
      }
    }
  }
}

sub xst_parse_replace_files
{
  my ($values, $fn_hash) = @_;
  my @ret;

  $values = [$values] if !ref $values;

  foreach $i (@$values)
  {
    if (exists $$fn_hash{$i})
    {
      push @ret, $$fn_hash{$i};
    }
    else
    {
      push @ret, $i;
    }
  }

  return @ret;
}

sub xst_parse_from_table
{
  my ($fn, $table) = @_;
  my %hash;
  my ($key, $proc, @param);
  my ($i, @cp);

  foreach $i (@$table)
  {
    @cp = @$i;
    $key = shift (@cp);
    $proc = shift (@cp);
    unshift @cp, &xst_parse_replace_files (shift (@cp), $fn);

    &xst_parse_replace_hash_values (\@cp, \%hash);
    $hash{$key} = &$proc (@cp) if ($hash{$key} eq undef);
  }

  foreach $i (keys (%hash))
  {
    delete $hash{$i} if (($hash{$i} eq undef) || ($hash{$i} eq ""));
  }
  
  return \%hash;
}

# Just return the passed values. If there's just
# one value, the value. If more, a reference to an
# array with the values.
sub xst_parse_trivial
{
  my (@res) = @_;

  return $res[0] if $#res == 0;
  return \@res;
}

sub xst_parse_chomp_line_std
{
  my ($fd) = @_;
  my $line;

  $line = <$fd>;
  return -1 if !$line;

  chomp $line;
  $line =~ s/^[ \t]+//;
  $line =~ s/[ \t]+$//;

  return \$line;
}

sub xst_parse_chomp_line_hash_comment
{
  my ($fd) = @_;
  my $line;

  $line = &xst_parse_chomp_line_std ($fd);
  return -1 if $line == -1;

  $line = $$line;

  # This will put escaped hashes out of danger.
  $line =~ s/([\"\'][^\#]*)\#([^\"\']*[\"\'])/\1__hash__\2/g;
  $line =~ s/\\\#/__hash__/g;

  # Nuke everything after a hash.
  $line =~ s/\#.*//;

  # Let escaped hashes come back home.
  $line =~ s/__hash__/\#/g;

  # Bye bye trailing spaces.
  $line =~ s/[ \t]+$//;
  
  return \$line;
}

# Parse a $file, wich is assumed to have a column-based format, with $re matching field separators
# and one record per line. Search for $key, and return either a scalar with the first ocurrence,
# or an array with all the found ocurrences.
sub xst_parse_split_ref
{
  my ($file, $key, $re, $all, $line_read_proc) = @_;
  my ($fd, @line, @res);

  $proc = $line_read_proc? $line_read_proc : \&xst_parse_chomp_line_std;
  
  $fd = &xst_open_read_from_names ($file);
  $all = 0 if !$fd;
  
  while (($line = &$proc ($fd)) != -1)
  {
    $line = $$line;
    next if $line eq "";
    @line = split ($re, $line, 2);

    if (shift (@line) eq $key)
    {
      if ($all) {
        push @res, $line[0];
      }
      else
      {
        close $fd;
        return \$line[0];
      }
    }
  }

  close $fd;
  return \@res if ($all);
  return -1;
}

sub xst_parse_split
{
  my $res;

  # Don't pass @_ like this anywhere. This is bad practice.
  $res = &xst_parse_split_ref (@_);

  return $$res if ref $res eq "SCALAR";
  return @$res if ref $res eq "ARRAY";
  return undef;
}

# This gives meaning to the $all flag of xst_parse_split, and returns a reference to the array, which
# is what we want. (ie search a.com\nsearch b.com\nsearch c.com)
sub xst_parse_split_all
{
  my ($file, $key, $re, $line_read_proc) = @_;
  my @a;

  @a = &xst_parse_split ($file, $key, $re, 1, $line_read_proc);

  return \@a;
}

# Same, but use the hash_comment routine for line analysis.
sub xst_parse_split_all_hash_comment
{
  my ($file, $key, $re) = @_;

  return &xst_parse_split_all ($file, $key, $re, \&xst_parse_chomp_line_hash_comment);
}

# Same, but for $all = 0. (ie nameserver 10.0.0.1)
sub xst_parse_split_first_str
{
  my ($file, $key, $re, $line_read_proc) = @_;

  return &xst_parse_split ($file, $key, $re, 0, $line_read_proc);
}

# Interpret the result as a boolean. (ie multi on)
sub xst_parse_split_first_bool
{
  my ($file, $key, $re, $line_read_proc) = @_;
  my $ret;

  $ret = &xst_parse_split_first_str ($file, $key, $re, $line_read_proc);

  return undef if ($ret eq undef);
  return (&xst_read_boolean ($ret)? 1: 0);
}

# After getting the first field, split the result with $sep matching separators. (ie order hosts,bind)
sub xst_parse_split_first_array
{
  my ($file, $key, $re, $sep, $line_read_proc) = @_;
  my @ret;
  
  @ret = split ($sep, &xst_parse_split ($file, $key, $re, 0, $line_read_proc));

  return \@ret;
}

sub xst_parse_split_hash
{
  my ($file, $key_re, $value_re) = @_;
  my ($fd, @line, %res, $key);

  $fd = &xst_open_read_from_names ($file);
  
  while (<$fd>)
  {
    chomp;
    s/^[ \t]+//;
    s/[ \t]+$//;
    next if (/^$/);
    @line = split ($key_re, $_, 2);

    $key = shift (@line);
    $res{$key} = [ split ($value_re, $line[0]) ];
  }

  close $fd;
  return undef if (scalar keys (%res) == 0);
  return \%res;
}

# For files which are a list of /bin/sh shell variable declarations. (ie GATEWAY=10.10.10.1)
sub xst_parse_sh
{
  my ($file, $key) = @_;
  my $ret;

  $ret = &xst_parse_split_first_str ($file, $key, "[ \t]*=[ \t]*",
                                     \&xst_parse_chomp_line_hash_comment);

  # Quote shell special chars.
  $ret =~ s/\\\"/\\_/g;
  $ret =~ s/\"//g;
  $ret =~ s/\\_/\"/g;
  $ret =~ s/\\\'/\\_/g;
  $ret =~ s/\'//g;
  $ret =~ s/\\_/\'/g;
  $ret =~ s/\\(.)/\1/g;

  return $ret;
}

# Same, but interpret the returing value as a bool. (ie NETWORKING=yes)
sub xst_parse_sh_bool
{
  my ($file, $key) = @_;
  my $ret;

  $ret = &xst_parse_sh ($file, $key);

  return undef if ($ret eq undef);
  return (&xst_read_boolean ($ret)? 1: 0);
}

# Search for $keyword in $file, delimited by $re (default " ") or EOL.
# If keyword exists, return 1, else 0.
sub xst_parse_kw
{
  my ($file, $keyword, $re, $line_read_proc) = @_;
  my $res;

  return undef if ! -f $file;
  
  $re = " " if $re eq undef;
  $res = &xst_parse_split_ref ($file, $keyword, $re, 0, $line_read_proc);

  return 0 if $res == -1;
  return 1;
}

# A file containing the desired value in its first line. (ie /etc/hostname)
sub xst_parse_line_first
{
  my ($file) = @_;
  my ($fd, $res);

  $fd = &xst_open_read_from_names ($file);
  return undef if !$fd;

  chomp ($res = <$fd>);
  close $fd;
  return $res;
}

# parse a chat file, searching for an entry that matches $re.
# $re must have one paren operator (ie "^atd[^0-9]*([0-9, -]+)").
sub xst_parse_chat
{
  my ($file, $re) = @_;
  my ($fd, $found);

  $fd = &xst_open_read_from_names ("$file");
  return undef if !$fd;

  while (<$fd>)
  {
    # We'll be emptying $_ as we "scan".
    chomp;
    while ($_ ne "")
    {
      # If it uses quotes. FIXME: Assuming they surround the whole string.
      if (/^\'/)
      {
        s/\'([^\']*)\' ?//;
        $found = $1;
      }
      else
      {
        s/([^ \t]*) ?//;
        $found = $1;
      }
      
      # If it looks like what we're looking for, return what matched the parens.
      if ($found =~ /$re/i)
      {
        close $fd;
        return $1;
      }
    }
  }
  
  close $fd;
  # Oops: not found.
  return undef;
}

sub xst_parse_ini_line_clean
{
  $_ = $_[0];
  
  chomp;
  s/\#.*//;
  s/;.*//;
  s/^[ \t]+//;
  s/[ \t]+$//;

  return $_;
}

sub xst_parse_ini_line_read
{
  my $fd = $_[0];
  my $l;

  $l = <$fd>;
  return -1 if ($l eq undef);
  
  $l = &xst_parse_ini_line_clean ($l);
  while ($l =~ /\\$/)
  {
    $l =~ s/\\$//;
    $l .= &xst_parse_ini_line_clean (scalar <$fd>);
  }

  return \$l;
}

sub xst_parse_ini_sections
{
  my ($file) = @_;
  my @sections, $line;

  $fd = &xst_open_read_from_names ($file);
  
  while (($line = &xst_parse_ini_line_read ($fd)) != -1)
  {
    $_ = $$line;
    next if (/^$/);
    push @sections, $1 if (/\[([^\]]+)\]/i);
  }

  close $fd;

  return @sections;
}

sub xst_parse_ini
{
  my ($file, $section, $var) = @_;
  my ($fd, $res, $line);
  my $found_section_flag = 0;

  $fd = &xst_open_read_from_names ($file);
  $res = undef;
  
  while (($line = &xst_parse_ini_line_read ($fd)) != -1)
  {
    $_ = $$line;
    next if (/^$/);
    if (/\[$section\]/i)
    {
      s/\[$section\][ \t]*//i;
      $found_section_flag = 1;
    }

    if ($found_section_flag && /^$var[ \t]*=/i)
    {
      s/^$var[ \t]*=[ \t]*//i;
      $res = $_;
      last;
    }
  }

  close $fd;

  return $res;
}

sub xst_parse_ini_bool
{
  my ($file, $section, $var) = @_;
  my $ret;
  
  $ret = &xst_parse_ini ($file, $section, $var);
  
  return undef if ($ret eq undef);
  return (&xst_read_boolean ($ret)? 1: 0);
}

# Debian interfaces(5) states that files starting with # are comments.
# Also, leading and trailing spaces are ignored.
sub xst_parse_interfaces_line_clean
{
  $_ = $_[0];
  
  chomp;
  s/^[ \t]+//;
  s/^\#.*//;
  s/[ \t]+$//;

  return $_;
}

# interfaces(5) also states that \ line continuation is possible.
sub xst_parse_interfaces_line_read
{
  my $fd = $_[0];
  my $l;

  $l = <$fd>;
  return -1 if ($l eq undef);
  
  $l = &xst_parse_interfaces_line_clean ($l);
  while ($l =~ /\\$/)
  {
    $l =~ s/\\$//;
    $l .= &xst_parse_interfaces_line_clean (scalar <$fd>);
  }

  return \$l;
}

# Read lines until a stanza, a line starting with iface is found.
# Return ref to an array with the stanza params split.
sub xst_parse_interfaces_get_next_stanza
{
  my $fd = $_[0];
  my $line;

  while (($line = &xst_parse_interfaces_line_read ($fd)) != -1)
  {
    $_ = $$line;
    if (/^iface[ \t]/)
    {
      s/^iface[ \t]+//;
      return [ split ("[ \t]+", $_) ];
    }
  }

  return -1;
}

# Read lines until a line not recognized as a stanza is
# found, and split in a "tuple" of key/value.
sub xst_parse_interfaces_get_next_option
{
  my $fd = $_[0];
  my $line;

  while (($line = &xst_parse_interfaces_line_read ($fd)) != -1)
  {
    $_ = $$line;
    next if /^$/;
    
    return [ split ("[ \t]+", $_, 2) ] if (!/^iface[ \t]/);
    return -1;
  }

  return -1;
}

# Get all stanzas from file. Return array.
sub xst_parse_interfaces_stanzas
{
  my ($file) = @_;
  my ($fd, @res);

  $fd = &xst_open_read_from_names ($file);
  $res = undef;
  
  while (($_ = &xst_parse_interfaces_get_next_stanza ($fd)) != -1)
  {
    push @res, $_;
  }

  close $fd;

  return @res;
}

# Find stanza for $iface in $file, and return
# tuple for option with $key. Return -1 if unexisting.
sub xst_parse_interfaces_option_tuple
{
  my ($file, $iface, $key, $all) = @_;
  my ($fd, @res);

  $fd = &xst_open_read_from_names ($file);

  while (($stanza = &xst_parse_interfaces_get_next_stanza ($fd)) != -1)
  {
    if ($$stanza[0] eq $iface)
    {
      while (($tuple = &xst_parse_interfaces_get_next_option ($fd)) != -1)
      {
        if ($$tuple[0] eq $key)
        {
          return $tuple if !$all;
          push @res, $tuple;
        }
      }

      return -1 if !$all;
    }
  }

  return @res if $all;
  return -1;
}

# Go get option $kw for $iface stanza. If found,
# return 1 (true), else, false.
sub xst_parse_interfaces_option_kw
{
  my ($file, $iface, $kw) = @_;
  my $tuple;

  $tuple = &xst_parse_interfaces_option_tuple ($file, $iface, $kw);

  if ($tuple != -1)
  {
    if ($$tuple[1] ne "")
    {
      &xst_report_warning ("Keyword for interface $iface in $file had unexpected value");
    }

    return 1;
  }

  return 0;
}

# For such keywords as noauto, whose existence means
# a false value.
sub xst_parse_interfaces_option_kw_not
{
  my ($file, $iface, $kw) = @_;
  
  return !&xst_parse_interfaces_option_kw ($file, $iface, $kw);
}

# Go get option $key for $iface in $file and return value.
sub xst_parse_interfaces_option_str
{
  my ($file, $iface, $key) = @_;
  my $tuple;

  $tuple = &xst_parse_interfaces_option_tuple ($file, $iface, $key);

  if ($tuple != -1)
  {
    return $$tuple[1];
  }

  return undef;
}
