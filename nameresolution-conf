#!/usr/bin/perl

# Name resolution configurator. Designed to be architecture- and distribution independent.
#
# Copyright (C) 2000 Helix Code, Inc.
#
# Authors: Hans Petter Jansson <hpj@helixcode.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

# Best viewed with 100 columns of width.

# Configuration files affected:
#
# /etc/resolv.conf
# /etc/host.conf
# /etc/hosts
# /etc/sysconfig/network
# /etc/rc.config
# /etc/smb.conf

# Running programs affected:
#
# smbd
# nmbd


# --- Usage text --- #

my $Usage =<<"End_of_Usage;";
Usage: nameresolution-conf <--get | --set | --filter | --help>
                           [--prefix <location>] [--disable-immediate]
                           [--verbose]

       Major operations (specify one of these):

       -g --get      Prints the current name resolution configuration to
                     standard output, as as standalone XML document. The
                     configuration is read from the host\'s system config
                     files.

       -s --set      Updates the system name resolution configuration from
                     a standalone XML document read from standard input.
                     The format is the same as for the document generated
                     with --get.

       -f --filter   Reads XML configuration from standard input, parses it,
                     and writes the configurator\'s impression of it back to
                     standard output. Good for debugging and parsing tests.

       -h --help     Prints this page to standard output.

          --version  Prints version information to standard output.

       Modifiers (specify any combination of these):

       -p --prefix <location>  Specifies a directory prefix where the
                     configuration is looked for or stored. When storing
                     (with --set), directories and files may be created.

          --disable-immediate  With --set, prevents the configurator from
                     running any commands that make immediate changes to
                     the system configuration. Use with --prefix to make a
                     dry run that won\'t affect your configuration.

                     With --get, suppresses running of non-vital external
                     programs that might take a long time to finish.

       -v --verbose  Turns on diagnostic messages to standard error.

End_of_Usage;

$version = "0.1.0";

# --- System config file locations --- #

# We list each config file type with as many alternate locations as possible.
# They are tried in array order. First found = used.

# Right now there's only one entry per array, as I couldn't find any
# typical deviations.

@resolv_conf_names =       ( "/etc/resolv.conf" );
@host_conf_names =         ( "/etc/host.conf" );
@hosts_names =             ( "/etc/hosts" );
@sysconfig_network_names = ( "/etc/sysconfig/network" );
@rc_config_names =         ( "/etc/rc.config" );
@smb_conf_names =          ( "/etc/smb.conf" );


# --- Internal configuration variables --- #

# Configuration is parsed/read to, and printed/written from, these temporary variables.

$cf_hostname = "";
$cf_domain = "";
$cf_workgroup = "";
$cf_description = "";

$cf_hostname_reverse = "";
$cf_domain_reverse = "";

@cf_searchdomains = ();
@cf_nameservers = ();
@cf_statichosts = ();

$cf_winsserver = "";

@cf_order = ();
$cf_hostmatch = 0;  # 0 = all, 1 = first


# --- Operation modifying variables --- #

# Variables are set to their default value, which may be overridden by user. Note
# that a $prefix of "" will cause the configurator to use '/' as the base path,
# and disables creation of directories and writing of previously non-existent
# files.

$prefix = "";
$verbose = 0;
$do_immediate = 1;


# --- XML print formatting  --- #

# enter: Call after entering a block. Increases indent level.
# leave: Call before leaving a block. Decreases indent level.
# indent: Call before printing a line. Indents to current level. 
# vspace: Ensures there is a vertical space of one and only one line.

$indent_level = 0;
$have_vspace = 0;

sub enter  { $indent_level += 2; }
sub leave  { $indent_level -= 2; }
sub indent { for ($i = 0; $i < $indent_level; $i++) { print " "; } $have_vspace = 0; }
sub vspace { if (not $have_vspace) { print "\n"; $have_vspace = 1; } }


# --- XML scanning --- #

# This code tries to replace XML::Parser scanning from stdin in tree mode.


@xml_scan_list;


sub xml_scan_make_kid_array
{
  my %hash = {};
  my @sublist;

  @attr = @_[0] =~ /[^\t\n\r ]+[\t\n\r ]*([a-zA-Z]+)[ \t\n\r]*\=[ \t\n\r\"\']*([a-zA-Z]+)/g;
  %hash = @attr;

  push(@sublist, \%hash);
  return(\@sublist);
}


sub xml_scan_recurse;

sub xml_scan_recurse
{
  my @list;
  if (@_) { @list = @_[0]->[0]; }

  while (@xml_scan_list)
  {
    $el = @xml_scan_list[0]; shift @xml_scan_list;

    if ((not $el) || $el =~ /^\<[!?].*\>$/s) { next; }  # Empty strings, PI and DTD must go.

    if ($el =~ /^\<.*\/\>$/s)     # Empty.
    {
      $el =~ /^\<([a-zA-Z]+).*\/\>$/s;
      push(@list, $1);
      push(@list, xml_scan_make_kid_array($el));
    }
    elsif ($el =~ /^\<\/.*\>$/s)  # End.
    {
      last;
    }
    elsif ($el =~ /^\<.*\>$/s)    # Start.
    {
      $el =~ /^\<([a-zA-Z]+).*\>$/s;
      push(@list, $1);
      $sublist = xml_scan_make_kid_array($el);
      push(@list, xml_scan_recurse($sublist));
      next;
    }
    elsif ($el ne "")             # PCDATA.
    {
      push(@list, 0);
      push(@list, "$el");
    }
  }

  return(\@list);
}


sub xml_scan
{
  my $doc; my @tree;
  read STDIN, $doc, 512000;  # Read in document (FIXME: ugly).
  @xml_scan_list = ($doc =~ /([^<]*)(\<[^>]*\>)[ \t\n\r]*/mg);  # pcdata, tag, pcdata, tag, ...

  $tree = xml_scan_recurse;

  return($tree);

#  $" = "\n";
#  print "@list\n";
}


@xml_entities = ( "&lt;", '<', "&gt;", '>', "&apos;", '\'', "&quot;", '"' );

sub xml_entities_to_plain
{
  my $in = @_[0];
  my $out = "";
  my @xe;

  $in = $$in;

  my @elist = ($in =~ /([^&]*)(\&[a-zA-Z]+\;)?/mg);  # text, entity, text, entity, ...

  while (@elist)
  {
    # Join text.

    $out = join('', $out, @elist[0]);
    shift @elist;
    
    # Find entity and join its text equivalent.
    # Unknown entities are simply removed.

    for (@xe = @xml_entities; @xe; )
    {
      if (@xe[0] eq @elist[0]) { $out = join('', $out, @xe[1]); last; }
      shift @xe; shift @xe;
    }

    shift @elist;
  }

  return($out);
}


sub xml_plain_to_entities
{
  my $in = @_[0];
  my $out = "";
  my @xe;
  my $joined = 0;

  $in = $$in;

  my @clist = split(//, $in);

  while (@clist)
  {
    # Find character and join its entity equivalent.
    # If none found, simply join the character.

    $joined = 0;  # Cumbersome.

    for (@xe = @xml_entities; @xe && !$joined; )
    {
      if (@xe[1] eq @clist[0]) { $out = join('', $out, @xe[0]); $joined = 1; }
      shift @xe; shift @xe;
    }

    if (!$joined) { $out = join('', $out, @clist[0]); }
    shift @clist;
  }

  return($out);
}


# --- String and array manipulation --- #

# Pushes a value to an array, only if it's not already in there.
# I'm sure there's a smarter way to do this. Should only be used for small lists,
# as it's O(N^2). Larger lists with unique members should use a hash.

sub push_unique
{
  my $arr = @_[0];
  my $found;
  my $i;

  # Go through all elements in pushed list.

  for ($i = 1; @_[$i]; $i++)
  {
    # Compare against all elements in destination array.

    $found = "";
    for $elem (@$arr)
    {
      if ($elem eq @_[$i]) { $found = $elem; last; }
    }

    if ($found eq "") { push(@$arr, @_[$i]); }
  }
}


sub is_line_comment_start
{
  if (@_[0] =~ /^\#/) { return(1); }
  return(0);
}


# --- File operations --- #


sub open_read_from_names
{
  my $FILE;
  my $fname = "";

  for $name (@_)
  {
    if (open(FILE, "$prefix/$name")) { $fname = $name; last; }
  }

  if ($verbose)
  {
    (my $fullname = "$prefix/$fname") =~ tr/\//\//s;  # '//' -> '/'
    if ($fname ne "") { print STDERR "Reading options from \"$fullname\".\n"; }
    else { print STDERR "Could not read \[@_\].\n"; }
  }

  return($FILE);
}


sub open_write_from_names
{
  my $FILE;
  my $name;
  my $fullname;

  # Find out where it lives.

  for $elem (@_) { if (stat($elem) ne "") { $name = $elem; last; } }

  if ($name eq "")
  {
    # If we couldn't locate the file, and have no prefix, give up.

    # If we have a prefix, but couldn't locate the file relative to '/',
    # take the first name in the array and let that be created in $prefix.

    if ($prefix eq "")
    {
      if ($verbose) { print STDERR "No file to replace: \[@_\].\n"; }
      return(0);
    }
    else
    {
      $name = @_[0];
      if ($verbose)
      {
        (my $fullname = "$prefix/$name") =~ tr/\//\//s;
        print STDERR "Could not find \[@_\]. Writing to \"$fullname\".\n";
      }
    }
  }
  elsif ($verbose)
  {
    (my $fullname = "$prefix/$name") =~ tr/\//\//s;
    print STDERR "Found \"$name\". Writing to \"$fullname\".\n";
  }

  ($name = "$prefix/$name") =~ tr/\//\//s;  # '//' -> '/'
  create_path($name);

  # Make a backup if the file already exists - if the user specified a prefix,
  # it might not.

  if (stat($name))
  {
    # NOTE: Might not work everywhere. Might be unsafe if the user is allowed
    # to specify a $name list somehow, in the future.

    system("cp $name $name.confsave >/dev/null 2>/dev/null");
  }

  # Truncate and return filehandle.

  if (!open(FILE, ">$name") && $verbose)
  {
    print STDERR "Error: Failed to write to \"$name\". Are you root?\n";
  }

  return($FILE);
}


sub open_filter_write_from_names
{
  my $INFILE;
  my $OUTFILE;
  my $name;

  # Find out where it lives.

  for $elem (@_) { if (stat($elem) ne "") { $name = $elem; last; } }

  if ($name eq "")
  {
    # If we couldn't locate the file, and have no prefix, give up.

    # If we have a prefix, but couldn't locate the file relative to '/',
    # take the first name in the array and let that be created in $prefix.

    if ($prefix eq "")
    {
      if ($verbose) { print STDERR "No file to patch: \[@_\].\n"; }
      return(0, 0);
    }
    else
    {
      $name = @_[0];
      if ($verbose)
      {
        (my $fullname = "$prefix/$name") =~ tr/\//\//s;
        print STDERR "Could not find \[@_\]. Patching \"$fullname\".\n";
      }
    }
  }
  elsif ($verbose)
  {
    (my $fullname = "$prefix/$name") =~ tr/\//\//s;
    print STDERR "Found \"$name\". Patching \"$fullname\".\n";
  }

  ($name = "$prefix/$name") =~ tr/\//\//s;  # '//' -> '/'
  create_path($name);

  # Make a backup if the file already exists - if the user specified a prefix,
  # it might not.

  if (stat($name))
  {
    # NOTE: Might not work everywhere. Might be unsafe if the user is allowed
    # to specify a $name list somehow, in the future.

    system("cp $name $name.confsave >/dev/null 2>/dev/null");
  }

  # Return filehandles. Backup file is used as filter input. It might be
  # invalid, in which case the caller should just write to OUTFILE without
  # bothering with INFILE filtering.

  open(INFILE, "$name.confsave");

  if (!open(OUTFILE, ">$name") && $verbose)
  {
    print STDERR "Error: Failed to write to \"$name\". Are you root?\n";
  }

  return($INFILE, $OUTFILE);
}


sub create_path
{
  my $path;

  ($path = @_[0]) =~ s/^\///;      # '/etc/jall' -> 'etc/jall'
  my @pelem = split(/\//, $path);  # 'a/b/c/d/' -> 'a', 'b', 'c', 'd', ''

  for ($path = ""; @pelem; shift @pelem)
  {
    if (@pelem[0] ne "" && @pelem[1] ne "")
    {
      $path = "$path/@pelem[0]";
      mkdir($path, 0770);
    }
  }
}


# --- Configuration file manipulation --- #

# NET-3 style /etc/resolv.conf
#
# domain <domain>
# search <domain> <domain> ...
# search <domain> <domain> ...
# nameserver <IP>
# nameserver <IP>
# 
# Determines the following:
#
# - Local domain suffix
# - Search domains
# - Nameservers
#
# Exists: Red Hat [5|6].x, Caldera 2.4, TurboLinux 6.0, Mandrake 7.0, SuSE 6.3,
#         SunOS 5.7, (presumably all)
#
# Absent: (presumably none)

sub read_resolv_conf
{
  my $FILE;

  # Find the file.

  $FILE = open_read_from_names(@resolv_conf_names);
  if (not FILE) { return; }  # We didn't find it.

  # Parse the file.

  while (<FILE>)
  {
    @line = split(/[ \n\r\t]+/, $_);
    if (@line[0] eq "") { shift(@line); }  # Leading whitespace. He.

    if (@line[0] eq "domain") { $cf_domain = @line[1]; }
    elsif (@line[0] eq "search")
    {
      shift @line;
      for $elem (@line)
      {
        if (is_line_comment_start($elem)) { last; }
        if ($elem ne "") { push_unique(\@cf_searchdomains, $elem); }
      }
    }
    elsif (@line[0] eq "nameserver")
    {
      shift @line;
      for $elem (@line)
      {
        if (is_line_comment_start($elem)) { last; }
        if ($elem ne "") { push_unique(\@cf_nameservers, $elem); }
      }
    }
  }

  close(FILE);
  return;
}


sub write_resolv_conf
{
  my $FILE;

  # Find the file.

  $FILE = open_write_from_names(@resolv_conf_names);
  if (not FILE) { return; }  # We didn't find it.

  # Write the file.

  if ($cf_domain ne "")         { print FILE "domain $cf_domain\n"; }
  for $elem (@cf_searchdomains) { print FILE "search $elem\n"; }
  for $elem (@cf_nameservers)   { print FILE "nameserver $elem\n"; }

  close(FILE);
}


# NET-3 style /etc/host.conf
#
# order hosts,bind
# multi on
#
# Nothing configurable, really. We just maintain it so we can see/correct
# problems. The above is the default if nothing else is specified.
#
# Exists: Red Hat [5|6].x, Caldera 2.4, TurboLinux 6.0, Mandrake 7.0
#
# Absent: SuSE 6.3, SunOS 5.7

sub read_host_conf
{
  my $FILE;

  # Find the file.

  $FILE = open_read_from_names(@host_conf_names);
  if (not FILE) { return; }  # We didn't find it.

  # Parse the file.

  while (<FILE>)
  {
    @line = split(/[ \n\r\t,]+/, $_);
    if (@line[0] eq "") { shift(@line); }  # Leading whitespace. He.

    if (@line[0] eq "order")
    {
      shift @line;
      @cf_order = ();
      push(@cf_order, @line);
    }
    elsif (@line[0] eq "multi")
    {
      if (@line[1] eq "on")      { $cf_hostmatch = 0; }
      elsif (@line[1] eq "off")  { $cf_hostmatch = 1; }
      else                       { $cf_hostmatch = 0; }  # Unexpected; go default.
    }
  }

  close(FILE);
}


sub write_host_conf
{
  my $FILE;

  # Find the file.

  $FILE = open_write_from_names(@host_conf_names);
  if (not FILE) { return; }  # We didn't find it.

  # Write the file.

  $" = ',';

  if (@cf_order)     { print FILE "order @cf_order\n"; }
  else               { print FILE "order hosts,bind\n"; }

  $" = ' ';

  if ($cf_hostmatch) { print FILE "multi off\n"; }
  else               { print FILE "multi on\n"; }

  close(FILE);
}


# NET-3 style /etc/hosts
#
# <IP> <name> <name> ...
# <IP> <name> <name> ...
#
# These are host aliases to be used before DNS.
#
# Exists: Red Hat [5|6].x, Caldera 2.4, TurboLinux 6.0, Mandrake 7.0, SuSE 6.3,
#         SunOS 5.7, (presumably all)
#
# Absent: (presumably none)

sub read_hosts
{
  my $FILE;
  my @alias = ();

  # Find the file.

  $FILE = open_read_from_names(@hosts_names);
  if (not FILE) { return; }  # We didn't find it.

  # Parse the file.

  while (<FILE>)
  {
    @line = split(/[ \n\r\t]+/, $_);
    if (@line[0] eq "") { shift(@line); }  # Leading whitespace. He.

    if (@line[0] ne "" && (not is_line_comment_start(@line[0])) &&
        (@line[0] =~ /[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/))
    {
      push(@cf_statichosts, @line[0]);  # IP.
      shift @line;

      @alias = ();
      for $alias (@line)
      {
        if (is_line_comment_start($alias)) { last; }
        push(@alias, $alias);
      }
      push(@cf_statichosts, [@alias]);  # Alias.
    }
  }

  close(FILE);
}


sub write_hosts
{
  my $INFILE;
  my $OUTFILE;

  # Find the file.

  ($INFILE, $OUTFILE) = open_filter_write_from_names(@hosts_names);
  if (not OUTFILE) { return; }  # We didn't find it.

  # Write the file, preserving as much as possible from INFILE.

  # TODO: Replace old entries with corresponding new entries for
  # the same IP. This preserves the comment context.

  my @iplist = @cf_statichosts;

  while (<INFILE>)
  {
    @line = split(/[ \n\r\t]+/, $_);
    if (@line[0] eq "") { shift(@line); }  # Leading whitespace. He.

    if (@line[0] ne "" && (not is_line_comment_start(@line[0])) &&
        (@line[0] =~ /[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/))
    {
      # Don't print (recognized) old entries - we handle those.
    }
    else { print OUTFILE; }
  }

  # Put new entries at the end.

  while (@iplist)
  {
    if (@iplist[0] ne "")
    {
      printf OUTFILE ("%-16s", @iplist[0]);

      my $aliaslist = @iplist[1];
      for $alias (@$aliaslist) { print OUTFILE " $alias"; }

      print OUTFILE "\n";
    }

    shift @iplist;
    shift @iplist;
  }

  close(OUTFILE);
}


# Red Hat style /etc/sysconfig/network
#
# <filtered lines>
# HOSTNAME=<hostname>
# DOMAINNAME=<domainname>
# <filtered lines>
#
# Determines the local hostname and domain. BEWARE: This is actually a sourced
# shell script. We rely on some lenience from the user (and the distro) to
# be able to parse it correctly.
#
# Exists: Red Hat [5|6].x, Caldera 2.4, TurboLinux 6.0, Mandrake 7.0
#
# Absent: SuSE 6.3, SunOS 5.7

sub read_sysconfig_network
{
  my $FILE;

  # Find the file.

  $FILE = open_read_from_names(@sysconfig_network_names);
  if (not FILE) { return; }  # We didn't find it.

  # Parse the file.

  while (<FILE>)
  {
    @line = split(/[ \n\r\t\"\'=]+/, $_);
    if (@line[0] eq "") { shift(@line); }  # Leading whitespace. He.

    if (@line[0] eq "HOSTNAME" && not is_line_comment_start(@line[1]))
    { $cf_hostname = @line[1]; }
    elsif (@line[0] eq "DOMAINNAME" && not is_line_comment_start(@line[1]))
    { $cf_domain = @line[1]; }
  }

  close(FILE);
}


sub write_sysconfig_network
{
  my $INFILE;
  my $OUTFILE;
  my $wrote_hostname = 0;
  my $wrote_domain = 0;

  # Find the file.

  ($INFILE, $OUTFILE) = open_filter_write_from_names(@sysconfig_network_names);
  if (not OUTFILE) { return; }  # No point if we can't write.

  # Write the file, preserving as much as possible from INFILE.

  while (<INFILE>)
  {
    @line = split(/[ \n\r\t\"\'=]+/, $_);
    if (@line[0] eq "") { shift(@line); }  # Leading whitespace. He.

    if (@line[0] eq "HOSTNAME")
    {
      print OUTFILE "HOSTNAME=$cf_hostname\n";
      $wrote_hostname = 1;
    }
    elsif (@line[0] eq "DOMAINNAME")
    {
      print OUTFILE "DOMAINNAME=$cf_domain\n";
      $wrote_domain = 1;
    }
    else { print OUTFILE; }
  }

  if (not $wrote_hostname) { print OUTFILE "HOSTNAME=$cf_hostname\n"; }
  if (not $wrote_domain)   { print OUTFILE "DOMAINNAME=$cf_domain\n"; }

  close(OUTFILE);
  if (INFILE) { close(INFILE); }
}


# SuSE style /etc/rc.config
#
# <filtered lines>
# FQHOSTNAME="<fully qualified hostname>"
# SEARCHLIST="<space separated list of searchdomains>"
# NAMESERVER="<space separated list of nameservers>"
# <filtered lines>
#
# Determines the local hostname.domain, searchdomains and nameservers.
# BEWARE: This is actually a sourced shell script. We rely on some lenience
# from the user (and the distro) to be able to parse it correctly. The file
# is read by SuSE configuration tools and translated to NET-3 config files
# at strategic times.
#
# Exists: SuSE 6.3
#
# Absent: Red Hat 6.x, Caldera 2.4, TurboLinux 6.0, Mandrake 7.0, SunOS 5.7

sub read_rc_config
{
  my $FILE;

  # Find the file.

  $FILE = open_read_from_names(@rc_config_names);
  if (not FILE) { return; }  # We didn't find it.

  # Parse the file.

  # The code for SEARCHLIST and NAMESERVER is basically the same as in
  # read_resolv_conf, only the splitting is different.

  while (<FILE>)
  {
    @line = split(/[ \n\r\t\"\'=]+/, $_);  # Handles quoted arguments.
    if (@line[0] eq "") { shift(@line); }  # Leading whitespace. He.

    if (@line[0] eq "FQHOSTNAME" && not is_line_comment_start(@line[1]))
    {
      $cf_hostname = @line[1];
    }
    elsif (@line[0] eq "SEARCHLIST")
    {
      shift @line;
      for $elem (@line)
      {
        if (is_line_comment_start($elem)) { last; }
        if ($elem ne "") { push_unique(\@cf_searchdomains, $elem); }
      }
    }
    elsif (@line[0] eq "NAMESERVER")
    {
      shift @line;
      for $elem (@line)
      {
        if (is_line_comment_start($elem)) { last; }
        if ($elem ne "") { push_unique(\@cf_nameservers, $elem); }
      }
    }
  }

  close(FILE);
}


# SuSE /etc/rc.config likes all env arguments in double quotes. Since we're
# really nice guys, we conform to that.

sub write_rc_config
{
  my $INFILE;
  my $OUTFILE;
  my $wrote_hostname = 0;
  my $wrote_searchdomains = 0;
  my $wrote_nameservers = 0;

  # Find the file.

  ($INFILE, $OUTFILE) = open_filter_write_from_names(@rc_config_names);
  if (not OUTFILE) { return; }  # No point if we can't write.

  # Write the file, preserving as much as possible from INFILE.

  while (<INFILE>)
  {
    @line = split(/[ \n\r\t\"\'=]+/, $_);
    if (@line[0] eq "FQHOSTNAME")
    {
      print OUTFILE "FQHOSTNAME=\"$cf_hostname\"\n";  # FIXME: Needs to be fully qualified.
      $wrote_hostname = 1;
    }
    elsif (@line[0] eq "SEARCHLIST")
    {
      print OUTFILE "SEARCHLIST=\"@cf_searchdomains\"\n";
      $wrote_searchdomains = 1;
    }
    elsif (@line[0] eq "NAMESERVER")
    {
      print OUTFILE "NAMESERVER=\"@cf_nameservers\"\n";
      $wrote_nameservers = 1;
    }
    else
    {
      print OUTFILE;
    }
  }

  if (not $wrote_hostname)      { print OUTFILE "FQHOSTNAME=\"$cf_hostname\"\n"; }
  if (not $wrote_searchdomains) { print OUTFILE "SEARCHLIST=\"$cf_searchdomains\"\n"; }
  if (not $wrote_nameservers)   { print OUTFILE "NAMESERVER=\"$cf_nameservers\"\n"; }

  close(OUTFILE);
  if (INFILE) { close(INFILE); }
}


# Samba /etc/smb.conf
#
# <filtered lines>
# workgroup = <workgroup>
# server string = <description>
# <filtered lines>
#
# Exists: (Wherever Samba is installed)
#
# Absent: (Wherever Samba is not installed)

sub read_smb_conf
{
  my $FILE;

  # Find the file.

  $FILE = open_read_from_names(@smb_conf_names);
  if (not FILE) { return; }  # We didn't find it.

  # Parse the file.

  while (<FILE>)
  {
    @line = split(/[ \n\r\t=]+/, $_);
    if (@line[0] eq "") { shift(@line); }  # Leading whitespace. He.

    if (@line[0] eq "workgroup" && not is_line_comment_start(@line[1]))
    {
      $cf_workgroup = @line[1];
    }
    elsif (@line[0] eq "serverstring" && not is_line_comment_start(@line[1]))
    {
      shift @line;
      $cf_description = join(' ', @line);
    }
    elsif (@line[0] eq "server" && @line[1] eq "string" && not is_line_comment_start(@line[2]))
    {
      shift @line; shift @line;
      $cf_description = join(' ', @line);
    }
    elsif (@line[0] eq "winsserver" && not is_line_comment_start(@line[1]))
    {
      $cf_winsserver = @line[1];
    }
    elsif (@line[0] eq "wins" && @line[1] eq "server" && not is_line_comment_start(@line[2]))
    {
      $cf_winsserver = @line[2];
    }
  }

  close(FILE);
}


sub write_smb_conf
{
  my $INFILE;
  my $OUTFILE;
  my $wrote_workgroup = 0;
  my $wrote_description = 0;
  my $wrote_winsserver = 0;
  my $block = "";

  # Find the file.

  ($INFILE, $OUTFILE) = open_filter_write_from_names(@smb_conf_names);
  if (not OUTFILE) { return; }  # No point if we can't write.

  # Write the file, preserving as much as possible from INFILE.

  while (<INFILE>)
  {
    @line = split(/[ \n\r\t=]+/, $_);
    if (@line[0] eq "") { shift(@line); }  # Leading whitespace. He.

    if ((@line[0] =~ /\[.*\]/))
    {
      # New block.

      if ($block eq "[global]")
      {
        # These need to be written before exiting the [global] block.

        if (not $wrote_workgroup)
        { print OUTFILE "workgroup = $cf_workgroup\n"; $wrote_workgroup = 1; }
        if (not $wrote_description)
        { print OUTFILE "server string = $cf_description\n"; $wrote_description = 1; }
        if ((not $wrote_winsserver) && $cf_winsserver ne "")
        { print OUTFILE "wins server = $cf_winsserver\n"; $wrote_winsserver = 1; }
      }

      $block = @line[0];
    }

    if (@line[0] eq "workgroup" && not is_line_comment_start(@line[1]))
    {
      print OUTFILE "workgroup = $cf_workgroup\n";
      $wrote_workgroup = 1;
    }
    elsif (@line[0] eq "serverstring" && not is_line_comment_start(@line[1]))
    {
      print OUTFILE "serverstring = $cf_description\n";
      $wrote_description = 1;
    }
    elsif (@line[0] eq "server" && @line[1] eq "string" && not is_line_comment_start(@line[2]))
    {
      print OUTFILE "server string = $cf_description\n";
      $wrote_description = 1;
    }
    elsif (@line[0] eq "winsserver" && not is_line_comment_start(@line[1]))
    {
      print OUTFILE "winsserver = $cf_winsserver\n";
      $wrote_winsserver = 1;
    }
    elsif (@line[0] eq "wins" && @line[1] eq "server" && not is_line_comment_start(@line[2]))
    {
      if ($cf_winsserver ne "") { print OUTFILE "wins server = $cf_winsserver\n"; }
      $wrote_winsserver = 1;
    }
    else
    {
      print OUTFILE;
    }
  }

  if (not $wrote_workgroup)                             { print OUTFILE "workgroup = $cf_workgroup\n"; }
  if (not $wrote_description)                           { print OUTFILE "server string = $cf_description\n"; }
  if ((not $wrote_winsserver) && $cf_winsserver ne "")  { print OUTFILE "wins server = $cf_winsserver\n"; }

  close(OUTFILE);
  if (INFILE) { close(INFILE); }
}


# --- XML parsing --- #


# Scan XML from standard input to an internal tree.

sub xml_parse
{
  # Scan XML to tree.

  $tree = xml_scan;

  # Walk the tree recursively and extract configuration parameters.
  # This is the top level - find and enter the "resolving" tag.

  while (@$tree)
  {
    if (@$tree[0] eq "nameresolution") { xml_parse_resolving(@$tree[1]); }

    shift @$tree;
    shift @$tree;
  }

  return($tree);
}


# <resolving>...</resolving>

sub xml_parse_resolving
{
  my $tree = @_[0];

  shift @$tree;  # Skip attributes.

  while (@$tree)
  {
    if    (@$tree[0] eq "hostname")        { $cf_hostname = xml_get_word(@$tree[1]); }
    elsif (@$tree[0] eq "domain")          { $cf_domain = xml_get_word(@$tree[1]); }
    elsif (@$tree[0] eq "hostnamereverse") { $cf_hostname_reverse = xml_get_word(@$tree[1]); }
    elsif (@$tree[0] eq "domainreverse")   { $cf_domain_reverse = xml_get_word(@$tree[1]); }
    elsif (@$tree[0] eq "workgroup")       { $cf_workgroup = xml_get_word(@$tree[1]); }
    elsif (@$tree[0] eq "description")     { $cf_description = xml_get_text(@$tree[1]); }
    elsif (@$tree[0] eq "winsserver")      { $cf_winsserver = xml_get_word(@$tree[1]); }
    elsif (@$tree[0] eq "searchdomain")    { push(@cf_searchdomains, xml_get_word(@$tree[1])); }
    elsif (@$tree[0] eq "nameserver")      { push(@cf_nameservers, xml_get_word(@$tree[1])); }
    elsif (@$tree[0] eq "statichost")      { xml_parse_statichost(@$tree[1]); }
    elsif (@$tree[0] eq "order")           { xml_parse_order(@$tree[1]); }
    elsif (@$tree[0] eq "hostmatch")       { xml_parse_hostmatch(@$tree[1]); }

    shift @$tree;
    shift @$tree;
  }
}


# <resolving><statichost>...</statichost></resolving>

sub xml_parse_statichost
{
  my $tree = @_[0];
  my $ip;
  my @alias;

  shift @$tree;  # Skip attributes.

  while (@$tree)
  {
    if    (@$tree[0] eq "ip")    { $ip = xml_get_word(@$tree[1]); }
    elsif (@$tree[0] eq "alias") { push(@alias, xml_get_word(@$tree[1])); }

    shift @$tree;
    shift @$tree;
  }

  if ($ip =~ /[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/)
  {
    push(@cf_statichosts, $ip);
    push(@cf_statichosts, [@alias]);
  }
  else
  {
    # Print warning message: IP is not well-formed.
  }
}


# <resolving><order>...</order></resolving>

sub xml_parse_order
{
  my $tree = @_[0];

  shift @$tree;  # Skip attributes.

  while (@$tree)
  {
    if (@$tree[0] eq "") { shift @$tree; shift @$tree; next; }
    push(@cf_order, @$tree[0]);

    shift @$tree;
    shift @$tree;
  }
}


# <resolving><hostmatch return=... /></resolving>

sub xml_parse_hostmatch
{
  my $tree = @_[0];

  # Check attribute; 'all' or 'first'.

  if (@$tree[0]->{return} eq "all") { $cf_hostmatch = 0; }
  else { $cf_hostmatch = 1; }
}


# Compresses node into a word and returns it.

sub xml_get_word
{
  my $tree = @_[0];

  shift @$tree;  # Skip attributes.

  while (@$tree)
  {
    if (@$tree[0] == 0)
    {
      my $retval;

      ($retval = @$tree[1]) =~ tr/ \n\r\t\f//d;
      $retval = xml_entities_to_plain(\$retval);
      return($retval);
    }

    shift @$tree;
    shift @$tree;
  }

  return("");
}


# Replaces misc. whitespace with spaces and returns text.

sub xml_get_text
{
  my $tree = @_[0];

  shift @$tree;  # Skip attributes.

  while (@$tree)
  {
    if (@$tree[0] = 0)
    {
      ($retval = @$tree[1]) =~ tr/\n\r\t\f/    /;
      $retval = xml_entities_to_plain(\$retval);
      return($retval);
    }

    shift @$tree;
    shift @$tree;
  }
}


# --- XML printing --- #


sub xml_print
{
  my $cfl_hostname = xml_plain_to_entities(\$cf_hostname);
  my $cfl_domain = xml_plain_to_entities(\$cf_domain);
  my $cfl_workgroup = xml_plain_to_entities(\$cf_workgroup);
  my $cfl_description = xml_plain_to_entities(\$cf_description);
  my $cfl_winsserver = xml_plain_to_entities(\$cf_winsserver);
  my $cfl_hostname_reverse = xml_plain_to_entities(\$cf_hostname_reverse);
  my $cfl_domain_reverse = xml_plain_to_entities(\$cf_domain_reverse);

  print "<?xml version='1.0' encoding='ISO-8859-1' standalone='yes'?>\n";
  print "<!DOCTYPE nameresolution []>\n\n";
  print "<nameresolution>\n";
  enter;

  vspace;
  indent; print "<!-- Configuration starts here -->\n";
  vspace;

  # Hostname, domain, search domains, nameservers.

  if ($cfl_hostname ne "") { indent; print "<hostname>$cfl_hostname</hostname>\n"; }
  if ($cfl_domain ne "") { indent; print "<domain>$cfl_domain</domain>\n"; }
  if ($cfl_workgroup ne "") { indent; print "<workgroup>$cfl_workgroup</workgroup>\n"; }
  if ($cfl_description ne "") { indent; print "<description>$cfl_description</description>\n"; }
  vspace;
  if ($cfl_winsserver ne "") { indent; print "<winsserver>$cfl_winsserver</winsserver>\n"; }
  vspace;

  for $elem (@cf_searchdomains)
  {
    $elem = xml_plain_to_entities(\$elem);
    indent; print "<searchdomain>$elem</searchdomain>\n";
  }

  vspace;

  for $elem (@cf_nameservers)
  {
    $elem = xml_plain_to_entities(\$elem);
    indent; print "<nameserver>$elem</nameserver>\n";
  }

  # Static hosts.

  my @iplist = @cf_statichosts;
  while (@iplist)
  {
    if (@iplist[0] ne "")
    {
      vspace;
      indent; print "<statichost>\n";
      enter;

      @iplist[0] = xml_plain_to_entities(\@iplist[0]);

      indent; print "<ip>@iplist[0]</ip>\n";

      my $aliaslist = @iplist[1];
      for $alias (@$aliaslist)
      {
        $alias = xml_plain_to_entities(\$alias);
        indent; print "<alias>$alias</alias>\n";
      }

      leave;
      indent; print "</statichost>\n";
    }

    shift @iplist;
    shift @iplist;
  }

  vspace;
  indent; print "<!-- You shouldn't have to modify anything below this line -->\n";
  vspace;

  # Search order and host matches (multi).

  indent; print "<order>";
  for $elem (@cf_order) { print "<$elem/>"; }
  print "</order>\n";

  indent;
  if ($cf_hostmatch) { print "<hostmatch return='first'/>\n"; }
  else               { print "<hostmatch return='all'/>\n"; }

  vspace;
  indent; print "<!-- You cannot modify anything below this line -->\n";
  vspace;

  if ($cfl_hostname_reverse ne "")
  {
    indent; print "<hostnamereverse>$cfl_hostname_reverse</hostnamereverse>\n";
  }

  if ($cfl_domain_reverse ne "")
  {
    indent; print "<domainreverse>$cfl_domain_reverse</domainreverse>\n";
  }

  vspace;
  indent; print "<!-- End of configuration -->\n";
  vspace;

  leave;
  print "</nameresolution>\n";
}


# --- Get (read) config --- #


sub get_immediate
{
  # This is rather unethical. Have to find some reasonable defaults on non-(GNU/Linux)
  # systems. It'll have to do for now.

  # If any of this fails, the worst that can happen is that the reverse names
  # get set to empty strings, which is the expected action when they're unknown.

  my $ip = `ifconfig eth0 2>/dev/null`;
  if ($ip eq "") { $ip = `ifconfig ppp0 2>/dev/null`; }

  $ip =~ /^.*addr:([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)/m;
  $ip = $1;

  if ($ip eq "")
  {
    if ($verbose) { print STDERR "Warning: Couldn't find a configured network device.\n"; }
    return(0);
  }

  # Succeeds only if we get an FQDN. This is probably the right thing to do.

  $cf_hostname_reverse = `nslookup -timeout=1 -retry=2 $ip 2>/dev/null`;
  $cf_hostname_reverse =~ /^Name:[ \t]+([a-zA-Z0-9]+)\.([a-zA-Z0-9.]+)$/mg;
  $cf_hostname_reverse = $1;
  $cf_domain_reverse = $2;

  if (($cf_domain_reverse eq "" || $cf_hostname_reverse eq "") && $verbose)
  {
    print STDERR "Warning: Couldn't get reverse names for this host.\n";
  }
}


sub get
{
  if ($verbose) { print STDERR "Getting system configuration, generating XML output.\n"; }

  read_host_conf;
  read_hosts;
  read_resolv_conf;
  read_sysconfig_network;
  read_rc_config;
  read_smb_conf;

  if ($verbose) { print STDERR "Getting reverse names.\n"; }
  get_immediate;

  if ($verbose) { print STDERR "Printing XML.\n"; }
  xml_print;
}


# --- Set (write) config --- #


sub set_immediate
{
  # Set hostname via utility, in case the config files aren't enough.

  if (!system "which hostname >/dev/null 2>/dev/null")
  {
    # Found hostname command.

    if ($cf_hostname ne "")
    {
      if (system "hostname $cf_hostname >/dev/null 2>/dev/null")
      {
	if ($verbose) { print STDERR "Warning: Failed to set runtime hostname. Are you root?\n"; }
      }
      elsif ($verbose)
      {
        print STDERR "Runtime hostname set.\n";
      }
    }
    elsif ($verbose)
    {
      print STDERR "Warning: No hostname specified; runtime hostname not set.\n";
    }
  }
  elsif ($verbose)
  {
    print STDERR "Warning: No hostname command found; runtime hostname not set.\n";
  }

  # Reload SMB configuration.

  if (-f "/etc/rc.d/init.d/smb")
  {
    if (system "/etc/rc.d/init.d/smb reload >/dev/null 2>/dev/null")
    {
      if ($verbose) { print STDERR "Warning: SMB configuration reload failed.\n"; }
      if (system "/etc/rc.d/init.d/smb restart >/dev/null 2>/dev/null")
      {
        if ($verbose) { print STDERR "Warning: SMB restart failed.\n"; }
      }
    }
    elsif ($verbose)
    {
      print STDERR "SMB told to reload its configuration.\n";
    }
  }
  elsif ($verbose)
  {
    print STDERR "Warning: Could not find a way to restart SMB services.\n";
  }
}


sub set
{
  if ($verbose) { print STDERR "Setting system configuration from XML input.\n"; }

  if ($verbose) { print STDERR "Parsing XML.\n"; }
  xml_parse;

  write_smb_conf;
  write_rc_config;
  write_sysconfig_network;
  write_resolv_conf;
  write_hosts;
  write_host_conf;

  if ($do_immediate)
  {
    if ($verbose) { print STDERR "Changing running configuration via local utilities.\n"; }
    set_immediate;
  }
}


# --- Filter config: XML in, XML out --- #


sub filter
{
  xml_parse;
  xml_print;
}


# --- Main --- #

$operation = "";  # Major operation user wants to perform. [get | set | filter]


sub set_operation
{
  if ($operation ne "")
  {
    print STDERR "Error: You may specify only one major operation.\n\n";
    print STDERR $Usage;
    exit(1);
  }

  $operation = @_[0];
}


# Process options.

while (@ARGV)
{
  if    (@ARGV[0] eq "--get"     || @ARGV[0] eq "-g") { set_operation("get"); }
  elsif (@ARGV[0] eq "--set"     || @ARGV[0] eq "-s") { set_operation("set"); }
  elsif (@ARGV[0] eq "--filter"  || @ARGV[0] eq "-f") { set_operation("filter"); }
  elsif (@ARGV[0] eq "--help"    || @ARGV[0] eq "-h") { print $Usage; exit(0); }
  elsif (@ARGV[0] eq "--version")                     { print "$version\n"; exit(0); }
  elsif (@ARGV[0] eq "--prefix"  || @ARGV[0] eq "-p")
  {
    if ($prefix ne "")
    {
      print STDERR "Error: You may specify --prefix only once.\n\n";
      print STDERR $Usage; exit(1);
    }

    $prefix = @ARGV[1];

    if ($prefix eq "")
    {
      print STDERR "Error: You must specify an argument to the --prefix option.\n\n";
      print STDERR $Usage; exit(1);
    }

    shift @ARGV;  # For the argument.
  }
  elsif (@ARGV[0] eq "--disable-immediate")           { $do_immediate = 0; }
  elsif (@ARGV[0] eq "--verbose" || @ARGV[0] eq "-v") { $verbose = 1; }
  else
  {
    print STDERR "Error: Unrecognized option '@ARGV[0]'.\n\n";
    print STDERR $Usage; exit(1);
  }

  shift @ARGV;
}


# Do our thing.

if    ($operation eq "get")    { get; }
elsif ($operation eq "set")    { set; }
elsif ($operation eq "filter") { filter; }
else
{
  print STDERR "Error: No operation specified.\n\n";
  print STDERR $Usage; exit(1);
}

