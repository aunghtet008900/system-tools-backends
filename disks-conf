#!/usr/bin/perl

# Simple fixed media configurator. Designed to be architecture- and distribution independent.
#
# Copyright (C) 2000 Helix Code, Inc.
#
# Authors: Hans Petter Jansson <hpj@helixcode.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

# Best viewed with 100 columns of width.

# Configuration files affected:
#
# /etc/fstab

# Running programs affected/used:
#
# fdisk
# mount


# --- Usage text --- #

my $Usage =<<"End_of_Usage;";
Usage: disks-conf <--get | --set | --filter | --help>
                  [--prefix <location>] [--disable-immediate]
                  [--verbose]

       Major operations (specify one of these):

       -g --get      Prints the current fixed media configuration to
                     standard output, as as standalone XML document. The
                     configuration is read from the host\'s system config
                     files.

       -s --set      Updates the system fixed media configuration from
                     a standalone XML document read from standard input.
                     The format is the same as for the document generated
                     with --get.

       -f --filter   Reads XML configuration from standard input, parses it,
                     and writes the configurator\'s impression of it back to
                     standard output. Good for debugging and parsing tests.

       -h --help     Prints this page to standard output.

          --version  Prints version information to standard output.

       Modifiers (specify any combination of these):

       -p --prefix <location>  Specifies a directory prefix where the
                     configuration is looked for or stored. When storing
                     (with --set), directories and files may be created.

          --disable-immediate  With --set, prevents the configurator from
                     running any commands that make immediate changes to
                     the system configuration. Use with --prefix to make a
                     dry run that won\'t affect your configuration.

                     With --get, suppresses running of non-vital external
                     programs that might take a long time to finish.

       -v --verbose  Turns on diagnostic messages to standard error.

          --progress Prints progress information suitable for interactive
                     frontends to standard output. The progress information
                     is printed before any XML, and consists of a decimal
                     number saying how many dots to expect, followed by a
                     newline, and a running line of dots as the operation
                     progresses, followed by a newline after the last dot.
                     The dots generated can be more or less than the
                     number indicated on the first line.

End_of_Usage;

$version = "0.1.0";

$progress_max = 16;


# --- System config file locations --- #

# We list each config file type with as many alternate locations as possible.
# They are tried in array order. First found = used.

# Right now there's only one entry per array, as I couldn't find any
# typical deviations.

@fstab_names = ( "/etc/fstab" );


# --- Internal configuration variables --- #

# Configuration is parsed/read to, and printed/written from, these temporary variables.

@cf_disks = ();


# --- Operation modifying variables --- #

# Variables are set to their default value, which may be overridden by user. Note
# that a $prefix of "" will cause the configurator to use '/' as the base path,
# and disables creation of directories and writing of previously non-existent
# files.

$prefix = "";
$verbose = 0;
$progress = 0;
$do_immediate = 1;


# --- Progress printing --- #


sub print_progress
{
  if ($progress) { print "."; }
}


# --- XML print formatting  --- #

# enter: Call after entering a block. Increases indent level.
# leave: Call before leaving a block. Decreases indent level.
# indent: Call before printing a line. Indents to current level. 
# vspace: Ensures there is a vertical space of one and only one line.

$indent_level = 0;
$have_vspace = 0;

sub enter  { $indent_level += 2; }
sub leave  { $indent_level -= 2; }
sub indent { for ($i = 0; $i < $indent_level; $i++) { print " "; } $have_vspace = 0; }
sub vspace { if (not $have_vspace) { print "\n"; $have_vspace = 1; } }


# --- XML scanning --- #

# This code tries to replace XML::Parser scanning from stdin in tree mode.


@xml_scan_list;


sub xml_scan_make_kid_array
{
  my %hash = {};
  my @sublist;

  @attr = @_[0] =~ /[^\t\n\r ]+[\t\n\r ]*([a-zA-Z]+)[ \t\n\r]*\=[ \t\n\r\"\']*([a-zA-Z]+)/g;
  %hash = @attr;

  push(@sublist, \%hash);
  return(\@sublist);
}


sub xml_scan_recurse;

sub xml_scan_recurse
{
  my @list;
  if (@_) { @list = @_[0]->[0]; }

  while (@xml_scan_list)
  {
    $el = @xml_scan_list[0]; shift @xml_scan_list;

    if ((not $el) || $el =~ /^\<[!?].*\>$/s) { next; }  # Empty strings, PI and DTD must go.

    if ($el =~ /^\<.*\/\>$/s)     # Empty.
    {
      $el =~ /^\<([a-zA-Z]+).*\/\>$/s;
      push(@list, $1);
      push(@list, xml_scan_make_kid_array($el));
    }
    elsif ($el =~ /^\<\/.*\>$/s)  # End.
    {
      last;
    }
    elsif ($el =~ /^\<.*\>$/s)    # Start.
    {
      $el =~ /^\<([a-zA-Z]+).*\>$/s;
      push(@list, $1);
      $sublist = xml_scan_make_kid_array($el);
      push(@list, xml_scan_recurse($sublist));
      next;
    }
    elsif ($el ne "")             # PCDATA.
    {
      push(@list, 0);
      push(@list, "$el");
    }
  }

  return(\@list);
}


sub xml_scan
{
  my $doc; my @tree;
  read STDIN, $doc, 512000;  # Read in document (FIXME: ugly).
  @xml_scan_list = ($doc =~ /([^\<]*)(\<[^\>]*\>)[ \t\n\r]*/mg);  # pcdata, tag, pcdata, tag, ...

  $tree = xml_scan_recurse;

  return($tree);

#  $" = "\n";
#  print "@list\n";
}


@xml_entities = ( "&lt;", '<', "&gt;", '>', "&apos;", '\'', "&quot;", '"' );

sub xml_entities_to_plain
{
  my $in = @_[0];
  my $out = "";
  my @xe;

  $in = $$in;

  my @elist = ($in =~ /([^&]*)(\&[a-zA-Z]+\;)?/mg);  # text, entity, text, entity, ...

  while (@elist)
  {
    # Join text.

    $out = join('', $out, @elist[0]);
    shift @elist;
    
    # Find entity and join its text equivalent.
    # Unknown entities are simply removed.

    for (@xe = @xml_entities; @xe; )
    {
      if (@xe[0] eq @elist[0]) { $out = join('', $out, @xe[1]); last; }
      shift @xe; shift @xe;
    }

    shift @elist;
  }

  return($out);
}


sub xml_plain_to_entities
{
  my $in = @_[0];
  my $out = "";
  my @xe;
  my $joined = 0;

  $in = $$in;

  my @clist = split(//, $in);

  while (@clist)
  {
    # Find character and join its entity equivalent.
    # If none found, simply join the character.

    $joined = 0;  # Cumbersome.

    for (@xe = @xml_entities; @xe && !$joined; )
    {
      if (@xe[1] eq @clist[0]) { $out = join('', $out, @xe[0]); $joined = 1; }
      shift @xe; shift @xe;
    }

    if (!$joined) { $out = join('', $out, @clist[0]); }
    shift @clist;
  }

  return($out);
}


# --- String and array manipulation --- #

# Boolean/strings conversion.

sub read_boolean
{
  if (@_[0] eq "true") { return(1); }
  elsif (@_[0] eq "yes") { return(1); }
  return(0);
}

sub print_boolean_yesno
{
  if (@_[0] == 1) { return("yes"); }
  return("no");
}

sub print_boolean_truefalse
{
  if (@_[0] == 1) { return("true"); }
  return("false");
}


# Pushes a value to an array, only if it's not already in there.
# I'm sure there's a smarter way to do this. Should only be used for small lists,
# as it's O(N^2). Larger lists with unique members should use a hash.

sub push_unique
{
  my $arr = @_[0];
  my $found;
  my $i;

  # Go through all elements in pushed list.

  for ($i = 1; @_[$i]; $i++)
  {
    # Compare against all elements in destination array.

    $found = "";
    for $elem (@$arr)
    {
      if ($elem eq @_[$i]) { $found = $elem; last; }
    }

    if ($found eq "") { push(@$arr, @_[$i]); }
  }
}


sub is_line_comment_start
{
  if (@_[0] =~ /^\#/) { return(1); }
  return(0);
}


# --- IP calculation --- #

# Both functions take two arguments: IP and netmask.


sub ip_calc_network
{
  my @ip_reg1;
  my @ip_reg2;

  @ip_reg1 = (@_[0] =~ /([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)/);
  @ip_reg2 = (@_[1] =~ /([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)/);
  
  @ip_reg1[0] = (@ip_reg1[0] * 1) & (@ip_reg2[0] * 1);
  @ip_reg1[1] = (@ip_reg1[1] * 1) & (@ip_reg2[1] * 1);
  @ip_reg1[2] = (@ip_reg1[2] * 1) & (@ip_reg2[2] * 1);
  @ip_reg1[3] = (@ip_reg1[3] * 1) & (@ip_reg2[3] * 1);
  
  return(join('.', @ip_reg1));
}


sub ip_calc_broadcast
{
  my @ip_reg1;
  my @ip_reg2;

  @ip_reg1 = (@_[0] =~ /([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)/);
  @ip_reg2 = (@_[1] =~ /([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)/);
  
  @ip_reg1 = ($cf_hostip =~ /([0-9]+)\.([0-9]+)\.([0-9]+)\.([0-9]+)/);

  @ip_reg1[0] = (@ip_reg1[0] * 1) | (~(@ip_reg2[0] * 1) & 255);
  @ip_reg1[1] = (@ip_reg1[1] * 1) | (~(@ip_reg2[1] * 1) & 255);
  @ip_reg1[2] = (@ip_reg1[2] * 1) | (~(@ip_reg2[2] * 1) & 255);
  @ip_reg1[3] = (@ip_reg1[3] * 1) | (~(@ip_reg2[3] * 1) & 255);

  return(join('.', @ip_reg1));
}


# --- File operations --- #

@builtin_paths = ( "/sbin", "/usr/sbin", "/usr/local/sbin", "/bin", "/usr/bin",
                   "/usr/local/bin" );

sub locate_tool
{
  my $found = "";
  my @user_paths;

  # Extract user paths to try.

  @user_paths = ($ENV{PATH} =~ /([^:]+):/mg);

  # Try user paths.

  for $path (@user_paths)
  {
    if (-x "$path/@_[0]") { $found = "$path/@_[0]"; last; }
  }

  # Try builtin paths.

  for $path (@builtin_paths)
  {
    if (-x "$path/@_[0]") { $found = "$path/@_[0]"; last; }
  }
  
  return($found);
}


sub open_read_from_names
{
  my $FILE;
  my $fname = "";

  for $name (@_)
  {
    if (open(FILE, "$prefix/$name")) { $fname = $name; last; }
  }

  if ($verbose)
  {
    (my $fullname = "$prefix/$fname") =~ tr/\//\//s;  # '//' -> '/'
    if ($fname ne "") { print STDERR "Reading options from \"$fullname\".\n"; }
    else { print STDERR "Could not read \[@_\].\n"; }
  }

  return($FILE);
}


sub open_write_from_names
{
  my $FILE;
  my $name;
  my $fullname;

  # Find out where it lives.

  for $elem (@_) { if (stat($elem) ne "") { $name = $elem; last; } }

  if ($name eq "")
  {
    # If we couldn't locate the file, and have no prefix, give up.

    # If we have a prefix, but couldn't locate the file relative to '/',
    # take the first name in the array and let that be created in $prefix.

    if ($prefix eq "")
    {
      if ($verbose) { print STDERR "No file to replace: \[@_\].\n"; }
      return(0);
    }
    else
    {
      $name = @_[0];
      if ($verbose)
      {
        (my $fullname = "$prefix/$name") =~ tr/\//\//s;
        print STDERR "Could not find \[@_\]. Writing to \"$fullname\".\n";
      }
    }
  }
  elsif ($verbose)
  {
    (my $fullname = "$prefix/$name") =~ tr/\//\//s;
    print STDERR "Found \"$name\". Writing to \"$fullname\".\n";
  }

  ($name = "$prefix/$name") =~ tr/\//\//s;  # '//' -> '/'
  create_path($name);

  # Make a backup if the file already exists - if the user specified a prefix,
  # it might not.

  if (stat($name))
  {
    # NOTE: Might not work everywhere. Might be unsafe if the user is allowed
    # to specify a $name list somehow, in the future.

    system("cp $name $name.confsave >/dev/null 2>/dev/null");
  }

  # Truncate and return filehandle.

  if (!open(FILE, ">$name") && $verbose)
  {
    print STDERR "Error: Failed to write to \"$name\". Are you root?\n";
  }

  return($FILE);
}


sub open_filter_write_from_names
{
  my $INFILE;
  my $OUTFILE;
  my $name;

  # Find out where it lives.

  for $elem (@_) { if (stat($elem) ne "") { $name = $elem; last; } }

  if ($name eq "")
  {
    # If we couldn't locate the file, and have no prefix, give up.

    # If we have a prefix, but couldn't locate the file relative to '/',
    # take the first name in the array and let that be created in $prefix.

    if ($prefix eq "")
    {
      if ($verbose) { print STDERR "No file to patch: \[@_\].\n"; }
      return(0, 0);
    }
    else
    {
      $name = @_[0];
      if ($verbose)
      {
        (my $fullname = "$prefix/$name") =~ tr/\//\//s;
        print STDERR "Could not find \[@_\]. Patching \"$fullname\".\n";
      }
    }
  }
  elsif ($verbose)
  {
    (my $fullname = "$prefix/$name") =~ tr/\//\//s;
    print STDERR "Found \"$name\". Patching \"$fullname\".\n";
  }

  ($name = "$prefix/$name") =~ tr/\//\//s;  # '//' -> '/'
  create_path($name);

  # Make a backup if the file already exists - if the user specified a prefix,
  # it might not.

  if (stat($name))
  {
    # NOTE: Might not work everywhere. Might be unsafe if the user is allowed
    # to specify a $name list somehow, in the future.

    system("cp $name $name.confsave >/dev/null 2>/dev/null");
  }

  # Return filehandles. Backup file is used as filter input. It might be
  # invalid, in which case the caller should just write to OUTFILE without
  # bothering with INFILE filtering.

  open(INFILE, "$name.confsave");

  if (!open(OUTFILE, ">$name") && $verbose)
  {
    print STDERR "Error: Failed to write to \"$name\". Are you root?\n";
  }

  return($INFILE, $OUTFILE);
}


sub create_path
{
  my $path;

  $path = @_[0];
  my @pelem = split(/\//, $path);  # 'a/b/c/d/' -> 'a', 'b', 'c', 'd', ''

  for ($path = ""; @pelem; shift @pelem)
  {
    if (@pelem[1] ne "")
    {
      $path = "$path@pelem[0]";
      mkdir($path, 0770);
      $path = "$path/";
    }
  }
}


# --- Backend-specific helper subs --- #


sub update_partition
{
  my $disk, my $device, my $point, my $fs, my $options, my $check,
  my $listed, my $bootable;
  my $disk_found = 0; my $point_found = 0;

  ($disk, $device, $point, $fs, $options, $check, $size, $listed,
   $bootable, $detected) = @_;

  if ($fs eq "auto") { $fs = ""; }

  for ($i = 0; @cf_disks[$i]; $i++)
  {
    if ((@cf_disks[$i])->{device} eq $disk)
    {
      # Found disk. Now look for partition.
          
      for ($j = 0; @cf_disks[$i]->{partitions}[$j]; $j++)
      {
        if (@cf_disks[$i]->{partitions}[$j]->{device} eq $device)
        {
          # Found partition.
          
          if ($options ne "")
          {
            if ($options =~ /noauto/)
            {
              @cf_disks[$i]->{partitions}[$j]->{mounted} = 0;
            }
            else
            {
              @cf_disks[$i]->{partitions}[$j]->{mounted} = 1;
            }
          }

          if ($point ne "") { @cf_disks[$i]->{partitions}[$j]->{point} = $point; }
          if ($fs) { @cf_disks[$i]->{partitions}[$j]->{type} = $fs; }
          if ($listed) { @cf_disks[$i]->{partitions}[$j]->{listed} = 1; }
          if ($bootable) { @cf_disks[$i]->{partitions}[$j]->{bootable} = 1; }
          if ($detected) { @cf_disks[$i]->{partitions}[$j]->{detected} = 1; }
          if ($check) { @cf_disks[$i]->{partitions}[$j]->{check} = 1; }
          if ($size) { @cf_disks[$i]->{partitions}[$j]->{size} = $size; }

          $point_found = 1; last;
        }
      }

      if (!$point_found)
      {
        # Make new partition entry.

        my %partition;

        if ($options =~ /noauto/) { %partition->{mounted} = 0; }
        else                      { %partition->{mounted} = 1; }

        %partition->{device} = $device;
        %partition->{point} = $point;
        %partition->{type} = $fs;
        %partition->{listed} = $listed;
        if ($bootable) { %partition->{bootable} = 1; }
        if ($detected) { %partition->{detected} = 1; }
        if ($check) { %partition->{check} = 1; }
        %partition->{size} = $size;

        $bleh = @cf_disks[$i]->{partitions};
        push(@$bleh, \%partition);
      }
            
      $disk_found = 1; last;
    }
  }

  if (!$disk_found)
  {
    # Make new disk entry containing this partition.

    my %disk, my %partition;

    if ($options =~ /noauto/) { %partition->{mounted} = 0; }
    else                      { %partition->{mounted} = 1; }

    %partition->{device} = $device;
    %partition->{point} = $point;
    %partition->{type} = $fs;
    %partition->{listed} = $listed;
    if ($bootable) { %partition->{bootable} = 1; }
    if ($detected) { %partition->{detected} = 1; }
    if ($check) { %partition->{check} = 1; }
    %partition->{size} = $size;

    %disk->{device} = $disk;
    %disk->{partitions} = [];

    $bleh = %disk->{partitions};
    push(@$bleh, \%partition);
    push(@cf_disks, \%disk);
  }
}


sub get_partition
{
  my $disk, my $device;
  my $i, my $j;

  ($disk, $device) = @_;

  for ($i = 0; @cf_disks[$i]; $i++)
  {
    if ((@cf_disks[$i])->{device} eq $disk)
    {
      # Found disk. Now look for partition.

      for ($j = 0; @cf_disks[$i]->{partitions}[$j]; $j++)
      {
        if (@cf_disks[$i]->{partitions}[$j]->{device} eq $device)
        {
          # Found partition.

          return (@cf_disks[$i]->{partitions}[$j]);
        }
      }
    }
  }
}


sub get_partition_data
{
  my $disk, my $device, my $point, my $fs, my $options, my $check,
  my $listed, my $bootable;

  ($disk, $device, $point, $fs, $options, $check, $size, $listed,
   $bootable, $detected) = @_;

  for ($i = 0; @cf_disks[$i]; $i++)
  {
    if ((@cf_disks[$i])->{device} eq $disk)
    {
      # Found disk. Now look for partition.

      for ($j = 0; @cf_disks[$i]->{partitions}[$j]; $j++)
      {
        if (@cf_disks[$i]->{partitions}[$j]->{device} eq $device)
        {
          # Found partition.

          return (@cf_disks[$i]->{partitions}[$j]->{point},
                  @cf_disks[$i]->{partitions}[$j]->{type},
                  @cf_disks[$i]->{partitions}[$j]->{listed},
                  @cf_disks[$i]->{partitions}[$j]->{mounted},
                  @cf_disks[$i]->{partitions}[$j]->{bootable},
                  @cf_disks[$i]->{partitions}[$j]->{check});
        }
      }
    }
  }
}


sub update_disk_size
{
  my $disk, my $size;
  
  ($disk, $size) = @_;

  for ($i = 0; @cf_disks[$i]; $i++)
  {
    if ((@cf_disks[$i])->{device} eq $disk)
    {
      # Found disk.
      
      @cf_disks[$i]->{size} = $size;
      last;
    }
  }
}


# --- Configuration file manipulation --- #


# /etc/fstab
#
# <device> <mount point> <filesystem> <option,option,...> <dump> <fsck>
# <device> <mount point> <filesystem> <option,option,...> <dump> <fsck>
# ...
#
# Exists: (Presumably everywhere)
#
# Absent: (Presumably nowhere)

sub read_fstab
{
  my $FILE;

  # Find the file.

  $FILE = open_read_from_names(@fstab_names);
  if (not FILE) { return; }  # We didn't find it.

  # Parse the file.

  while (<FILE>)
  {
    my $disk, $device, $point, $fs, $options, $check;

    @line = split(/[ \n\r\t]+/, $_);

    if (@line[0] eq "") { shift @line; }
    if (@line[0] eq "") { next; }
    if (is_line_comment_start(@line[0])) { next; }
    ($device, $point, $fs, $options, $dump, $check) = @line;

    if ($fs eq "nfs" || $fs eq "smbfs" || $fs eq "proc" || $fs eq "devpts" ||
        $fs eq "iso9660" || $fs eq "swap")
    {
      next;  # We can skip these filesystems for sure.
    }

    if ($point eq "none") { $dir = ""; }
    ($disk) = ($device =~ /([a-zA-Z\/]+)/);
    
    if ($disk eq "/dev/fd" || $disk eq $device)
    { 
      next;  # Skip floppies and CD-ROMs.
    }

    # (Find and update) or (add) our internal disk/partition record.

    if ($disk ne "")
    {
      update_partition($disk, $device, $point, $fs, $options, $check, "", 1, 0);
    }
  }

  close(FILE);
}


sub write_fstab
{
  my $INFILE, $OUTFILE;

  ($INFILE, $OUTFILE) = open_filter_write_from_names(@fstab_names);
  if (not OUTFILE) { return; }  # No point if we can't write.

  while (<INFILE>)
  {
    my $disk, my $device, my $point, my $fs, my $options, my $dump, my $check;
    my $ipoint, my $itype, my $icheck, my $ilisted, my $imounted, my $ibootable;

    @line = split(/[ \n\r\t]+/, $_);

    if (@line[0] eq "") { shift @line; }
    if (@line[0] eq "") { print OUTFILE; next; }
    if (is_line_comment_start(@line[0])) { print OUTFILE; next; }
    ($device, $point, $fs, $options, $dump, $check) = @line;

    if ($fs eq "nfs" || $fs eq "smbfs" || $fs eq "proc" || $fs eq "devpts" ||
        $fs eq "iso9660" || $fs eq "swap")
    {
      print OUTFILE; next;  # We can skip these filesystems for sure.
    }

    # By now, we know that the "entry" is "interesting". Check if known.

    ($disk) = ($device =~ /([a-zA-Z\/]+)/);

    ($ipoint, $itype, $ilisted, $imounted, $ibootable, $icheck) = get_partition_data($disk, $device);

    if ($ilisted)
    {
      # Write record if listedness requested.
      
      print OUTFILE $device . " ";
      if ($ipoint eq "") { print OUTFILE "none "; }
      else { print OUTFILE $ipoint . " "; }

      if ($itype eq "") { print OUTFILE "auto "; }
      else              { print OUTFILE $itype . " "; }

      # Options merging and printing.

      my $prev = 0;
      if (!$imounted) { print OUTFILE "noauto"; $prev = 1; }
      my @options = ($options =~ /([a-zA-Z0-9=]+),?/mg);
      for $option (@options)
      {
        # Strip options we handle, keep the rest.

        if ($option eq "auto" || $option eq "noauto" ||
            $option eq "defaults") { next; }
        if ($prev) { print OUTFILE ","; }
        print OUTFILE $option;
        $prev = 1;
      }
      
      if (!$prev) { print OUTFILE "defaults"; }
      
      # Leave dump alone.
      
      print OUTFILE " $dump ";
      
      # Fsck onboot priority.

      if ($icheck eq "") { $icheck = 0; }
      if ($icheck == 1)
      {
        if ($ipoint eq "/") { print OUTFILE "1\n"; }
        else { print OUTFILE "2\n"; }
      }
      else { print OUTFILE "0\n"; }
      
      # Indicate that parameters for this partition have been stored.
      
      my $partition = get_partition($disk, $device);
      %$partition->{stored} = 1;
    }
    
    # Unknown or unlisted-by-request partitions are not written.
  }
  
  # Print the remaining partitions from our internal list. These are
  # newly added, and didn't exist in the fstab previously.
  
  for ($i = 0; @cf_disks[$i]; $i++)
  {
    for ($j = 0; @cf_disks[$i]->{partitions}[$j]; $j++)
    {
      if (@cf_disks[$i]->{partitions}[$j]->{listed} &&
          !@cf_disks[$i]->{partitions}[$j]->{stored})
      {
        my $part = @cf_disks[$i]->{partitions}[$j];

        if ($verbose)
        {
          print STDERR "Adding " . @cf_disks[$i]->{partitions}[$j]->{device} . " to fstab.\n";
        }
        
        # Write record.

        print OUTFILE %$part->{device} . " ";
        if (%$part->{point} eq "") { print OUTFILE "none "; }
        else { print OUTFILE %$part->{point} . " "; }

        if (%$part->{type} eq "") { print OUTFILE "auto "; }
        else                     { print OUTFILE %$part->{type} . " "; }

        # Options printing.

        if (!%$part->{mounted}) { print OUTFILE "noauto "; }
        else { print OUTFILE "defaults "; }

        # No dumping by default.

        print OUTFILE " 0 ";
      
        # Fsck onboot priority.

        if (%$part->{check} == 1)
        {
          if (%$part->{point} eq "/") { print OUTFILE "1\n"; }
          else { print OUTFILE "2\n"; }
        }
        else { print OUTFILE "0\n"; }
      }
    }
  }
  
  close OUTFILE;
}


# fdisk -l <disk device>
#
# <filtered lines>
#
# <partition device> [*] <start cluster> <end cluster> <blocks> <id> <verbose id>
# <partition device> [*] <start cluster> <end cluster> <blocks> <id> <verbose id>
# ...
#
# Exists: Red Hat 6.2 (Presumably all Linux)
#
# Absent:
#
# The star is optional, and means that the partition is bootable. We could've
# used /proc/partitions to get this information, but it lists CD-ROM devices
# and whatnot as well, without a disambiguating identifier. Then there is
# portability, forward-compatibility, people without /proc, etc.

# fdisk -s <disk device>
#
# <blocksize>

sub get_fdisk
{
  my $fdisk_tool;

  # Okay, so this is strictly not portable either. Patches welcome.

  my @check_devs = ( "/dev/hda", "/dev/hdb", "/dev/hdc", "/dev/hdd",

                     "/dev/sda", "/dev/sdb", "/dev/sdc", "/dev/sdd",
                     "/dev/sde", "/dev/sdf",
                     
                     "/dev/eda", "/dev/edb", "/dev/edc", "/dev/edd",
                     
                     "/dev/xda", "/dev/xdb" );

  $fdisk_tool = locate_tool("fdisk");

  for $dev (@check_devs)
  {
    my $disk, $device, $point, $fs, $options, $check, $size, $bootable;
    
    if ($verbose) { print STDERR "Looking for partitions on $dev.\n"; }

    open(FDISK_HD, "$fdisk_tool -l $dev 2>/dev/null |");
    while (<FDISK_HD>)
    {
      if (/^\/dev/)
      {
        @line = split(/[ \n\r\t]+/, $_);

        $device = @line[0]; shift @line;
        ($disk) = ($device =~ /([a-zA-Z\/]+)/);
        if (@line[0] eq "\*")
        {
          # NOTE: Currently unused.
          $bootable = 1; shift @line;
        }
        else { $bootable = 0; }

        shift @line; shift @line;  # Start and end clusters.

        ($size) = (@line[0] =~ /([0-9]+)/);
        shift @line;

        if (@line[0] eq "82") { next; }  # Swap.
        elsif (@line[0] eq "83") { $type = "ext2"; }
        elsif (@line[0] eq "e") { $type = "vfat"; }
        elsif (@line[0] eq "c") { $type = "fat32"; }
        elsif (@line[0] eq "b") { $type = "fat32"; }
        elsif (@line[0] eq "6") { $type = "msdos"; }
        elsif (@line[0] eq "4") { $type = "msdos"; }
        elsif (@line[0] eq "1") { $type = "msdos"; }
        elsif (@line[0] eq "7") { $type = "hpfs"; }
        else { $type = ""; }

        update_partition($disk, $device, "", $type, "noauto", 0, $size, 0,
                         $bootable, 1);
      }
    }
    close(FDISK_HD);

    if ($verbose) { print STDERR "Querying size of $dev.\n"; }

    open(FDISK_HD, "$fdisk_tool -s $dev 2>/dev/null |");
    ($size) = (<FDISK_HD> =~ /([0-9]+)/);
    if ($size ne "") { update_disk_size($dev, $size); }
    close(FDISK_HD);
    
    print_progress();
  }
}


# --- XML parsing --- #


# Scan XML from standard input to an internal tree.

sub xml_parse
{
  # Scan XML to tree.

  $tree = xml_scan;

  # Walk the tree recursively and extract configuration parameters.
  # This is the top level - find and enter the toplevel tag.

  while (@$tree)
  {
    if (@$tree[0] eq "disks") { xml_parse_toplevel(@$tree[1]); }

    shift @$tree;
    shift @$tree;
  }

  return($tree);
}


sub xml_parse_toplevel
{
  my $tree = @_[0];

  shift @$tree;  # Skip attributes.

  while (@$tree)
  {
    if (@$tree[0] eq "disk") { xml_parse_disk(@$tree[1]); }

    shift @$tree;
    shift @$tree;
  }
}


sub xml_parse_disk
{
  my %disk;

  my $tree = @_[0];
  shift @$tree;  # Skip attributes.

  %disk->{partitions} = [];  # Init partition list.

  while (@$tree)
  {
    if (@$tree[0] eq "device") { %disk->{device} = xml_get_word(@$tree[1]); }
    elsif (@$tree[0] eq "size") { %disk->{size} = xml_get_word(@$tree[1]); }
    elsif (@$tree[0] eq "partition")
    {
      my %partition = xml_parse_partition(@$tree[1]);
      $bleh = %disk->{partitions};
      push(@$bleh, \%partition);
    }
    
    shift @$tree; shift @$tree;
  }

  push(@cf_disks, \%disk);
}


sub xml_parse_partition
{
  my %partition;

  my $tree = @_[0];
  shift @$tree;  # Skip attributes.

  while (@$tree)
  {
    if (@$tree[0] eq "device") { %partition->{device} = xml_get_word(@$tree[1]); }
    elsif (@$tree[0] eq "type") { %partition->{type} = xml_get_word(@$tree[1]); }
    elsif (@$tree[0] eq "point") { %partition->{point} = xml_get_word(@$tree[1]); }
    elsif (@$tree[0] eq "size") { %partition->{size} = xml_get_word(@$tree[1]); }
    elsif (@$tree[0] eq "bootable") { %partition->{bootable} = xml_parse_state(@$tree[1]); }
    elsif (@$tree[0] eq "integritycheck") { %partition->{check} = xml_parse_state(@$tree[1]); }
    elsif (@$tree[0] eq "mounted") { %partition->{mounted} = xml_parse_state(@$tree[1]); }
    elsif (@$tree[0] eq "listed") { %partition->{listed} = xml_parse_state(@$tree[1]); }
    elsif (@$tree[0] eq "detected") { %partition->{detected} = xml_parse_state(@$tree[1]); }
    
    shift @$tree; shift @$tree;
  }

  return(%partition);
}


sub xml_parse_state
{
  my $tree = @_[0];

  # Check attribute; 'yes', 'true', 'no', 'false'.

  return(read_boolean(@$tree[0]->{state}));
}


# Compresses node into a word and returns it.

sub xml_get_word
{
  my $tree = @_[0];

  shift @$tree;  # Skip attributes.

  while (@$tree)
  {
    if (@$tree[0] == 0)
    {
      my $retval;

      ($retval = @$tree[1]) =~ tr/ \n\r\t\f//d;
      $retval = xml_entities_to_plain(\$retval);
      return($retval);
    }

    shift @$tree;
    shift @$tree;
  }

  return("");
}


# Replaces misc. whitespace with spaces and returns text.

sub xml_get_text
{
  my $tree = @_[0];

  shift @$tree;  # Skip attributes.

  while (@$tree)
  {
    if (@$tree[0] = 0)
    {
      ($retval = @$tree[1]) =~ tr/\n\r\t\f/    /;
      $retval = xml_entities_to_plain(\$retval);
      return($retval);
    }

    shift @$tree;
    shift @$tree;
  }
}


# --- XML printing --- #


sub xml_print
{
  print "<?xml version='1.0' encoding='ISO-8859-1' standalone='yes'?>\n";
  print "<!DOCTYPE disks []>\n\n";
  print "<disks>\n";
  enter;

  vspace;
  indent; print "<!-- Configuration starts here -->\n";
  vspace;
  indent; print "<!-- Local fixed media and partitions -->\n";
  vspace;

  my @disks = @cf_disks;

  while (@disks)
  {
    if (@disks[0])
    {
      my $disk = @disks[0];
      
      vspace;
      indent; print "<disk>\n";
      enter;

      indent; print "<device>" . %$disk->{device} . "</device>\n";
      if (%$disk->{size}) { indent; print "<size>" . %$disk->{size} . "</size>\n"; }
      
      my $partitions = %$disk->{partitions};
      
      while (@$partitions)
      {
        my $partition = @$partitions[0];

        vspace;
        indent; print "<partition>\n";
        enter;

        indent; print "<device>" . %$partition->{device} . "</device>\n";
        if (%$partition->{type}) { indent; print "<type>" . %$partition->{type} . "</type>\n"; }
        if (%$partition->{point}) { indent; print "<point>" . %$partition->{point} . "</point>\n"; }
        if (%$partition->{size})
        {
          indent; print "<size>" . %$partition->{size} . "</size>\n";
        }
        
        indent; print "<bootable state='" . print_boolean_truefalse(%$partition->{bootable}) . "'/>";
                print "<integritycheck state='" . print_boolean_truefalse(%$partition->{check}) . "'/>\n";

        indent;
        print "<mounted state='" . print_boolean_truefalse(%$partition->{mounted}) . "'/>";
        print "<listed state='" . print_boolean_truefalse(%$partition->{listed}) . "'/>";
        print "<detected state='" . print_boolean_truefalse(%$partition->{detected}) . "'/>\n";

        leave;
        indent; print "</partition>\n";
        
        shift @$partitions;
      }

      leave;
      indent; print "</disk>\n";
      vspace;
    }
  
    shift @disks;
  }

  vspace;
  indent; print "<!-- End of configuration -->\n";
  vspace;

  leave;
  print "</disks>\n";
}


# --- Get (read) config --- #


sub get
{
  if ($progress) { $| = 1; print $progress_max . "\n"; }

  if ($verbose) { print STDERR "Getting system configuration, generating XML output.\n"; }

  get_fdisk;
  read_fstab;

  if ($verbose) { print STDERR "Printing XML.\n"; }
  if ($progress) { print "\n"; }
  xml_print;
}


# --- Set (write) config --- #


sub set_immediate
{
  my $mount_tool;
  my $umount_tool;

  $mount_tool = locate_tool("mount");
  $umount_tool = locate_tool("umount");

  # Update mount status.

  if (($mount_tool ne "") && ($umount_tool ne ""))
  {
    my $i, my $j;

    for ($i = 0; @cf_disks[$i]; $i++)
    {
      for ($j = 0; @cf_disks[$i]->{partitions}[$j]; $j++)
      {
        if (@cf_disks[$i]->{partitions}[$j]->{mounted})
        {
          if ($verbose)
          {
            print STDERR "Mounting " . @cf_disks[$i]->{partitions}[$j]->{device} . ".\n";
          }
          system "$mount_tool " . @cf_disks[$i]->{partitions}[$j]->{device} . " " .
                 @cf_disks[$i]->{partitions}[$j]->{point} . " >/dev/null 2>/dev/null";
        }
        else
        {
          if ($verbose)
          {
            print STDERR "Unmounting " . @cf_disks[$i]->{partitions}[$j]->{device} . ".\n";
          }
          system "$umount_tool " . @cf_disks[$i]->{partitions}[$j]->{device} . " >/dev/null 2>/dev/null";
        }
      }
    }
  }
  else
  {
    if ($verbose) { print STDERR "Warning: Could not find mount tools. No mounting done.\n"; }
  }
}


sub set
{
  if ($verbose) { print STDERR "Setting system configuration from XML input.\n"; }

  if ($verbose) { print STDERR "Parsing XML.\n"; }
  xml_parse;

  write_fstab;

  if ($do_immediate)
  {
    if ($verbose) { print STDERR "Changing running configuration via local utilities.\n"; }
    set_immediate;
  }
}


# --- Filter config: XML in, XML out --- #


sub filter
{
  xml_parse;
  xml_print;
}


# --- Main --- #

$operation = "";  # Major operation user wants to perform. [get | set | filter]


sub set_operation
{
  if ($operation ne "")
  {
    print STDERR "Error: You may specify only one major operation.\n\n";
    print STDERR $Usage;
    exit(1);
  }

  $operation = @_[0];
}


# Process options.

while (@ARGV)
{
  if    (@ARGV[0] eq "--get"    || @ARGV[0] eq "-g") { set_operation("get"); }
  elsif (@ARGV[0] eq "--set"    || @ARGV[0] eq "-s") { set_operation("set"); }
  elsif (@ARGV[0] eq "--filter" || @ARGV[0] eq "-f") { set_operation("filter"); }
  elsif (@ARGV[0] eq "--help"   || @ARGV[0] eq "-h") { print $Usage; exit(0); }
  elsif (@ARGV[0] eq "--version")                    { print "$version\n"; exit(0); }
  elsif (@ARGV[0] eq "--prefix" || @ARGV[0] eq "-p")
  {
    if ($prefix ne "")
    {
      print STDERR "Error: You may specify --prefix only once.\n\n";
      print STDERR $Usage; exit(1);
    }

    $prefix = @ARGV[1];

    if ($prefix eq "")
    {
      print STDERR "Error: You must specify an argument to the --prefix option.\n\n";
      print STDERR $Usage; exit(1);
    }

    shift @ARGV;  # For the argument.
  }
  elsif (@ARGV[0] eq "--disable-immediate")           { $do_immediate = 0; }
  elsif (@ARGV[0] eq "--verbose" || @ARGV[0] eq "-v") { $verbose = 1; }
  elsif (@ARGV[0] eq "--progress")                    { $progress = 1; }
  else
  {
    print STDERR "Error: Unrecognized option '@ARGV[0]'.\n\n";
    print STDERR $Usage; exit(1);
  }

  shift @ARGV;
}


# Do our thing.

if    ($operation eq "get")    { get; }
elsif ($operation eq "set")    { set; }
elsif ($operation eq "filter") { filter; }
else
{
  print STDERR "Error: No operation specified.\n\n";
  print STDERR $Usage; exit(1);
}

