#!/usr/bin/env perl
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-

# Time configurator. Designed to be architecture- and distribution independent.
#
# Copyright (C) 2000-2001 Ximian, Inc.
#
# Authors: Chema Celorio <chema@ximian.com>
#          Arturo Espinosa <arturo@ximian.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

# Best viewed with 100 columns of width.


BEGIN {
require "___scriptsdir___/ishare.pl";
require "___scriptsdir___/general.pl";
require "___scriptsdir___/platform.pl";
require "___scriptsdir___/util.pl";
require "___scriptsdir___/file.pl";
require "___scriptsdir___/xml.pl";
}


# --- Tool information --- #

$name = "internetsharing";
$version = "___version___";
@platforms = ("redhat-7.1", "redhat-7.0", "mandrake-7.2");

$description =<<"end_of_description;";
       Sets up firewall rules for a basic internet sharing (masq)
       network.
end_of_description;


# --- XML parsing --- #

# Scan XML from standard input to an internal tree.

sub xml_parse
{
  my ($tree, %hash, $elem);
  
  # Scan XML to tree.

  $tree = &xst_xml_scan ();

  # Walk the tree recursively and extract configuration parameters.
  # This is the top level - find and enter the "networking" tag.

  while ($elem = shift @$tree)
  {
    if   ($elem eq "internetsharing") { &xml_parse_internetsharing (shift @$tree, \%hash); }
    else { &xst_report ("xml_unexp_tag", $elem); shift @$tree; }
  }

  return (\%hash);
}


sub xml_parse_internetsharing
{
  my ($tree, $hash) = @_;
  my ($elem, %interface);
  
  shift @$tree;  # Skip attributes.
  
  while ($elem = shift @$tree)
  {
      if    ($elem eq "fwrules")   { $$hash{"fwrules"} = &xml_parse_fwrules (shift @$tree);        }
      elsif ($elem eq "dhcp")      { $$hash{"dhcp"}    = &xml_parse_dhcp    (shift @$tree);        }
      elsif ($elem eq "interface") { &xst_network_xml_parse_interface (shift @$tree, \%interface); }
      else  { &xst_report ("xml_unexp_tag", $elem); shift @$tree; }
  }
  
  $$hash{"interface"} = \%interface unless scalar keys %interface == 0;
}


sub xml_parse_fwrules
{
  my ($tree) = @_;
  my ($elem, $hash, $landevs);

  $hash = {};
  $landevs = [];
  shift @$tree;  # Skip attributes.

  while ($elem = shift @$tree)
  {
      if    ($elem eq "tools")        { $$hash{"tools"}        = &xst_xml_get_pcdata (shift @$tree); }
      elsif ($elem eq "configured")   { $$hash{"configured"}   = &xst_xml_get_pcdata (shift @$tree); }
      elsif ($elem eq "forwarding")   { $$hash{"forwarding"}   = &xst_xml_get_pcdata (shift @$tree); }
      elsif ($elem eq "masquerading") { $$hash{"masquerading"} = &xst_xml_get_pcdata (shift @$tree); }
      elsif ($elem eq "active")       { $$hash{"active"}       = &xst_xml_get_pcdata (shift @$tree); }
      elsif ($elem eq "landev")       { push @$landevs, &xst_xml_get_pcdata (shift @$tree); }
      else  { &xst_report ("xml_unexp_tag", $elem); shift @$tree; }
  }

  $hash{"landev"} = $landevs;

  return $hash;
}


sub xml_parse_dhcp
{
  my ($tree) = @_;
  my ($elem, $hash);

  $hash = {};
  shift @$tree;  # Skip attributes.

  while ($elem = shift @$tree)
  {
      if    ($elem eq "installed")    { $$hash{"installed"}  = &xst_xml_get_pcdata (shift @$tree); }
      elsif ($elem eq "configured")   { $$hash{"configured"} = &xst_xml_get_pcdata (shift @$tree); }
      elsif ($elem eq "active")       { $$hash{"active"}     = &xst_xml_get_pcdata (shift @$tree); }
      else  { &xst_report ("xml_unexp_tag", $elem); shift @$tree; }
  }

  return $hash;
}


# --- XML printing --- #


sub xml_print
{
  my ($h) = @_;

  &xst_xml_print_begin ();
  &xst_xml_print_hash      ($$h{"fwrules"}, "fwrules");
  &xst_xml_print_hash      ($$h{"dhcp"},    "dhcp");
  &xst_xml_print_hash_hash ($$h{"interface"}, "interface");
  &xst_xml_print_end ();
}

# Main operations

sub get
{
  my $hash;
  
  $hash = &xst_ishare_conf_get ();

  &xst_end();
  &xml_print ($hash);
}


sub set
{
  my $hash;

  $hash = &xml_parse ();
  &xst_ishare_conf_set ($hash);
  &xst_end();
}


# --- Filter config: XML in, XML out --- #


sub filter
{
  my $hash;

  $hash = &xml_parse ();
  &xst_end();
  &xml_print ($hash);
}

# --- Main --- #

# get, set and filter are special cases that don't need more parameters than a ref to their function.
# Read general.pl.in:xst_run_directive to know about the format of this hash.

$directives = {
  "get"    => [ \&get,    [], "" ],
  "set"    => [ \&set,    [], "" ],
  "filter" => [ \&filter, [], "" ]
    };

$tool = &xst_init ($name, $version, $description, $directives, @ARGV);
&xst_platform_ensure_supported ($tool, @platforms);
&xst_run ($tool);

