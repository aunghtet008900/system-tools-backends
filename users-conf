#!/usr/bin/perl 

# User configurator. Designed to be architecture- and distribution independent.
#
# Version 0.1 - copyright (C) 2000 Suitware, Inc.
#               copyright (C) 2000 Helix Code, Inc.
#
#
# Authors: Hans Petter Jansson <hpj@helixcode.com>
#          Walt Pohl <cher@suitware.com>
#          Megan Payne <chastity@suitware.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

# Issues:
#
# We need to read and write the password databases atomically, but currently
# we don't.
#
# Should we enforce chfn format for info?
#
# We don't let the user set the shadow fields.  Is that a problem?

# Configuration files affected:
#
# /etc/passwd
# /etc/group
# /etc/shadow ?
# /etc/shells (not yet)

# --- Usage text --- #

my $Usage =<<'End_of_Usage;';
Usage: user-conf <--get | --set | --filter | --help>
                 [--prefix <location>] [--disable-immediate]
                 [--verbose]

       Major operations (specify one of these):

       -g --get      Prints the current user and group information to
                     standard output, as as standalone XML document. The
                     configuration is read from the host's system config
                     files.

       -s --set      Updates the system user and group information from
                     a standalone XML document read from standard input.
                     The format is the same as for the document generated
                     with --get.

       -f --filter   Reads XML configuration from standard input, parses it,
                     and writes the configurator's impression of it back to
                     standard output. Good for debugging and parsing tests.

       -h --help     Prints this page to standard output. That's all.

       Modifiers (specify any combination of these):

       -p --prefix <location>  Specifies a directory prefix where the
                     configuration is looked for or stored. When storing
                     (with --set), directories and files may be created.

          --disable-immediate  With --set, prevents the configurator from
                     running any commands that make immediate changes to
                     the system configuration. Use with --prefix to make a
                     dry run that won't affect your configuration.

                     With --get, suppresses running of non-vital external
                     programs that might take a long time to finish.

       -v --verbose  Turns on diagnostic messages to standard error.

End_of_Usage;


# --- System config file locations --- #

# We list each config file type with as many alternate locations as possible.
# They are tried in array order. First found = used.

@etc_passwd_names = ( "/etc/passwd" );
@etc_group_names = ( "/etc/group" );

# --- Internal configuration variables --- #

# Configuration is parsed/read to, and printed/written from, these temporary variables.

@users  = ();
@groups = ();

# --- Operation modifying variables --- #

# Variables are set to their default value, which may be overridden by user. Note
# that a $prefix of "" will cause the configurator to use '/' as the base path,
# and disables creation of directories and writing of previously non-existent
# files.


$prefix = "";
$verbose = 0;
$do_immediate = 1;


# --- XML print formatting  --- #

# enter: Call after entering a block. Increases indent level.
# leave: Call before leaving a block. Decreases indent level.
# indent: Call before printing a line. Indents to current level. 
# vspace: Ensures there is a vertical space of one and only one line.

$indent_level = 0;
$have_vspace = 0;

sub enter  { $indent_level += 2; }
sub leave  { $indent_level -= 2; }
sub indent { for ($i = 0; $i < $indent_level; $i++) { print " "; } $have_vspace = 0; }
sub vspace { if (not $have_vspace) { print "\n"; $have_vspace = 1; } }


# --- String and array manipulation --- #

# Pushes a value to an array, only if it's not already in there.
# I'm sure there's a smarter way to do this. Should only be used for small lists,
# as it's O(N^2). Larger lists with unique members should use a hash.

sub push_unique
{
  my $arr = @_[0];
  my $found;
  my $i;

  # Go through all elements in pushed list.

  for ($i = 1; @_[$i]; $i++)
  {
    # Compare against all elements in destination array.

    $found = "";
    for $elem (@$arr)
    {
      if ($elem eq @_[$i]) { $found = $elem; last; }
    }

    if ($found eq "") { push(@$arr, @_[$i]); }
  }
}


# --- File operations --- #

# FIXME:  We should make atomic versions of these.


sub open_read_from_names
{
  my $FILE;
  my $fname = "";

  for $name (@_)
  {
    if (open(FILE, "$prefix/$name")) { $fname = $name; last; }
  }

  if ($verbose)
  {
    (my $fullname = "$prefix/$fname") =~ tr/\//\//s;  # '//' -> '/'
    if ($fname ne "") { print STDERR "Reading options from \"$fullname\".\n"; }
    else { print STDERR "Could not read \[@_\].\n"; }
  }

  return($FILE);
}


sub open_write_from_names
{
  my $FILE;
  my $name;
  my $fullname;

  # Find out where it lives.

  for $elem (@_) { if (stat($elem) ne "") { $name = $elem; last; } }

  if ($name eq "")
  {
    # If we couldn't locate the file, and have no prefix, give up.

    # If we have a prefix, but couldn't locate the file relative to '/',
    # take the first name in the array and let that be created in $prefix.

    if ($prefix eq "")
    {
      if ($verbose) { print STDERR "No file to replace: \[@_\].\n"; }
      return(0);
    }
    else
    {
      $name = @_[0];
      if ($verbose)
      {
        (my $fullname = "$prefix/$name") =~ tr/\//\//s;
        print STDERR "Could not find \[@_\]. Writing to \"$fullname\".\n";
      }
    }
  }
  elsif ($verbose)
  {
    (my $fullname = "$prefix/$name") =~ tr/\//\//s;
    print STDERR "Found \"$name\". Writing to \"$fullname\".\n";
  }

  ($name = "$prefix/$name") =~ tr/\//\//s;  # '//' -> '/'
  create_path($name);

  # Make a backup if the file already exists - if the user specified a prefix,
  # it might not.

  if (stat($name))
  {
    # NOTE: Might not work everywhere. Might be unsafe if the user is allowed
    # to specify a $name list somehow, in the future.

    system("cp $name $name.confsave >/dev/null 2>/dev/null");
  }

  # Truncate and return filehandle.

  if (!open(FILE, ">$name") && $verbose)
  {
    print STDERR "Error: Failed to write to \"$name\". Are you root?\n";
  }

  return($FILE);
}


sub open_filter_write_from_names
{
  my $INFILE;
  my $OUTFILE;
  my $name;

  # Find out where it lives.

  for $elem (@_) { if (stat($elem) ne "") { $name = $elem; last; } }

  if ($name eq "")
  {
    # If we couldn't locate the file, and have no prefix, give up.

    # If we have a prefix, but couldn't locate the file relative to '/',
    # take the first name in the array and let that be created in $prefix.

    if ($prefix eq "")
    {
      if ($verbose) { print STDERR "No file to patch: \[@_\].\n"; }
      return(0, 0);
    }
    else
    {
      $name = @_[0];
      if ($verbose)
      {
        (my $fullname = "$prefix/$name") =~ tr/\//\//s;
        print STDERR "Could not find \[@_\]. Patching \"$fullname\".\n";
      }
    }
  }
  elsif ($verbose)
  {
    (my $fullname = "$prefix/$name") =~ tr/\//\//s;
    print STDERR "Found \"$name\". Patching \"$fullname\".\n";
  }

  ($name = "$prefix/$name") =~ tr/\//\//s;  # '//' -> '/'
  create_path($name);

  # Make a backup if the file already exists - if the user specified a prefix,
  # it might not.

  if (stat($name))
  {
    # NOTE: Might not work everywhere. Might be unsafe if the user is allowed
    # to specify a $name list somehow, in the future.

    system("cp $name $name.confsave >/dev/null 2>/dev/null");
  }

  # Return filehandles. Backup file is used as filter input. It might be
  # invalid, in which case the caller should just write to OUTFILE without
  # bothering with INFILE filtering.

  open(INFILE, "$name.confsave");

  if (!open(OUTFILE, ">$name") && $verbose)
  {
    print STDERR "Error: Failed to write to \"$name\". Are you root?\n";
  }

  return($INFILE, $OUTFILE);
}


sub create_path
{
  my $path;

  ($path = @_[0]) =~ s/^\///;      # '/etc/jall' -> 'etc/jall'
  my @pelem = split(/\//, $path);  # 'a/b/c/d/' -> 'a', 'b', 'c', 'd', ''

  for ($path = ""; @pelem; shift @pelem)
  {
    if (@pelem[0] ne "" && @pelem[1] ne "")
    {
      $path = "$path/@pelem[0]";
      mkdir($path, 0770);
    }
  }
}


# --- Configuration file manipulation --- #

# /etc/passwd
#
# At the moment, we treat the password field as a black box, so we can ignore
# the question of shadow passwords, PAM, MD5 passwords, etc.
#
# Exists: (presumably all)
#
# Absent: (presumably none)

sub read_etc_passwd {
  my $FILE;
  my @line;    

  # Find the file.

  $FILE = open_read_from_names(@etc_passwd_names);
  if (not FILE) { return; }  # We didn't find it.

  # Parse the file.

  while (<FILE>)
  {
    chomp;      
    @line = split ':';
    push @users, [ @line ];
  }
}

sub write_etc_passwd {
  my $FILE;

  $FILE = open_write_from_names(@etc_passwd_names);
  if (not FILE) { return; }
  foreach $user (@users) { print FILE "$user\n";}
}

sub write_etc_groups {
  my $FILE;

  $FILE = open_write_from_names(@etc_group_names);
  if (not FILE) { return; }
  foreach $group (@groups) { print FILE "$group\n";}
}

# /etc/group
#
#
# Exists: (presumably all)
#
# Absent: (presumably none)

sub read_etc_group {
  my $FILE;
  my @line;    

  # Find the file.

  $FILE = open_read_from_names(@etc_group_names);
  if (not FILE) { return; }  # We didn't find it.

  # Parse the file.

  while (<FILE>)
  {
    chomp;
    @line = split ':';
    push @groups, [ @line ];
  }
}


# --- XML parsing --- #


@xml_scan_list;


sub xml_scan_make_kid_array
{
  my %hash = {};
  my @sublist;

  @attr = @_[0] =~ /[^\t\n\r ]+[\t\n\r ]*([a-zA-Z]+)[ \t\n\r]*\=[ \t\n\r\"\']*([a-zA-Z]+)/g;
  %hash = @attr;

  push(@sublist, \%hash);
  return(\@sublist);
}


sub xml_scan_recurse;

sub xml_scan_recurse
{
  my @list;
  if (@_) { @list = @_[0]->[0]; }

  while (@xml_scan_list)
  {
    $el = @xml_scan_list[0]; shift @xml_scan_list;

    if (($el eq "") || $el =~ /^\<[!?].*\>$/s) { next; }  # Empty strings, PI and DTD must go.

    if ($el =~ /^\<.*\/\>$/s)     # Empty.
    {
      $el =~ /^\<([a-zA-Z]+).*\/\>$/s;
      push(@list, $1);
      push(@list, xml_scan_make_kid_array($el));
    }
    elsif ($el =~ /^\<\/.*\>$/s)  # End.
    {
      last;
    }
    elsif ($el =~ /^\<.*\>$/s)    # Start.
    {
      $el =~ /^\<([a-zA-Z]+).*\>$/s;
      push(@list, $1);
      $sublist = xml_scan_make_kid_array($el);
      push(@list, xml_scan_recurse($sublist));
      next;
    }
    elsif ($el ne "")             # PCDATA.
    {
      push(@list, 0);
      push(@list, "$el");
    }
  }

  return(\@list);
}


sub xml_scan
{
  my $doc; my @tree;
  read STDIN, $doc, 512000;  # Read in document (FIXME: ugly).
  @xml_scan_list = ($doc =~ /([^\<]*)(\<[^\>]*\>)[ \t\n\r]*/mg);  # pcdata, tag, pcdata, tag, ...

  $tree = xml_scan_recurse;

  return($tree);

#  $" = "\n";
#  print "@list\n";
}


@xml_entities = ( "&lt;", '<', "&gt;", '>', "&apos;", '\'', "&quot;", '"' );

sub xml_entities_to_plain
{
  my $in = @_[0];
  my $out = "";
  my @xe;

  $in = $$in;

  my @elist = ($in =~ /([^&]*)(\&[a-zA-Z]+\;)?/mg);  # text, entity, text, entity, ...

  while (@elist)
  {
    # Join text.

    $out = join('', $out, @elist[0]);
    shift @elist;
    
    # Find entity and join its text equivalent.
    # Unknown entities are simply removed.

    for (@xe = @xml_entities; @xe; )
    {
      if (@xe[0] eq @elist[0]) { $out = join('', $out, @xe[1]); last; }
      shift @xe; shift @xe;
    }

    shift @elist;
  }

  return($out);
}


sub xml_plain_to_entities
{
  my $in = @_[0];
  my $out = "";
  my @xe;
  my $joined = 0;

  $in = $$in;

  my @clist = split(//, $in);

  while (@clist)
  {
    # Find character and join its entity equivalent.
    # If none found, simply join the character.

    $joined = 0;  # Cumbersome.

    for (@xe = @xml_entities; @xe && !$joined; )
    {
      if (@xe[1] eq @clist[0]) { $out = join('', $out, @xe[0]); $joined = 1; }
      shift @xe; shift @xe;
    }

    if (!$joined) { $out = join('', $out, @clist[0]); }
    shift @clist;
  }

  return($out);
}


# Scan XML from standard input to an internal tree.

sub xml_parse
{
  $tree = xml_scan;

  while (@$tree) 
  {
    if (@$tree[0] eq "userconf") { xml_parse_userconf(@$tree[1]); }
    shift @$tree;
    shift @$tree;
  }
  return ($tree);
}

sub xml_parse_userconf
{
  my $tree = @_[0];

  shift @$tree;  # skip attributes
  while (@$tree)
  {
    if (@$tree[0] eq "user") { xml_parse_user(@$tree[1]) }
    if (@$tree[0] eq "group") { xml_parse_group(@$tree[1]) }
    shift @$tree;
    shift @$tree;
  }
}

sub xml_parse_users
{
  my $tree = @_[0];

  shift @$tree;  # skip attributes
  $FILE = open_write_from_names(@etc_passwd_names) ;
  while (@$tree)
  {
    if (@$tree[0] eq "user") { xml_parse_user(@$tree[1]) }
    shift @$tree;
    shift @$tree;
  }
  close(FILE);
}

sub xml_parse_user
{
  my $tree = @_[0];
  my ($name, $password, $uid, $gid, $info, $homedir, $shell);

  shift @$tree;  # skip attributes
  while (@$tree)
  {
    if (@$tree[0] eq "name") { $name = xml_get_word(@$tree[1]); }
    if (@$tree[0] eq "password") { $password = xml_get_word(@$tree[1]); }
    if (@$tree[0] eq "uid") { $uid = xml_get_text(@$tree[1]); }
    if (@$tree[0] eq "gid") { $gid = xml_get_word(@$tree[1]); }
    if (@$tree[0] eq "info") { $info = xml_get_text(@$tree[1]); }
    if (@$tree[0] eq "homedir") { $homedir = xml_get_word(@$tree[1]); }
    if (@$tree[0] eq "shell") { $shell = xml_get_word(@$tree[1]); }
    shift @$tree;
    shift @$tree;
  }
  $user = "$name:$password:$uid:$gid:$info:$homedir:$shell";
  push @users, $user;
}

sub xml_parse_groups
{
  my $tree = @_[0];

  shift @$tree;  # skip attributes
  while (@$tree)
  {
    if (@$tree[0] eq "group") { xml_parse_group(@$tree[1]) }
    shift @$tree;
    shift @$tree;
  }
}

sub xml_parse_group
{
  my $tree = @_[0];
  my ($name, $gid, $members, $gpasswd);
  my $FILE;

  $FILE = open_write_from_names(@etc_group_names);   
  if (not FILE) { return; }  # Again didn't find the file.

  shift @$tree;  # skip attributes

  while (@$tree)
  {
    if (@$tree[0] eq "name") { $name = xml_get_word(@$tree[1]); }
    if (@$tree[0] eq "password") { $gpasswd = xml_get_word(@$tree[1]); }
    if (@$tree[0] eq "gid") { $gid = xml_get_word(@$tree[1]); }
    if (@$tree[0] eq "member") { 
	if ($members eq "") { $members = xml_get_word(@$tree[1]); }
	else { $members = $members . "," . xml_get_word(@$tree[1]); }
    }
    shift @$tree;
    shift @$tree;
  }
  $group = "$name:$gpasswd:$gid:$members";
  push @groups, $group;

}

sub xml_parse_members
{
  my $tree = @_[0];
  my ($member, $members);
  $flag = 1;  

  shift @$tree;  # skip attributes
  while (@$tree) {
    if ($flag) {	
	if (@$tree[0] eq "member") { $member = xml_get_word(@$tree[1]); $members = $member; }
        $flag = 0;
    } else {
	if (@$tree[0] eq "member") { $member = xml_get_word(@$tree[1]); $members = $members . "," . $member; }
    }	
    shift @$tree;
    shift @$tree;
  }
  return($members);
}

# Compresses node into a word and returns it.

sub xml_get_word
{
  my $tree = @_[0];

  shift @$tree;  # Skip attributes.

#  print "(DEBUG1 ", @$tree, ")";
  while (@$tree)
  {
    if (@$tree[0] == 0)
    {
      my $retval;

      ($retval = @$tree[1]) =~ tr/ \n\r\t\f//d;
      $retval = xml_entities_to_plain(\$retval);
      return($retval);
    }

    shift @$tree;
    shift @$tree;
  }

  return("");
}


# Compresses misc. whitespace to spaces and returns text.

sub xml_get_text
{
  my $tree = @_[0];

  shift @$tree;  # Skip attributes.

  while (@$tree)
  {
    if (@$tree[0] == 0)
    {
      my $retval;

      ($retval = @$tree[1]) =~ tr/\n\r\t\f/    /;
      $retval = xml_entities_to_plain(\$retval);
      return($retval);
    }

    shift @$tree;
    shift @$tree;
  }
  return ("");
}


# --- XML printing --- #


sub xml_tag
{
  my $tag = @_[0];
  my $text = @_[1];
  indent;
  print "<", $tag, ">";
  print xml_plain_to_entities(\$text);
  print "</", $tag, ">\n";
}

sub xml_tag_if_nonempty
{
  my $tag = @_[0];
  my $text = @_[1];
  return if ($text eq "");
  indent;
  print "<", $tag, ">";
  print xml_plain_to_entities(\$text);
  print "</", $tag, ">\n";
}

sub xml_enter
{
  my $tag = @_[0];
  indent;
  print "<", $tag, ">\n";
  enter;
}

sub xml_leave
{
  my $tag = @_[0];
  leave;
  indent;
  print "</", $tag, ">\n";
}

sub xml_print
{
  my $user;
  my $group;
  my $member;
    
  print "<?xml version='1.0' encoding='ISO-8859-1' standalone='yes'?>\n";
  print "<!DOCTYPE userconf []>\n\n";
  xml_enter("userconf");

  vspace;
  indent; print "<!-- Configuration starts here -->\n";
  vspace;

  for $user ( @users )  {
    xml_enter "user";
    my ($name, $password, $uid, $gid, $gecos, $home, $shell) = @$user;
    xml_tag "name", $name;
    xml_tag "password", $password;
    xml_tag "uid", $uid;
    xml_tag "gid", $gid;
    xml_tag_if_nonempty "info", $gecos;
    xml_tag_if_nonempty "homedir", $home;
    xml_tag_if_nonempty "shell", $shell;
    xml_leave "user";
  }
  vspace;

  for $group ( @groups )  {
    xml_enter "group";
    my ($group, $password, $gid, $members) = @$group;
    xml_tag "name", $group;
    if ($password ne "") {
      xml_tag "password", $password;
    }
    xml_tag "gid", $gid;
    foreach $member (split ',' , $members) {
      xml_tag "member", $member
    }
    
    xml_leave "group";
  }
  vspace;

  indent; print "<!-- End of configuration -->\n";
  vspace;

  xml_leave "userconf";
}


# --- Get (read) config --- #


sub get_immediate
{
}


sub get
{
  if ($verbose) { print STDERR "Getting system configuration, generating XML output.\n"; }

  read_etc_passwd;
  read_etc_group;

  if ($verbose) { print STDERR "Printing XML.\n"; }
  xml_print;
}


# --- Set (write) config --- #


sub set
{
  if ($verbose) { print STDERR "Setting system configuration from XML input.\n"; }

  if ($verbose) { print STDERR "Parsing XML.\n"; }
  xml_parse;
  if ($verbose) { print STDERR "Writing configuration data.\n"; }
  write_etc_passwd;
  write_etc_groups;
}

sub set_immediate
{
}

# --- Filter config: XML in, XML out --- #


sub filter
{
  xml_parse;
  xml_print;
}


# --- Main --- #

$operation = "";  # Major operation user wants to perform. [get | set | filter]


sub set_operation
{
  if ($operation ne "")
  {
    print STDERR "Error: You may specify only one major operation.\n\n";
    print STDERR $Usage;
    exit(1);
  }

  $operation = @_[0];
}


# Process options.

while (@ARGV)
{
  if    (@ARGV[0] eq "--get"    || @ARGV[0] eq "-g") { set_operation("get"); }
  elsif (@ARGV[0] eq "--set"    || @ARGV[0] eq "-s") { set_operation("set"); }
  elsif (@ARGV[0] eq "--filter" || @ARGV[0] eq "-f") { set_operation("filter"); }
  elsif (@ARGV[0] eq "--help"   || @ARGV[0] eq "-h") { print STDERR $Usage; exit(0); }
  elsif (@ARGV[0] eq "--prefix" || @ARGV[0] eq "-p")
  {
    if ($prefix ne "")
    {
      print STDERR "Error: You may specify --prefix only once.\n\n";
      print STDERR $Usage; exit(1);
    }

    $prefix = @ARGV[1];

    if ($prefix eq "")
    {
      print STDERR "Error: You must specify an argument to the --prefix option.\n\n";
      print STDERR $Usage; exit(1);
    }

    shift @ARGV;  # For the argument.
  }
  elsif (@ARGV[0] eq "--disable-immediate")           { $do_immediate = 0; }
  elsif (@ARGV[0] eq "--verbose" || @ARGV[0] eq "-v") { $verbose = 1; }
  else
  {
    print STDERR "Error: Unrecognized option '@ARGV[0]'.\n\n";
    print STDERR $Usage; exit(1);
  }

  shift @ARGV;
}


# Do our thing.

if    ($operation eq "get")    { get; }
elsif ($operation eq "set")    { set; }
elsif ($operation eq "filter") { filter; }
else
{
  print STDERR "Error: No operation specified.\n\n";
  print STDERR $Usage; exit(1);
}

