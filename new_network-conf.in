#!/usr/bin/env perl
#-*-perl-*-

# Network configurator. Designed to be architecture and distribution independent.
#
# Copyright (C) 2000-2001 Ximian, Inc.
#
# Authors: Hans Petter Jansson <hpj@ximian.com>
#          Michael Vogt <mvo@debian.org> (Debian Support)
#          Arturo Espinosa <arturo@ximian.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

# Best viewed with 100 columns of width.

# Configuration files affected:
#
# /etc/resolv.conf
# /etc/host.conf
# /etc/hosts
# /etc/sysconfig/network
# /etc/rc.config
# /etc/smb.conf

# Running programs affected:
#
# smbd
# nmbd
# ifconfig: check current interfaces and activate/deactivate.



require "___scriptsdir___/be.pl";
require "___scriptsdir___/network.pl";


# --- Tool information --- #

$name = "network";
$version = "0.1.0";

$description =<<"end_of_description;";
       Configures all network parameters and interfaces.
end_of_description;

$progress_max = 10;


# Find the tools

$tool_ifconfig = &be_locate_tool ("ifconfig");
$tool_ifup = &be_locate_tool ("ifup");

# --- Configuration file manipulation --- #

# --- Name resolution utilities --- #


# &be_ensure_local_host_entry (<hostname>)
#
# Given a hostname, add the hostname as an alias for the loopback IP, in the
# /etc/hosts database. This is required for tools like nmblookup to work on
# a computer with no reverse name or DNS. The name is added as the first alias,
# which usually means it'll be returned by a lookup on the loopback IP.

sub be_ensure_local_host_entry
{
  my $local_ip = "127.0.0.1";
  my $local_hostname = @_[0];
  my ($ifh, $ofh);
  local (*INFILE, *OUTFILE);
  my $written = 0;

  if ($local_hostname eq "") { return; }

  # Find the file.

  ($ifh, $ofh) = &be_open_filter_write_from_names(@hosts_names);
  if (!$ofh) { return; }  # We didn't find it.
  *INFILE = $ifh; *OUTFILE = $ofh;

  # Write the file, preserving as much as possible from INFILE.

  while (<INFILE>)
  {
    @line = split(/[ \n\r\t]+/, $_);
    if ($line[0] eq "") { shift @line; }  # Leading whitespace. He.

    if ($line[0] ne "" && (not &be_ignore_line($line[0])) &&
#       ($line[0] =~ /[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/) &&
        $line[0] eq $local_ip)
    {
      # Found $local_ip. Add $local_hostname to beginning of list,
      # and remove any other occurrences.

      shift @line;

      printf OUTFILE ("%-16s %s", $local_ip, $local_hostname);
      for $alias (@line)
      {
        if ($alias ne $local_hostname) { print OUTFILE " $alias"; }
      }
      print OUTFILE "\n";

      $written = 1;
    }
    else { print OUTFILE; }
  }

  # If the IP wasn't present, add the entry at the end.

  if (!$written) { printf OUTFILE ("%-16s %s\n", $local_ip, $local_hostname); }
  close INFILE;
  close OUTFILE;
}


# --- XML parsing ---

# Scan XML from standard input to an internal tree.

sub xml_parse
{
  # Scan XML to tree.

  $tree = &be_xml_scan;

  # Walk the tree recursively and extract configuration parameters.
  # This is the top level - find and enter the "network" tag.

  while (@$tree)
  {
    if ($$tree[0] eq "network") { &xml_parse_network ($$tree[1]); }

    shift @$tree;
    shift @$tree;
  }

  return($tree);
}

# <network>...</network>

sub xml_parse_network
{
  my $tree = $_[0];

  shift @$tree;  # Skip attributes.

  while (@$tree)
  {
    if    ($$tree[0] eq "hostname")        { $cf_hostname = &be_xml_get_word($$tree[1]); }
    elsif ($$tree[0] eq "domain")          { $cf_domain = &be_xml_get_word($$tree[1]); }
    elsif ($$tree[0] eq "hostnamereverse") { $cf_hostname_reverse = &be_xml_get_word($$tree[1]); }
    elsif ($$tree[0] eq "domainreverse")   { $cf_domain_reverse = &be_xml_get_word($$tree[1]); }
    elsif ($$tree[0] eq "workgroup")       { $cf_workgroup = &be_xml_get_word($$tree[1]); }
    elsif ($$tree[0] eq "description")     { $cf_description = &be_xml_get_text($$tree[1]); }
    elsif ($$tree[0] eq "winsserver")      { $cf_winsserver = &be_xml_get_word($$tree[1]); }
    elsif ($$tree[0] eq "searchdomain")    { push(@cf_searchdomains, &be_xml_get_word($$tree[1])); }
    elsif ($$tree[0] eq "nameserver")      { push(@cf_nameservers, &be_xml_get_word($$tree[1])); }
    elsif ($$tree[0] eq "statichost")      { &xml_parse_statichost($$tree[1]); }
    elsif ($$tree[0] eq "order")           { &xml_parse_order($$tree[1]); }
    elsif ($$tree[0] eq "hostmatch")       { &xml_parse_hostmatch($$tree[1]); }
    elsif ($$tree[0] eq "interface")       { &xml_parse_interface($$tree[1]); }

    shift @$tree;
    shift @$tree;
  }
}


# <network><statichost>...</statichost></network>

sub xml_parse_statichost
{
  my $tree = $_[0];
  my $ip;
  my @alias;

  push(@cf_statichosts, &be_read_boolean($$tree[0]->{enabled}));
  shift @$tree;

  while (@$tree)
  {
    if    ($$tree[0] eq "ip")    { $ip = &be_xml_get_word($$tree[1]); }
    elsif ($$tree[0] eq "alias") { push(@alias, &be_xml_get_word($$tree[1])); }

    shift @$tree;
    shift @$tree;
  }

  if ($ip =~ /[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/)
  {
    push(@cf_statichosts, $ip);
    push(@cf_statichosts, [@alias]);
  }
  else
  {
    # Print warning message: IP is not well-formed.
  }
}


# <network><order>...</order></network>

sub xml_parse_order
{
  my $tree = $_[0];

  shift @$tree;  # Skip attributes.

  while (@$tree)
  {
    if ($$tree[0] eq "") { shift @$tree; shift @$tree; next; }
    push(@cf_order, $$tree[0]);

    shift @$tree;
    shift @$tree;
  }
}


# <network><hostmatch return=... /></network>

sub xml_parse_hostmatch
{
  my $tree = $_[0];

  # Check attribute; 'all' or 'first'.

  if ($$tree[0]->{return} eq "all") { $cf_hostmatch = 0; }
  else { $cf_hostmatch = 1; }
}


# <interface>...</interface>

sub xml_parse_interface
{
  my $tree = $_[0];
  my %interface;
  my $dev;

  shift @$tree;
  
  while (@$tree)
  {
    $interface{$$tree[0]} = &be_xml_get_word ($$tree[1]);

    shift @$tree;
    shift @$tree;
  }

  $dev = $interface{"dev"};
  delete $interface{"dev"};
  $$cf_nw_interfaces{$dev} = { %interface };
}


# --- XML printing --- #


sub xml_print
{
  my $cfl_hostname = &be_xml_plain_to_entities(\$cf_hostname);
  my $cfl_domain = &be_xml_plain_to_entities(\$cf_domain);
  my $cfl_workgroup = &be_xml_plain_to_entities(\$cf_workgroup);
  my $cfl_description = &be_xml_plain_to_entities(\$cf_description);
  my $cfl_winsserver = &be_xml_plain_to_entities(\$cf_winsserver);
  my $cfl_hostname_reverse = &be_xml_plain_to_entities(\$cf_hostname_reverse);
  my $cfl_domain_reverse = &be_xml_plain_to_entities(\$cf_domain_reverse);
  my ($elem, $elem2);

  print "<?xml version='1.0' encoding='ISO-8859-1' standalone='yes'?>\n";
  print "<!DOCTYPE network []>\n\n";
  print "<network>\n";
  &be_xml_vspace ();
  &be_xml_enter ();

  &be_xml_vspace ();
  &be_xml_print ("<!-- Configuration starts here -->\n");
  &be_xml_vspace ();

  # Hostname, domain, search domains, nameservers.

  if ($cfl_hostname ne "") { &be_xml_print ("<hostname>$cfl_hostname</hostname>\n"); }
  if ($cfl_domain ne "") { &be_xml_print ("<domain>$cfl_domain</domain>\n"); }
  if ($cfl_workgroup ne "") { &be_xml_print ("<workgroup>$cfl_workgroup</workgroup>\n"); }
  if ($cfl_description ne "") { &be_xml_print ("<description>$cfl_description</description>\n"); }
  &be_xml_vspace ();
  if ($cfl_winsserver ne "") { &be_xml_print ("<winsserver>$cfl_winsserver</winsserver>\n"); }
  &be_xml_vspace ();

  for $elem (@cf_searchdomains)
  {
    $elem = &be_xml_plain_to_entities(\$elem);
    &be_xml_print ("<searchdomain>$elem</searchdomain>\n");
  }

  &be_xml_vspace ();

  for $elem (@cf_nameservers)
  {
    $elem = &be_xml_plain_to_entities(\$elem);
    &be_xml_print ("<nameserver>$elem</nameserver>\n");
  }

  # Static hosts.

  my @iplist = @cf_statichosts;
  while (@iplist)
  {
    if ($iplist[0] ne "")
    {
      &be_xml_vspace ();
      &be_xml_print ("<statichost enabled='" . &be_print_boolean_truefalse($iplist[0]) .
                    "'>\n");
      &be_xml_enter ();

      $iplist[1] = &be_xml_plain_to_entities(\$iplist[1]);

      &be_xml_print ("<ip>$iplist[1]</ip>\n");

      my $aliaslist = $iplist[2];
      for $alias (@$aliaslist)
      {
        $alias = &be_xml_plain_to_entities(\$alias);
        &be_xml_print ("<alias>$alias</alias>\n");
      }

      &be_xml_leave ();
      &be_xml_print ("</statichost>\n");
    }

    shift @iplist;
    shift @iplist;
    shift @iplist;
  }

  &be_xml_vspace ();
  &be_xml_print ("<network>\n");
  &be_xml_enter ();
  foreach $elem (keys (%{$cf_nw_global}))
  {
    &be_xml_print ("<$elem>$$cf_nw_global{$elem}</$elem>\n");
  }
  &be_xml_leave ();
  &be_xml_print ("</network>\n");
  
  foreach $elem (keys (%{$cf_nw_interfaces}))
  { 
    &be_xml_vspace ();
    &be_xml_print ("<interface>\n");
    &be_xml_enter ();
    &be_xml_print ("<dev>$elem</dev>\n");
    
    my %interface = %{$ { $cf_nw_interfaces}{$elem}};
    foreach $elem2 (keys (%interface))
    {
      &be_xml_print ("<$elem2>$interface{$elem2}</$elem2>\n");
    }
    
    &be_xml_leave ();
    &be_xml_print ("</interface>\n");
  } 

  &be_xml_vspace ();
  &be_xml_print ("<!-- You shouldn't have to modify anything below this line -->\n");
  &be_xml_vspace ();

  # Search order and host matches (multi).

  &be_xml_print ("<order>");
  for $elem (@cf_order) { print "<$elem/>"; }
  print "</order>\n";

  &be_xml_indent ();
  if ($cf_hostmatch) { print "<hostmatch return='first'/>\n"; }
  else               { print "<hostmatch return='all'/>\n"; }

  &be_xml_vspace ();
  &be_xml_print ("<!-- You cannot modify anything below this line -->\n");
  &be_xml_vspace ();

  if ($cfl_hostname_reverse ne "")
  {
    &be_xml_print ("<hostnamereverse>$cfl_hostname_reverse</hostnamereverse>\n");
  }

  if ($cfl_domain_reverse ne "")
  {
    &be_xml_print ("<domainreverse>$cfl_domain_reverse</domainreverse>\n");
  }

  &be_xml_vspace ();
  &be_xml_print ("<!-- End of configuration -->\n");
  &be_xml_vspace ();

  &be_xml_leave ();
  &be_xml_print ("</network>\n");
}


# Top-level actions.


sub get
{
  my $hash;

  &be_begin ();
  
  # network interface stuff
  $hash = &xst_network_conf_get ();

  # get_immediate needs to go after read_interfaces.
#  &get_immediate ($hash); &be_print_progress ();
  
  &be_end();
  &xml_print ($hash);
}


# --- Set (write) config --- #


sub set_interface_up
{
  my $dev = $_[0];

  # RedHat

  system ("$tool_ifup $dev");
}

sub set_interface_down
{
  my $dev = $_[0];

  system ("$tool_ifconfig $dev down");
}

sub set_active_interfaces
{
  my (%ifaces, %interface, $elem);
  
  open IFCONFIG, "ifconfig -au | sed 's/:* .*//;/^\$/D' |" ||
	 open IFCONFIG, "ifconfig | sed 's/:* .*//;/^\$/D' |";
  # another possibility, instead of sed: awk '/^[a-z]/{print $1}'

  while (<IFCONFIG>)
  {
    chomp;
    $ifaces{$_} = 1;
  }

  close IFCONFIG;

  foreach $elem (keys (%{$cf_nw_interfaces}))
  {
    %interface = %{$ { $cf_nw_interfaces}{$elem}};
    if ($ifaces{$elem} && ! $$interface{"enabled"})
    {
	 &set_interface_down ($elem);
	 next;
    }

    if (!$ifaces{$elem} && $$interface{"enabled"})
    {
	 &set_interface_up ($elem);
    }
  }
}

sub set_immediate
{
  # Set hostname via utility, in case the config files aren't enough.

  if ($cf_hostname ne "")
  {
    if (&be_run("hostname $cf_hostname >/dev/null 2>/dev/null"))
    {
      &be_report_warning(3, "Failed to set runtime hostname");
    }
    else
    {
      &be_report_info(1, "Runtime hostname set");
    }
  }
  else
  {
    &be_report_warning(4, "No hostname specified; runtime hostname not set");
  }

  # Reload SMB configuration.
  
  &be_service_restart(80, "-D", "samba", "smb", "smbd");

  # Activate or deactivate network interfaces

  &set_active_interfaces ();
}


# sub &set_local_host_entry
# {
#   # Temporary solution to find IP address. Ideally we want to define the
#   # hostname for all IPs we have.
# 
#   my $ip = `ifconfig eth0 2>/dev/null`;
#   if ($ip eq "") { $ip = `ifconfig ppp0 2>/dev/null`; }
# 
#   $ip =~ /^.*addr:([0-9]+\.[0-9]+\.[0-9]+\.[0-9]+)/m;
#   $ip = $1;
# 
#   if ($ip eq "")
#   {
#     &be_report_warning(01, "Couldn't find a configured network device");
#     return(0);
#   }
# 
#   &be_ensure_local_host_entry ($ip, $cf_hostname);
# }


sub set
{
  &be_begin ();
  &xml_parse ();

  &write_smb_conf (); &be_progress(10);
  &write_rc_config (); &be_progress(20);
  &write_sysconfig_network (); &be_progress(30);
#  &write_defaultdomain (); &be_progress(40);
  &write_hostname (); &be_progress(50);
  &write_resolv_conf (); &be_progress(60);
  &write_hosts (); &be_progress(70);
  &write_host_conf (); &be_progress(80);
  &be_ensure_local_host_entry ($cf_hostname);

  # network interface configuring
  &set_interfaces (); &be_progress (90);

  if ($be_do_immediate)
  {
    &set_immediate;
  }

  &be_end ();
}


# --- Filter config: XML in, XML out --- #


sub filter
{
  &be_begin ();
  &xml_parse ();
  &be_end ();
  &xml_print ();
}


# --- Main --- #

&be_init ($name, $version, $description, @ARGV);

# Do our thing.

if    ($be_operation eq "get")    { &get; }
elsif ($be_operation eq "set")    { &set; }
elsif ($be_operation eq "filter") { &filter; }
