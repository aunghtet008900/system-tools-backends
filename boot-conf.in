#!/usr/bin/env perl
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-

# Boot manager configurator. Designed to be architecture and distribution independent.
#
# Copyright (C) 2000-2001 Ximian, Inc.
#
# Authors: Tambet Ingo <tambet@ximian.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

# Best viewed with 100 columns of width.

# Configuration files affected:
#
# /etc/lilo.conf

# Running programs affected:
#
# /sbin/lilo

# Distros 
#
# RedHat 7.1   - LILO version 21.4-4
# Mandrake 7.1 - LILO version 21.4-3
# Turbolinux 7.0 - LILO version 21.7.4-4
#
#
#

BEGIN {
require "___scriptsdir___/general.pl";
require "___scriptsdir___/platform.pl";
require "___scriptsdir___/util.pl";
require "___scriptsdir___/file.pl";
require "___scriptsdir___/xml.pl";
require "___scriptsdir___/parse.pl";
require "___scriptsdir___/boot.pl";
}


# --- Tool information --- #

$name = "boot";
$version = "___version___";
@platforms = ("redhat-5.2", "redhat-6.0", "redhat-6.1", "redhat-6.2", "redhat-7.0",
              "redhat-7.1", "mandrake-7.1", "mandrake-7.2", "debian-2.2", "debian-woody", 
	      "suse-7.0", "turbolinux-7.0");

$description =<<"end_of_description;";
       Configures Boot manager (Only LILO at the moment).
end_of_description;


# Find the tools

$tool_lilo = &xst_file_locate_tool ("lilo");


# --- XML parsing ---

# Scan XML from standard input to an internal tree.


sub xml_parse
{
  my ($tree, %hash);
  # Scan XML to tree.

  $tree = &xst_xml_scan;

  # Walk the tree recursively and extract configuration parameters.
  # This is the top level - find and enter the "boot" tag.

  while (@$tree)
  {
    if ($$tree[0] eq "boot") { &xml_parse_boot ($$tree[1], \%hash); }

    shift @$tree;
    shift @$tree;
  }

  return(\%hash);
}


sub xml_parse_boot
{
  my $tree = $_[0];
  my $hash = $_[1];
  my @images;

  shift @$tree;  # Skip attributes.

  while (@$tree)
  {
    if    ($$tree[0] eq "prompt") { $$hash{"prompt"} = &xst_xml_get_word ($$tree[1]); }
    elsif ($$tree[0] eq "root") { $$hash{"root"} = &xst_xml_get_word ($$tree[1]); }
    elsif ($$tree[0] eq "timeout") { $$hash{"timeout"} = &xst_xml_get_word ($$tree[1]); }
    elsif ($$tree[0] eq "default") { $$hash{"default"} = &xst_xml_get_word ($$tree[1]); }
    elsif ($$tree[0] eq "append") { $$hash{"append"} = &xst_xml_get_text ($$tree[1]); }
    elsif ($$tree[0] eq "entry") { &xml_parse_image ($$tree[1], \@images); }

    shift @$tree;
    shift @$tree;
  }

  $$hash{"images"} = \@images; # unless scalar keys %image == 0;
}


sub xml_parse_image
{
  my ($tree, $images) = @_;
  my %hash;
  my $buf;

  shift @$tree;

  while (@$tree)
  {
    $hash{$$tree[0]} = &xst_xml_get_text ($$tree[1]);

    shift @$tree;
    shift @$tree;
  }

  push @$images, \%hash;
}
		   

# --- XML printing --- #
sub xml_print_global_kws
{
  my $h = $_[0];
  my @tags = sort ('prompt', 'lba32', 'compact', 'linear', 'lock');
  my $i;

  while ($i = shift @tags)
  {
    &xst_xml_print_line ("<$i/>\n") if exists $$h{$i};
  }
}


sub xml_print_images
{
  my ($h, $image) = @_;
  my ($i, $val, $array, $entry, %tmp);

  $array = $$h{$image};

  foreach $entry (@$array)
  {
    &xst_xml_print_vspace ();
    &xst_xml_print_line ("<entry>\n");
    &xst_xml_enter ();
    %tmp = %$entry;
        
    &xst_xml_print_line ("<image>$tmp{image}</image>") if exists $tmp{"image"};
    &xst_xml_print_line ("<other>$tmp{other}</other>") if exists $tmp{"other"};
    delete $tmp{"image"};
    delete $tmp{"other"};
    
    foreach $i (sort keys %tmp)
    {
      $val = &xst_xml_quote ($tmp{$i});

      if ($val eq "") { &xst_xml_print_line ("<$i/>\n"); }
      else { &xst_xml_print_line ("<$i>$val</$i>\n"); }
    }
    
    &xst_xml_leave ();
    &xst_xml_print_line ("</entry>\n");
  }
  
  &xst_xml_print_vspace ();
}


sub xml_print
{
  my $h = $_[0];
  my @scalars = qw(boot default delay install keytable map
                   message timeout append root);

  &xst_xml_print_begin ();

  &xml_print_global_kws ($h);
  &xst_xml_print_scalars ($h, @scalars);
  &xml_print_images ($h, 'images');

  &xst_xml_print_end ();
}
  

# Top-level actions.
sub get
{
  my $hash = &xst_boot_conf_get;
  &xst_boot_conf_fix ($hash);
  
  &xst_end;
  &xml_print ($hash);
}


# --- Set (write) config --- #
sub set
{
  my $hash = &xml_parse ();

  if ($hash)
  {
    &xst_boot_conf_fix_xml ($hash);
    &xst_boot_conf_set ($hash);
    &xst_file_run ($tool_lilo);
  }
  else
  {
    # TODO: report error.
    1;
  }
  
  &xst_end;
}


# --- Filter config: XML in, XML out --- #
sub filter
{
  my $hash = &xml_parse;

  &xst_end;
  &xml_print ($hash);
}


# --- Main --- #

# get, set and filter are special cases that don't need more parameters than a ref to their function.
# Read general.pl.in:xst_run_directive to know about the format of this hash.

$directives = {
  "get"    => [ \&get,    [], "" ],
  "set"    => [ \&set,    [], "" ],
  "filter" => [ \&filter, [], "" ]
    };

$tool = &xst_init ($name, $version, $description, $directives, @ARGV);
&xst_platform_ensure_supported ($tool, @platforms);
&xst_run ($tool);
