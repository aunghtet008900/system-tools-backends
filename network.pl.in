#!/usr/bin/env perl
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-

# Common stuff for the ximian-setup-tools backends.
#
# Copyright (C) 2000-2001 Ximian, Inc.
#
# Authors: Hans Petter Jansson <hpj@ximian.com>
#          Arturo Espinosa <arturo@ximian.com>
#          Michael Vogt <mvo@debian.org> - Debian 2.[2|3] support.
#          David Lee Ludwig <davidl@wpi.edu> - Debian 2.[2|3] support.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.


require "___scriptsdir___/general.pl";
require "___scriptsdir___/file.pl";
require "___scriptsdir___/parse.pl";
require "___scriptsdir___/replace.pl";


# This code is not under the portable table style because it is supposed to
# depend on wvdial.
sub xst_network_dialing_get
{
  my %vars =
      (
       "Modem" => "device",
       "Baud" => "speed",
       "Init1" => "init1",
       "Init2" => "init2",
       "Phone" => "phone",
       "Username" => "login",
       "Password" => "password",
       "Dial Command" => "dialcmd",
       "SetVolume" => "setvol",
       "Stupid mode" => "stupid",
       "Inherits" => "inherits"
       );
  my %title2type =
      (
       "Dialer (.*)" => "dialer",
       "Modem(.*)" => "modem"
       );
  
  my ($file) = @_;
  my %ret, @sections;
  my $i, $j, $name, $val;
  
  &xst_run ("wvdialconf $xst_prefix/$file") if (!-e "$xst_prefix/$file");
  
  @sections = &xst_parse_ini_sections ($file);
  foreach $i (@sections)
  {
    my %hash;
    
    $hash{"type"} = "unknown";
    foreach $j (keys %title2type)
    {
      if ($i =~ /$j/)
      {
        $hash{"name"} = $1;
        $hash{"type"} = $title2type{$j};
      }
    }
    
    $ret{$hash{"name"}} = \%hash;
    
    foreach $j (keys %vars)
    {
      $val = &xst_parse_ini ($file, $i, $j);
      $hash{$vars{$j}} = $val if ($val ne undef);
    }
  }
  
  return \%ret;
}

sub xst_network_active_interfaces_get
{
  local *IFCONFIG;
  my $dev;
  my $interface;
  my $tool_ifconfig;
  my @ret = ();

  $tool_ifconfig = &xst_locate_tool ("ifconfig");
  
  open IFCONFIG, "$tool_ifconfig -au | sed 's/:* .*//;/^\$/D' |" ||
    open IFCONFIG, "$tool_ifconfig | sed 's/:* .*//;/^\$/D' |";
  
  while (<IFCONFIG>)
  {
    chomp;
    push @ret, $_;
  }

  close IFCONFIG;

  return @ret;
}
  
sub xst_network_interface_active
{
  my $search_iface = $_[0];
  my @ifaces = &xst_network_active_interfaces_get ();

  while ($ifaces[0])
  {
    return 1 if (shift (@ifaces) eq $search_iface);
  }

  return 0;
}

sub xst_network_sysconfig_ifaces_get_existing
{
  local *IFACE_DIR;
  my @ret, $i, $name;
  
  if (opendir IFACE_DIR, "$xst_prefix/etc/sysconfig/network-scripts")
  {
    foreach $i (readdir (IFACE_DIR))
    {
      if ($i =~ /ifcfg-[a-z0-9]+$/)
      {
        $name = $i;
        $name =~ s/ifcfg-//;
        push @ret, $name;
      }
    }

    closedir (IFACE_DIR);
  }

  return @ret;
}

sub xst_network_interfaces_get
{
  my (%dist_attrib, %hash, %fn, @ifaces, $iface);
  my ($dist, $value, $file, $proc);
  my ($i, $j);

  %dist_attrib = &xst_network_get_interfaces_parse_table ();
  %fn = %{$dist_attrib{"fn"}};
  $proc = $dist_attrib{"ifaces_get"};
  @ifaces = &$proc ();
  $key = 0;
  
  foreach $i (@ifaces)
  {
    foreach $j (keys (%fn))
    {
      $value = $fn{$j};
      $value =~ s/\#iface\#/$i/;
      $ {$dist_attrib{"fn"}}{$j} = $value;
    }

    $iface = &xst_parse_from_table ($dist_attrib{"fn"},
                                    $dist_attrib{"table"});
    $$iface{"file"} = $i;
    $hash{$i} = $iface;
  }

  return \%hash;
}

sub xst_network_conf_get
{
  my %dist_attrib;
  my $hash;

  %dist_attrib = &xst_network_get_parse_table ();

  $hash = &xst_parse_from_table ($dist_attrib{"fn"},
						   $dist_attrib{"table"});
  return $hash;
}

sub xst_network_run_hostname
{
  my $hostname = $_[0];

  &xst_run ("hostname $hostname");
}

sub xst_network_dialing_set
{
  my %vars =
	 (
	  "device" => "Modem",
	  "speed" => "Baud",
	  "init1" => "Init1",
	  "init2" => "Init2",
	  "phone" => "Phone",
	  "login" => "Username",
	  "password" => "Password",
	  "dialcmd" => "Dial Command",
	  "setvol" => "SetVolume",
	  "mode" => "Stupid mode",
	  "inherits"=>"Inherits"
	  );
  my %type2title =
	 (
	  "dialer" => "Dialer #i#",
	  "modem" => "Modem #i#",
	  "unknown" => "#i#"
	  );
  my ($file, $values_hash) = @_;
  my %hash, $section;
  my $ret;
  my $i, $j;

  foreach $i (keys %$values_hash)
  {
    %hash = %{$$values_hash{$i}};

    $section = $type2title{$hash{"type"}};
    $section =~ s/\#i\#/$i/;
    delete $hash{"type"};
    delete $hash{"name"};

    

    foreach $j (keys %hash)
    {
      $ret = -1 if &xst_replace_ini ($file, $section, $vars{$j}, $hash{$j});
    }
  }

  return $ret;
}

sub xst_network_rh62_interface_set
{
  my ($dev, $enabled) = @_;
  my @ifaces, $i;

  if ($enabled)
  {
    return -1 if &xst_run ("ifup $dev");
  }
  else
  {
    print STDERR, "\n\nifdown $dev\n\n";
    return -1 if &xst_run ("ifdown $dev");
  }

  return 0;
}

sub xst_network_remove_pap_entry
{
  my ($file, $login) = @_;
  my $i, $buff;

  $buff = &xst_buffer_load ($file);

  foreach $i (@$buff)
  {
    $i = "" if ($i =~ /^[ \t]*$login[ \t]/);
  }

  &xst_buffer_clean ($buff);
  return &xst_buffer_save ($buff, $file);
}

sub xst_network_rh62_interface_delete
{
  my $dev = $_[0];
  my $file = "/etc/sysconfig/network-scripts/ifcfg-$dev";
  my $login;

  &xst_network_rh62_interface_set ($dev, 0);

  $login = xst_parse_sh ($file, "PAPNAME");
  &xst_network_remove_pap_entry ("/etc/ppp/pap-secrets", $login) if $login ne "";

  unlink ($file);
}

sub xst_network_interfaces_down_changed
{
  my ($proc, $old_hash, $values_hash) = @_;

  @ifaces = &xst_network_active_interfaces_get ();
  foreach $i (@ifaces)
  {
    if (&xst_util_struct_cmp ($old_hash{$i}, $values_hash{$i}))
    {
      return -1 if &$proc ($i, 0);
    }
  }

  return 0;
}

sub xst_network_interfaces_set
{
  my ($old_hash, $values_hash) = @_; 
  my (%dist_attrib, @ifaces, %fn);
  my ($value, $proc);
  my ($i, $j);
  my ($tmp, $res);

  %dist_attrib = &xst_network_get_interface_replace_table ();

  $old_hash = $$old_hash{"interface"};
  # Disable all running interfaces. fixme: this is ugly: should only
  # down those that have been changed, downed or deleted.
  $proc = $dist_attrib{"iface_set"};
  return -1 if &xst_network_interfaces_down_changed ($proc, $old_hash, $values_hash);

  # Delete all existing interfaces that are not in the hash.
  $proc = $dist_attrib{"ifaces_get"};
  @ifaces = &$proc ();
  $proc = $dist_attrib{"iface_delete"};
  foreach $i (@ifaces)
  {
    &$proc ($i) if !exists ($$values_hash{$i});
  }

  %fn = %{$dist_attrib{"fn"}};
  foreach $i (keys %$values_hash)
  {
    foreach $j (keys (%fn))
    {
      $value = $fn{$j};
      $value =~ s/\#iface\#/$i/;
      $ {$dist_attrib{"fn"}}{$j} = $value;
    }
    
    $tmp = &xst_replace_from_table ($dist_attrib{"fn"}, $dist_attrib{"table"},
                                    $$values_hash{$i}, $$old_hash{$i});
    if (!$tmp) # if success saving the settings for the interface, set up immediatly.
    {
      $tmp = &$proc ($ {$$values_hash{$i}}{"dev"}, 1) if ($ {$$values_hash{$i}}{"enabled"});
    }
    
    $res = $tmp if !$res;
  }

  return $res;
}

sub xst_network_conf_set
{
  my $values_hash = $_[0];
  my $old_hash;
  my %dist_attrib;
  
  &xst_network_ensure_local_host_entry ($values_hash, "127.0.0.1");

  $old_hash = &xst_network_conf_get ();
  %dist_attrib = &xst_network_get_replace_table ();
  $res = &xst_replace_from_table ($dist_attrib{"fn"}, $dist_attrib{"table"},
                                  $values_hash, $old_hash);
  return $res;
}

sub xst_network_get_pap_passwd
{
  my ($file, $login) = @_;
  my @arr;

  $arr = &xst_parse_split_first_array ($file, $login, "[ \t]+", "[ \t]+");

  return $$arr[1];
}

sub xst_network_rh62_parse_bootproto
{
  my $ret;
  my %rh62_to_proto_name =
	 (
	  "bootp" => "bootp",
	  "dhcp" => "dhcp",
	  "none" => "none"
	  );

  $ret = &xst_parse_sh (@_);

  return $rh62_to_proto_name{$ret};
}

sub xst_network_rh62_replace_bootproto
{
  my ($file, $key, $value) = @_;
  my %proto_name_to_rh62 =
	 (
	  "bootp" => "bootp",
	  "dhcp" => "dhcp",
	  "none" => "none"
	  );

  return &xst_parse_sh ($file, $key, $proto_name_to_rh62{$value});
}  

# lo_ip is the ip for localhost (commonly 127.0.0.1).
sub xst_network_ensure_local_host_entry
{
  my $values_hash = $_[0];
  my $lo_ip = $_[1];
  my $hostname = $$values_hash{"hostname"};
  my $statichost = $$values_hash{"statichost"};

  my $i;

  if (exists $$statichost{$lo_ip})
  {
    my $localhost = $$statichost{$lo_ip};
    foreach $i (@$localhost)
    {
      return if ($i eq $hostname);
    }

    push @$localhost, $hostname;
  }
  else
  {
    $$statichost{$lo_ip} = [ ($hostname) ];
  }  
}

sub xst_network_get_parse_table
{
  my %dist_map =
	 (
	  "redhat-6.0" => "redhat-6.2",
	  "redhat-6.1" => "redhat-6.2",
	  "redhat-6.2" => "redhat-6.2",
	  "redhat-7.0" => "redhat-6.2"
	  );

  my %dist_tables =
	 (
	  "redhat-6.2" =>
	  {
	    fn =>
	    {
		 SYSCONFIG_NW => "/etc/sysconfig/network",
		 RESOLV_CONF  => "/etc/resolv.conf",
		 HOST_CONF    => "/etc/host.conf",
		 HOSTS        => "/etc/hosts",
		 SMB_CONF     => "/etc/smb.conf",
		 WVDIAL       => "/etc/wvdial.conf" },
	    table =>
		   [
		    [ auto,          \&xst_parse_sh_bool,           SYSCONFIG_NW, NETWORKING ],
		    [ forward,       \&xst_parse_sh_bool,           SYSCONFIG_NW, FORWARD_IPV4 ],
		    [ hostname,      \&xst_parse_sh,                SYSCONFIG_NW, HOSTNAME ],
		    [ gateway,       \&xst_parse_sh,                SYSCONFIG_NW, GATEWAY],
		    [ gateway_dev,   \&xst_parse_sh,                SYSCONFIG_NW, GATEWAYDEV],
		    [ domain,        \&xst_parse_sh,                SYSCONFIG_NW, DOMAIN],
		    [ nameserver,    \&xst_parse_split_all,         RESOLV_CONF,  nameserver, "[ \t]+" ],
		    [ searchdomain,  \&xst_parse_split_first_array, RESOLV_CONF,  search, "[ \t]+", "[ \t]+" ],
		    [ domainname,    \&xst_parse_split_first_str,   RESOLV_CONF,  domain, "[ \t]+" ],
		    [ order,         \&xst_parse_split_first_array, HOST_CONF,    order, "[ \t]+", "," ],
		    [ hostmatch,     \&xst_parse_split_first_bool,  HOST_CONF,    multi, "[ \t]+" ],
		    [ statichost,    \&xst_parse_split_hash,        HOSTS,        "[ \t]+", "[ \t]+" ],
		    [ workgroup,     \&xst_parse_ini,               SMB_CONF,     "global", "workgroup" ],     
		    [ description,   \&xst_parse_ini,               SMB_CONF,     "global", "server string" ],    
		    [ winsserver,    \&xst_parse_ini,               SMB_CONF,     "global", "wins server" ],
		    [ dialing,       \&xst_network_dialing_get,     WVDIAL ],
		    [ interface,     \&xst_network_interfaces_get ]
		    ]
			 }
	  );
  
  my $dist = $dist_map{$xst_dist};
  return %{$dist_tables{$dist}} if $dist;

  # FIXME: This is a fatal error, and should make us bail.
  return undef;
}

sub xst_network_get_interfaces_parse_table
{
  my %dist_map =
	 (
	  "redhat-6.0" => "redhat-6.2",
	  "redhat-6.1" => "redhat-6.2",
	  "redhat-6.2" => "redhat-6.2",
	  "redhat-7.0" => "redhat-6.2"
	  );
  
  my %dist_tables =
	 (
	  "redhat-6.2" =>
	  {
	    ifaces_get => \&xst_network_sysconfig_ifaces_get_existing,
	    fn =>
	    {
        IFCFG => "/etc/sysconfig/network-scripts/ifcfg-#iface#",
        CHAT => "/etc/sysconfig/network-scripts/chat-#iface#",
        IFACE => "#iface#",
        PAP => "/etc/ppp/pap-secrets" },
	    table =>
          [
           [ name,               \&xst_parse_sh,      IFCFG, NAME ],
           [ dev,                \&xst_parse_sh,      IFCFG, DEVICE ],
           [ address,            \&xst_parse_sh,      IFCFG, IPADDR ],
           [ netmask,            \&xst_parse_sh,      IFCFG, NETMASK ],
           [ broadcast,          \&xst_parse_sh,      IFCFG, BROADCAST ],
           [ network,            \&xst_parse_sh,      IFCFG, NETWORK ],
           [ gateway,            \&xst_parse_sh,      IFCFG, GATEWAY ],
           [ dns1,               \&xst_parse_sh,      IFCFG, DNS1 ],
           [ dns2,               \&xst_parse_sh,      IFCFG, DNS2 ],
           [ bootproto,          \&xst_network_rh62_parse_bootproto, IFCFG, BOOTPROTO ],
           [ mtu,                \&xst_parse_sh,      IFCFG, MTU ],
           [ mru,                \&xst_parse_sh,      IFCFG, MRU ],
           [ remote_address,     \&xst_parse_sh,      IFCFG, REMIP ],
           [ login,              \&xst_parse_sh,      IFCFG, PAPNAME ],
           [ password,           \&xst_network_get_pap_passwd, PAP, "%login" ],
           [ disconnect_timeout, \&xst_parse_sh,      IFCFG, DISCONNECTTIMEOUT ],
           [ retry_timeout,      \&xst_parse_sh,      IFCFG, RETRYTIMEOUT ],
           [ serial_port,        \&xst_parse_sh,      IFCFG, MODEMPORT ],
           [ serial_speed,       \&xst_parse_sh,      IFCFG, LINESPEED ],
           [ serial_init,        \&xst_parse_sh,      IFCFG, INITSTRING ],
           [ ppp_options,        \&xst_parse_sh,      IFCFG, PPPOPTIONS ],
           [ wvsection,          \&xst_parse_sh,      IFCFG, WVDIALSECT ],
           [ auto,               \&xst_parse_sh_bool, IFCFG, ONBOOT ],
           [ user,               \&xst_parse_sh_bool, IFCFG, USERCTL ],
           [ set_default_gw,     \&xst_parse_sh_bool, IFCFG, DEFROUTE ],
           [ debug,              \&xst_parse_sh_bool, IFCFG, DEBUG ],
           [ persist,            \&xst_parse_sh_bool, IFCFG, PERSIST ],
           [ serial_escapechars, \&xst_parse_sh_bool, IFCFG, ESCAPECHARS ],
           [ serial_defabort,    \&xst_parse_sh_bool, IFCFG, DEFABORT ],
           [ serial_hwctl,       \&xst_parse_sh_bool, IFCFG, HARDFLOWCTL ],
           [ phone_number,       \&xst_parse_chat,    CHAT,  "^atd[^0-9]*([0-9, -]+)" ],
           [ enabled,            \&xst_network_interface_active, IFACE ]
           ]
             }
	  );
  
  my $dist = $dist_map{$xst_dist};
  return %{$dist_tables{$dist}} if $dist;

  # FIXME: This is a fatal error, and should make us bail.
  return undef;
}

sub xst_network_get_replace_table
{
  my %dist_map =
	 (
	  "redhat-6.0" => "redhat-6.2",
	  "redhat-6.1" => "redhat-6.2",
	  "redhat-6.2" => "redhat-6.2",
	  "redhat-7.0" => "redhat-6.2"
	  );

  my %dist_tables =
	 (
	  "redhat-6.2" =>
	  {
	    fn =>
	    {
        SYSCONFIG_NW => "/etc/sysconfig/network",
        RESOLV_CONF  => "/etc/resolv.conf",
        HOST_CONF    => "/etc/host.conf",
        HOSTS        => "/etc/hosts",
        SMB_CONF     => "/etc/smb.conf",
        WVDIAL       => "/etc/wvdial.conf" },
	    table =>
          [
           [ auto,          \&xst_replace_sh_bool,          SYSCONFIG_NW, NETWORKING ],
           [ forward,       \&xst_replace_sh_bool,          SYSCONFIG_NW, FORWARD_IPV4 ],
           [ hostname,      \&xst_replace_sh,               SYSCONFIG_NW, HOSTNAME ],
           [ hostname,      \&xst_network_run_hostname ],
           [ gateway,       \&xst_replace_sh,               SYSCONFIG_NW, GATEWAY],
           [ gateway_dev,   \&xst_replace_sh,               SYSCONFIG_NW, GATEWAYDEV],
           [ domain,        \&xst_replace_sh,               SYSCONFIG_NW, DOMAIN],
           [ nameserver,    \&xst_replace_join_all,         RESOLV_CONF,  nameserver, "[ \t]+" ],
           [ searchdomain,  \&xst_replace_join_first_array, RESOLV_CONF,  search, "[ \t]+", "[ \t]+" ],
           [ domainname,    \&xst_replace_join_first_str,   RESOLV_CONF,  domain, "[ \t]+" ],
           [ order,         \&xst_replace_join_first_array, HOST_CONF,    order, "[ \t]+", "," ],
           [ hostmatch,     \&xst_replace_join_first_bool,  HOST_CONF,    multi, "[ \t]+", "on", "off" ],
           [ statichost,    \&xst_replace_join_hash,        HOSTS,        "[ \t]+", "[ \t]+" ],
           [ workgroup,     \&xst_replace_ini,              SMB_CONF,     "global", "workgroup" ],     
           [ description,   \&xst_replace_ini,              SMB_CONF,     "global", "server string" ],
           [ winsserver,    \&xst_replace_ini,              SMB_CONF,     "global", "wins server" ],
           [ dialing,       \&xst_network_dialing_set,      WVDIAL ],
           [ interface,     \&xst_network_interfaces_set,		OLD_HASH ]
           ]
             }
	  );
  
  my $dist = $dist_map{$xst_dist};
  return %{$dist_tables{$dist}} if $dist;

  # FIXME: This is a fatal error, and should make us bail.
  return undef;
}

sub xst_network_get_interface_replace_table
{
  my %dist_map =
	 (
	  "redhat-6.0" => "redhat-6.2",
	  "redhat-6.1" => "redhat-6.2",
	  "redhat-6.2" => "redhat-6.2",
	  "redhat-7.0" => "redhat-6.2"
	  );

  my %dist_tables =
	(
    "redhat-6.2" =>
	  {
      iface_set => \&xst_network_rh62_interface_set,
      iface_delete => \&xst_network_rh62_interface_delete,
      ifaces_get => \&xst_network_sysconfig_ifaces_get_existing,
      fn =>
	    {
        IFCFG => "/etc/sysconfig/network-scripts/ifcfg-#iface#",
        CHAT => "/etc/sysconfig/network-scripts/chat-#iface#",
        IFACE => "#iface#",
        WVDIAL => "/etc/wvdial.conf"
      },
      table =>
       [
        [ name,               \&xst_replace_sh,      IFCFG, NAME ],
        [ dev,                \&xst_replace_sh,      IFCFG, DEVICE ],
        [ address,            \&xst_replace_sh,      IFCFG, IPADDR ],
        [ netmask,            \&xst_replace_sh,      IFCFG, NETMASK ],
        [ broadcast,          \&xst_replace_sh,      IFCFG, BROADCAST ],
        [ network,            \&xst_replace_sh,      IFCFG, NETWORK ],
        [ gateway,            \&xst_replace_sh,      IFCFG, GATEWAY ],
        [ dns1,               \&xst_replace_sh,      IFCFG, DNS1 ],
        [ dns2,               \&xst_replace_sh,      IFCFG, DNS2 ],
        [ bootproto,          \&xst_network_rh62_replace_bootproto, IFCFG, BOOTPROTO ],
        [ mtu,                \&xst_replace_sh,      IFCFG, MTU ],
        [ mru,                \&xst_replace_sh,      IFCFG, MRU ],
        [ remote_address,     \&xst_replace_sh,      IFCFG, REMIP ],
        [ login,              \&xst_replace_sh,      IFCFG, PAPNAME ],
        [ disconnect_timeout, \&xst_replace_sh,      IFCFG, DISCONNECTTIMEOUT ],
        [ retry_timeout,      \&xst_replace_sh,      IFCFG, RETRYTIMEOUT ],
        [ serial_port,        \&xst_replace_sh,      IFCFG, MODEMPORT ],
        [ serial_speed,       \&xst_replace_sh,      IFCFG, LINESPEED ],
        [ serial_init,        \&xst_replace_sh,      IFCFG, INITSTRING ],
        [ ppp_options,        \&xst_replace_sh,      IFCFG, PPPOPTIONS ],
        [ wvsection,          \&xst_replace_sh,      IFCFG, WVDIALSECT ],
        [ auto,               \&xst_replace_sh_bool, IFCFG, ONBOOT ],
        [ user,               \&xst_replace_sh_bool, IFCFG, USERCTL ],
        [ set_default_gw,     \&xst_replace_sh_bool, IFCFG, DEFROUTE ],
        [ debug,              \&xst_replace_sh_bool, IFCFG, DEBUG ],
        [ persist,            \&xst_replace_sh_bool, IFCFG, PERSIST ],
        [ serial_escapechars, \&xst_replace_sh_bool, IFCFG, ESCAPECHARS ],
        [ serial_defabort,    \&xst_replace_sh_bool, IFCFG, DEFABORT ],
        [ serial_hwctl,       \&xst_replace_sh_bool, IFCFG, HARDFLOWCTL ],
        [ phone_number,       \&xst_replace_chat,    CHAT,  "^atd[^0-9]*([0-9, -]+)" ]
      ]
    }
  );
  
  my $dist = $dist_map{$xst_dist};
  return %{$dist_tables{$dist}} if $dist;

  # FIXME: This is a fatal error, and should make us bail.
  return undef;
}

1;
