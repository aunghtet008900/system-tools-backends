#!/usr/bin/env perl
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-

# Common stuff for the ximian-setup-tools backends.
#
# Copyright (C) 2000-2001 Ximian, Inc.
#
# Authors: Hans Petter Jansson <hpj@ximian.com>
#          Arturo Espinosa <arturo@ximian.com>
#          Michael Vogt <mvo@debian.org> - Debian 2.[2|3] support.
#          David Lee Ludwig <davidl@wpi.edu> - Debian 2.[2|3] support.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.


require "___scriptsdir___/general.pl";
require "___scriptsdir___/file.pl";
require "___scriptsdir___/parse.pl";
require "___scriptsdir___/replace.pl";


sub xst_network_active_interfaces_get
{
  local *IFCONFIG;
  my $dev;
  my $interface;
  my $tool_ifconfig;
  my @ret = ();

  $tool_ifconfig = &be_locate_tool ("ifconfig");
  
  open IFCONFIG, "$tool_ifconfig -au | sed 's/:* .*//;/^\$/D' |" ||
    open IFCONFIG, "$tool_ifconfig | sed 's/:* .*//;/^\$/D' |";
  
  while (<IFCONFIG>)
  {
    chomp;
    push @ret, $_;
  }

  close IFCONFIG;

  return @ret;
}
  
sub xst_network_interface_active
{
  my $search_iface = $_[0];
  my @ifaces = &xst_network_active_interfaces_get ();

  while ($ifaces[0])
  {
    return 1 if (shift (@ifaces) eq $search_iface);
  }

  return 0;
}

sub xst_network_sysconfig_ifaces_get_existing
{
  local *IFACE_DIR;
  my @ret, $i, $name;
  
  if (opendir IFACE_DIR, "/etc/sysconfig/network-scripts")
  {
    foreach $i (readdir (IFACE_DIR))
    {
      if ($i =~ /ifcfg-[a-z0-9]+$/)
      {
        $name = $i;
        $name =~ s/ifcfg-//;
        push @ret, $name;
      }
    }

    closedir (IFACE_DIR);
  }

  return @ret;
}

sub xst_network_interfaces_get
{
  my (%dist_attrib, %hash, %fn, @ifaces);
  my ($dist, $value, $file, $proc);
  my ($i, $j);

  %dist_attrib = &xst_network_get_interfaces_parse_table ();

  %fn = %{$dist_attrib{"fn"}};
  $proc = $dist_attrib{"ifaces_get"};
  @ifaces = &$proc ();
  foreach $i (@ifaces)
  {
    foreach $j (keys (%fn))
    {
      $value = $fn{$j};
      $value =~ s/\#iface\#/$i/;
      $ {$dist_attrib{"fn"}}{$j} = $value;
    }

    $hash{$i} = &xst_parse_from_table ($dist_attrib{"fn"},
                                       $dist_attrib{"table"});
  }

  return \%hash;
}

sub xst_network_conf_get
{
  my %dist_attrib;
  my $hash;

  %dist_attrib = &xst_network_get_parse_table ();

  $hash = &xst_parse_from_table ($dist_attrib{"fn"},
						   $dist_attrib{"table"});
  return $hash;
}

sub xst_network_rh62_interface_set
{
  my ($dev, $enabled) = @_;
  my @ifaces, $i, $dev;

  return -1 if &be_run ("ifdown $dev");
  
  if ($enabled)
  {
    return -1 if &be_run ("ifup $dev");
  }

  return 0;
}

sub xst_network_interfaces_set
{
  my $values_hash = $_[0]; 
  my (%dist_attrib, @ifaces, %fn);
  my ($value, $proc);
  my ($i, $j);
  my ($tmp, $res);

  %dist_attrib = &xst_network_get_interface_replace_table ();

  # Disable all running interfaces. fixme: this is ugly: should only
  # down those that have been changed, downed or deleted.
  $proc = $dist_attrib{"iface_set"};
  @ifaces = &xst_network_active_interfaces_get ();
  foreach $i (@ifaces)
  {
    return -1 if &$proc ($i, 0);
  }

  %fn = %{$dist_attrib{"fn"}};
  foreach $i (keys %$values_hash)
  {
    foreach $j (keys (%fn))
    {
	 $value = $fn{$j};
	 $value =~ s/\#iface\#/$i/;
	 $ {$dist_attrib{"fn"}}{$j} = $value;
    }
    
    $tmp = &xst_replace_from_table ($dist_attrib{"fn"},
							 $dist_attrib{"table"}, $$values_hash {$i});
    if (!$tmp) # if success saving the settings for the interface, set up immediatly.
    {
	 $tmp = &$proc ($ {$$values_hash{$i}}{"dev"}, 1) if ($ {$$values_hash{$i}}{"enabled"});
    }
    
    $res = $tmp if !$res;
  }

  return $res;
}

sub xst_network_conf_set
{
  my $values_hash = $_[0];
  my %dist_attrib;
  
  %dist_attrib = &xst_network_get_replace_table ();

  $res = &xst_replace_from_table ($dist_attrib{"fn"},
						    $dist_attrib{"table"}, $values_hash);
  return $res;
}

sub xst_network_rh62_parse_bootproto
{
  my $ret;
  my %rh62_to_proto_name =
	 (
	  "bootp" => "bootp",
	  "dhcp" => "dhcp",
	  "none" => "none"
	  );

  $ret = &xst_parse_sh (@_);

  return $rh62_to_proto_name{$ret};
}

sub xst_network_rh62_replace_bootproto
{
  my ($file, $key, $value) = @_;
  my %proto_name_to_rh62 =
	 (
	  "bootp" => "bootp",
	  "dhcp" => "dhcp",
	  "none" => "none"
	  );

  return &xst_parse_sh ($file, $key, $proto_name_to_rh62{$value});
}  

# xst_ensure_local_host_entry (<hostname>)
#
# Given a hostname, add the hostname as an alias for the loopback IP, in the
# /etc/hosts database. This is required for tools like nmblookup to work on
# a computer with no reverse name or DNS. The name is added as the first alias,
# which usually means it'll be returned by a lookup on the loopback IP.

sub xst_ensure_local_host_entry
{
  my $local_ip = "127.0.0.1";
  my $local_hostname = @_[0];
  my ($ifh, $ofh);
  local (*INFILE, *OUTFILE);
  my $written = 0;

  if ($local_hostname eq "") { return; }

  # Find the file.

  ($ifh, $ofh) = &xst_open_filter_write_from_names (@hosts_names);
  if (!$ofh) { return; }  # We didn't find it.
  *INFILE = $ifh; *OUTFILE = $ofh;

  # Write the file, preserving as much as possible from INFILE.

  while (<INFILE>)
  {
    @line = split(/[ \n\r\t]+/, $_);
    if ($line[0] eq "") { shift @line; }  # Leading whitespace. He.

    if ($line[0] ne "" && (not &xst_ignore_line ($line[0])) &&
#       ($line[0] =~ /[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/) &&
        $line[0] eq $local_ip)
    {
      # Found $local_ip. Add $local_hostname to beginning of list,
      # and remove any other occurrences.

      shift @line;

      printf OUTFILE ("%-16s %s", $local_ip, $local_hostname);
      for $alias (@line)
      {
        if ($alias ne $local_hostname) { print OUTFILE " $alias"; }
      }
      print OUTFILE "\n";

      $written = 1;
    }
    else { print OUTFILE; }
  }

  # If the IP wasn't present, add the entry at the end.

  if (!$written) { printf OUTFILE ("%-16s %s\n", $local_ip, $local_hostname); }
  close INFILE;
  close OUTFILE;
}

sub xst_network_get_parse_table
{
  my %dist_map =
  (
    "redhat-6.0" => "redhat-6.2",
    "redhat-6.1" => "redhat-6.2",
    "redhat-6.2" => "redhat-6.2"
  );

  my %dist_tables =
  (
    "redhat-6.2" =>
    {
      fn =>
      {
        SYSCONFIG_NW => "/etc/sysconfig/network",
        RESOLV_CONF  => "/etc/resolv.conf",
        HOST_CONF    => "/etc/host.conf",
        HOSTS        => "/etc/hosts",
        SMB_CONF     => "/etc/smb.conf"
      },
      table =>
      [
        [ auto,          \&xst_parse_sh_bool,           SYSCONFIG_NW, NETWORKING ],
        [ forward,       \&xst_parse_sh_bool,           SYSCONFIG_NW, FORWARD_IPV4 ],
        [ hostname,      \&xst_parse_sh,                SYSCONFIG_NW, HOSTNAME ],
        [ gateway,       \&xst_parse_sh,                SYSCONFIG_NW, GATEWAY],
        [ gateway_dev,   \&xst_parse_sh,                SYSCONFIG_NW, GATEWAYDEV],
        [ domain,        \&xst_parse_sh,                SYSCONFIG_NW, DOMAIN],
        [ nameserver,    \&xst_parse_split_all,         RESOLV_CONF,  nameserver, "[ \t]+" ],
        [ searchdomain,  \&xst_parse_split_first_array, RESOLV_CONF,  search, "[ \t]+", "[ \t]+" ],
        [ domainname,    \&xst_parse_split_first_str,   RESOLV_CONF,  domain, "[ \t]+" ],
        [ order,         \&xst_parse_split_first_array, HOST_CONF,    order, "[ \t]+", "," ],
        [ hostmatch,     \&xst_parse_split_first_bool,  HOST_CONF,    multi, "[ \t]+" ],
        [ statichost,    \&xst_parse_split_hash,        HOSTS,        "[ \t]+", "[ \t]+" ],
        [ workgroup,     \&xst_parse_ini,               SMB_CONF,     "global", "workgroup" ],     
        [ description,   \&xst_parse_ini,               SMB_CONF,     "global", "server string" ],    
        [ winsserver,    \&xst_parse_ini,               SMB_CONF,     "global", "wins server" ],
        [ interface,     \&xst_network_interfaces_get ]
      ]
    }
  );

  my $dist = $dist_map{$be_dist};
  return %{$dist_tables{$dist}} if $dist;

  # FIXME: This is a fatal error, and should make us bail.
  return undef;
}

sub xst_network_get_interfaces_parse_table
{
  my %dist_map =
	 (
	  "redhat-6.0" => "redhat-6.2",
	  "redhat-6.1" => "redhat-6.2",
	  "redhat-6.2" => "redhat-6.2"
	  );
  
  my %dist_tables =
	 (
	  "redhat-6.2" =>
	  {
	    ifaces_get => \&xst_network_sysconfig_ifaces_get_existing,
	    fn =>
	    {
		 IFCFG => "/etc/sysconfig/network-scripts/ifcfg-#iface#",
		 CHAT => "/etc/sysconfig/network-scripts/chat-#iface#",
		 IFACE => "#iface#" },
	    table =>
		   [
		    [ dev,                \&xst_parse_sh,      IFCFG, DEVICE ],
		    [ address,            \&xst_parse_sh,      IFCFG, IPADDR ],
		    [ netmask,            \&xst_parse_sh,      IFCFG, NETMASK ],
		    [ broadcast,          \&xst_parse_sh,      IFCFG, BROADCAST ],
		    [ network,            \&xst_parse_sh,      IFCFG, NETWORK ],
		    [ bootproto,          \&xst_network_rh62_parse_bootproto, IFCFG, BOOTPROTO ],
		    [ mtu,                \&xst_parse_sh,      IFCFG, MTU ],
		    [ mru,                \&xst_parse_sh,      IFCFG, MRU ],
		    [ remote_address,     \&xst_parse_sh,      IFCFG, REMIP ],
		    [ login,              \&xst_parse_sh,      IFCFG, PAPNAME ],
		    [ disconnect_timeout, \&xst_parse_sh,      IFCFG, DISCONNECTTIMEOUT ],
		    [ retry_timeout,      \&xst_parse_sh,      IFCFG, RETRYTIMEOUT ],
		    [ serial_port,        \&xst_parse_sh,      IFCFG, MODEMPORT ],
		    [ serial_speed,       \&xst_parse_sh,      IFCFG, LINESPEED ],
		    [ serial_init,        \&xst_parse_sh,      IFCFG, INITSTRING ],
		    [ ppp_options,        \&xst_parse_sh,      IFCFG, PPPOPTIONS ],
		    [ auto,               \&xst_parse_sh_bool, IFCFG, ONBOOT ],
		    [ user,               \&xst_parse_sh_bool, IFCFG, USERCTL ],
		    [ set_default_gw,     \&xst_parse_sh_bool, IFCFG, DEFROUTE ],
		    [ debug,              \&xst_parse_sh_bool, IFCFG, DEBUG ],
		    [ persist,            \&xst_parse_sh_bool, IFCFG, PERSIST ],
		    [ serial_escapechars, \&xst_parse_sh_bool, IFCFG, ESCAPECHARS ],
		    [ serial_defabort,    \&xst_parse_sh_bool, IFCFG, DEFABORT ],
		    [ serial_hwctl,       \&xst_parse_sh_bool, IFCFG, HARDFLOWCTL ],
		    [ phone_number,       \&xst_parse_chat,    CHAT,  "^atd[^0-9]*([0-9, -]+)" ],
		    [ enabled,            \&xst_network_interface_active, IFACE ]
		    ]
			 }
	  );

  my $dist = $dist_map{$be_dist};
  return %{$dist_tables{$dist}} if $dist;

  # FIXME: This is a fatal error, and should make us bail.
  return undef;
}

sub xst_network_get_replace_table
{
  my %dist_map =
  (
    "redhat-6.0" => "redhat-6.2",
    "redhat-6.1" => "redhat-6.2",
    "redhat-6.2" => "redhat-6.2"
  );

  my %dist_tables =
  (
    "redhat-6.2" =>
    {
      fn =>
      {
        SYSCONFIG_NW => "/etc/sysconfig/network",
        RESOLV_CONF  => "/etc/resolv.conf",
        HOST_CONF    => "/etc/host.conf",
        HOSTS        => "/etc/hosts",
        SMB_CONF     => "/etc/smb.conf"
      },
      table =>
      [
        [ auto,          \&xst_replace_sh_bool,          SYSCONFIG_NW, NETWORKING ],
        [ forward,       \&xst_replace_sh_bool,          SYSCONFIG_NW, FORWARD_IPV4 ],
        [ hostname,      \&xst_replace_sh,               SYSCONFIG_NW, HOSTNAME ],
        [ gateway,       \&xst_replace_sh,               SYSCONFIG_NW, GATEWAY],
        [ gateway_dev,   \&xst_replace_sh,               SYSCONFIG_NW, GATEWAYDEV],
        [ domain,        \&xst_replace_sh,               SYSCONFIG_NW, DOMAIN],
        [ nameserver,    \&xst_replace_join_all,         RESOLV_CONF,  nameserver, "[ \t]+" ],
        [ searchdomain,  \&xst_replace_join_first_array, RESOLV_CONF,  search, "[ \t]+", "[ \t]+" ],
        [ domainname,    \&xst_replace_join_first_str,   RESOLV_CONF,  domain, "[ \t]+" ],
        [ order,         \&xst_replace_join_first_array, HOST_CONF,    order, "[ \t]+", "," ],
        [ hostmatch,     \&xst_replace_join_first_bool,  HOST_CONF,    multi, "[ \t]+", "on", "off" ],
        [ statichost,    \&xst_replace_join_hash,        HOSTS,        "[ \t]+", "[ \t]+" ],
        [ workgroup,     \&xst_replace_ini,              SMB_CONF,     "global", "workgroup" ],     
        [ description,   \&xst_replace_ini,              SMB_CONF,     "global", "server string" ],
        [ winsserver,    \&xst_replace_ini,              SMB_CONF,     "global", "wins server" ],
        [ interface,     \&xst_network_interfaces_set ]
      ]
    }
  );

  my $dist = $dist_map{$be_dist};
  return %{$dist_tables{$dist}} if $dist;

  # FIXME: This is a fatal error, and should make us bail.
  return undef;
}

sub xst_network_get_interface_replace_table
{
  my %dist_map =
  (
    "redhat-6.0" => "redhat-6.2",
    "redhat-6.1" => "redhat-6.2",
    "redhat-6.2" => "redhat-6.2"
  );

  my %dist_tables =
	(
    "redhat-6.2" =>
	  {
      iface_set => \&xst_network_rh62_interface_set,
      fn =>
	    {
        IFCFG => "/etc/sysconfig/network-scripts/ifcfg-#iface#",
        CHAT => "/etc/sysconfig/network-scripts/chat-#iface#" ,
        IFACE => "#iface#"
      },
      table =>
      [
        [ dev,                \&xst_replace_sh,      IFCFG, DEVICE ],
        [ address,            \&xst_replace_sh,      IFCFG, IPADDR ],
        [ netmask,            \&xst_replace_sh,      IFCFG, NETMASK ],
        [ broadcast,          \&xst_replace_sh,      IFCFG, BROADCAST ],
        [ network,            \&xst_replace_sh,      IFCFG, NETWORK ],
        [ bootproto,          \&xst_network_rh62_replace_bootproto, IFCFG, BOOTPROTO ],
        [ mtu,                \&xst_replace_sh,      IFCFG, MTU ],
        [ mru,                \&xst_replace_sh,      IFCFG, MRU ],
        [ remote_address,     \&xst_replace_sh,      IFCFG, REMIP ],
        [ login,              \&xst_replace_sh,      IFCFG, PAPNAME ],
        [ disconnect_timeout, \&xst_replace_sh,      IFCFG, DISCONNECTTIMEOUT ],
        [ retry_timeout,      \&xst_replace_sh,      IFCFG, RETRYTIMEOUT ],
        [ serial_port,        \&xst_replace_sh,      IFCFG, MODEMPORT ],
        [ serial_speed,       \&xst_replace_sh,      IFCFG, LINESPEED ],
        [ serial_init,        \&xst_replace_sh,      IFCFG, INITSTRING ],
        [ ppp_options,        \&xst_replace_sh,      IFCFG, PPPOPTIONS ],
        [ auto,               \&xst_replace_sh_bool, IFCFG, ONBOOT ],
        [ user,               \&xst_replace_sh_bool, IFCFG, USERCTL ],
        [ set_default_gw,     \&xst_replace_sh_bool, IFCFG, DEFROUTE ],
        [ debug,              \&xst_replace_sh_bool, IFCFG, DEBUG ],
        [ persist,            \&xst_replace_sh_bool, IFCFG, PERSIST ],
        [ serial_escapechars, \&xst_replace_sh_bool, IFCFG, ESCAPECHARS ],
        [ serial_defabort,    \&xst_replace_sh_bool, IFCFG, DEFABORT ],
        [ serial_hwctl,       \&xst_replace_sh_bool, IFCFG, HARDFLOWCTL ],
        [ phone_number,       \&xst_replace_chat,    CHAT,  "^atd[^0-9]*([0-9, -]+)" ]
      ]
    }
  );
  
  my $dist = $dist_map{$be_dist};
  return %{$dist_tables{$dist}} if $dist;

  # FIXME: This is a fatal error, and should make us bail.
  return undef;
}

1;
