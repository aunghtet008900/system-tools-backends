#!/usr/bin/env perl
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-

# Common stuff for the ximian-setup-tools backends.
#
# Copyright (C) 2000-2001 Ximian, Inc.
#
# Authors: Hans Petter Jansson <hpj@ximian.com>
#          Arturo Espinosa <arturo@ximian.com>
#          Michael Vogt <mvo@debian.org> - Debian 2.[2|3] support.
#          David Lee Ludwig <davidl@wpi.edu> - Debian 2.[2|3] support.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

use Socket;


$SCRIPTSDIR = "$SCRIPTSDIR";
if ($SCRIPTSDIR =~ /^___scriptsdir__[_]/)
{
    $SCRIPTSDIR = ".";
    $DOTIN = ".in";
}

require "$SCRIPTSDIR/general.pl$DOTIN";
require "$SCRIPTSDIR/file.pl$DOTIN";
require "$SCRIPTSDIR/parse.pl$DOTIN";
require "$SCRIPTSDIR/replace.pl$DOTIN";
require "$SCRIPTSDIR/service.pl$DOTIN";
require "$SCRIPTSDIR/util.pl$DOTIN";
require "$SCRIPTSDIR/xml.pl$DOTIN";

# Parse <interface>...</interface>. Put here so it can be shared with internetsharing.
sub xst_network_xml_parse_interface
{
  my $tree = $_[0];
  my $interface = $_[1];
  my %hash;
  my $dev;

  shift @$tree;
  
  while (@$tree)
  {
    $hash{$$tree[0]} = &xst_xml_get_pcdata ($$tree[1]);

    shift @$tree;
    shift @$tree;
  }

  $hash{"file"} = &xst_network_get_file ($hash{"dev"}) if !exists $hash{"file"};
  $dev = $hash{"file"};
  $$interface{$dev} = \%hash;
}

# Expects something like "132.248.10.2" and returns 4 bytes.
sub xst_network_ipv4_str2vec
{
  my ($str) = @_;

  return pack ('C4', split ('\.', $str));
}

# Converse
sub xst_network_ipv4_vec2str
{
  my ($vec) = @_;

  return join ('.', unpack ('C4', $vec));
}

# Gets the subnet, in bitmap.
sub xst_network_ipv4_calc_subnet_vec
{
  my ($addr, $mask) = @_;
  my ($addrvec, $maskvec);

  $addrvec = &xst_network_ipv4_str2vec ($addr);
  $maskvec = &xst_network_ipv4_str2vec ($mask);

  return $addrvec & $maskvec;
}

# What you're looking for.
sub xst_network_ipv4_calc_subnet
{
  my ($addr, $mask) = @_;

  return &xst_network_ipv4_vec2str (&xst_network_ipv4_calc_subnet_vec);
}

# The broadcast, bitmap.
sub xst_network_ipv4_calc_bcast_vec
{
  my ($addr, $mask) = @_;
  
  $addrvec = &xst_network_ipv4_str2vec ($addr);
  $maskvec = &xst_network_ipv4_str2vec ($mask);

  return $addrvec | ~$maskvec;
}

# And this returning the quad-dot notation.
sub xst_network_ipv4_calc_bcast
{
  my ($addr, $mask) = @_;

  return &xst_network_ipv4_vec2str (&xst_network_ipv4_calc_bcast_vec);
}


# Selects a ping command, which must ping just twice, with
# one second interval, returning numeric IPs to the given
# broadcast address.
sub xst_network_get_broadcast_ping_cmd
{
  my ($bcast) = @_;
  my ($tool_ping);

  my %cmd_map =
      (
       "debian-2.2" => "ping -c 2 -i 1 -n $bcast",
       "redhat-6.2" => "ping -c 2 -i 1 -n -b $bcast"
       );
  my %dist_map =
      (
       "redhat-6.0"   => "redhat-6.2",
       "redhat-6.1"   => "redhat-6.2",
       "redhat-6.2"   => "redhat-6.2",
       "redhat-7.0"   => "redhat-6.2",
       "redhat-7.1"   => "redhat-6.2",
       "debian-2.2"   => "debian-2.2",
       "debian-woody" => "debian-2.2",
       "mandrake-7.1" => "debian-2.2",
       "mandrake-7.2" => "debian-2.2",
       "suse-7.0"     => "debian-2.2" # FIXME: assumed that only redhat distros use -b.
       );

  return $cmd_map{$dist_map{$xst_dist}};
}


# Run ping, taking what looks like the replying host addresses, return
# colon-sepparated (:) string. To be used with xst_process_fork.
sub xst_network_ping_broadcast_call
{
  my ($bcast) = @_;
  my ($cmd, %hosts, $fd);

  $cmd = &xst_network_get_broadcast_ping_cmd ($bcast);
  $fd = &xst_file_run_pipe_read ($cmd);
  return undef if $fd eq undef;
  while (<$fd>)
  {
    if (/([0-9.]+):?[ \t]+icmp_seq/)
    {
      # If it already exists, it is the second count, and we can return then.
      last if exists $hosts{$1};
      $hosts{$1} = 1 ;
    }
  }
  &xst_file_close ($fd);

  return join (':', keys (%hosts));
}


# Return an array of IPs of the hosts in all the adjacent local networks.
sub xst_network_find_hosts
{
  my ($iface, $ifaces, $dev, $hosts_str, @hosts, $proc, @procs);

  $ifaces = &xst_network_active_interfaces_get_info ();

  foreach $dev (keys %$ifaces)
  {
    $iface = $$ifaces{$dev};
    if (exists $$iface{"bcast"})
    {
      push @procs, &xst_process_fork (\&xst_network_ping_broadcast_call, $$iface{"bcast"});
    }
  }

  &xst_process_list_check_ready (3, \@procs);

  foreach $proc (@procs)
  {
    if ($$proc{"ready"})
    {
      sysread ($$proc{"fd"}, $hosts_str, 4096);
      push @hosts, split (':', $hosts_str);
    }
  }

  return @hosts;
}


# like, &xst_network_lookup_address_block ("132.248.10.2") returns 'dns2.unam.mx'
# but watch it: it will block until libc timeouts or a result is found. If
# nothing found, returns the address.
sub xst_network_lookup_address_block
{
  my ($addr) = @_;
  my $name;

  $name = (gethostbyaddr (&xst_network_ipv4_str2vec ($addr), AF_INET))[0];
  return $addr if length ($name) == 0;
  return $name;
}


# To be called from xst_process_fork by the child.
sub xst_network_address_lookup_call
{
  my ($addr) = @_;

  return &xst_network_lookup_address_block ($addr);
}


# Fork a lookup process for every passed address, return ref to
# array with info on every proc.
sub xst_network_lookup_address_start
{
  my (@addrs) = @_;
  my ($addr, $proc, @procs);

  # Fork a lookup for every address.
  foreach $addr (@addrs)
  {
    $proc = &xst_process_fork (\&xst_network_address_lookup_call, $addr);
    $$proc{"addr"} = $addr;
    push @procs, $proc;
  }

  return \@procs;
}

# Take a ref to a list of forked lookup processes,
# and collect the information from those ready.
sub xst_network_lookup_address_collect
{
  my ($procs) = @_;
  my ($name, @names, $proc);
  
  # For every process, if the "ready" flag is on, read info.
  # Else, populate with the given address. Then kill child and wait for it to die.
  foreach $proc (@$procs)
  {
    if ($$proc{"ready"})
    {
      sysread ($$proc{"fd"}, $name, 4096);
      push @names, $name;
    }
    else
    {
      push @names, $$proc{"addr"};
    }
    &xst_process_kill ($proc);
  }

  return @names;
}


# like, &xst_network_lookup_address (10, "132.248.10.2", "132.248.29.8") returns
# 'dns2.unam.mx', 'sphinx.nuclecu.unam.mx' after 10 seconds, in the worst case.
# If any of the given addresses is not resolved before timeout, the address will
# be returned as its name. Timeout of 0 or undef blocks.
# Timeout may be a decimal (0.5, half a second). You can split this process in
# two, so you can collect the information at the last moment, giving more time for
# the lookups to take place. Use the two functions above for this, as shown here.
sub xst_network_lookup_address
{
  my ($timeout, @addrs) = @_;
  my $procs;

  $procs = &xst_network_lookup_address_start (@addrs);
  &xst_process_list_check_ready ($timeout, $procs);
  return &xst_network_lookup_address_collect ($procs);
}


# This code is not under the portable table style because it is supposed to
# depend on wvdial.
sub xst_network_dialing_get
{
  my %vars =
      (
       "Inherits"        => "inherits",
       "Modem"           => "device",
       "Baud"            => "speed",
       "Init1"           => "init1",
       "Init2"           => "init2",
       "Phone"           => "phone",
       "Username"        => "login",
       "Password"        => "password",
       "Dial Command"    => "dialcmd",
       "SetVolume"       => "setvol",
       "Stupid mode"     => "stupid",
       "Auto Reconnect"  => "persist",
       "Force Address"   => "address",
       "Auto DNS"        => "update_dns",
       "Check Def Route" => "set_default_gw",
       "XST Device"      => "xst_dev"
       );
  my %title2type =
      (
       "Dialer (.*)" => "dialer",
       "Modem(.*)" => "modem"
       );
  
  my ($file) = @_;
  my (%ret, @sections);
  my ($i, $j, $name, $val);

  &xst_report_enter ();
  &xst_file_run ("wvdialconf $xst_prefix/$file") if (!-e "$xst_prefix/$file");
  &xst_report ("network_dialing_get");
  
  @sections = &xst_parse_ini_sections ($file);
  foreach $i (@sections)
  {
    my %hash;
    
    $hash{"type"} = "unknown";
    foreach $j (keys %title2type)
    {
      if ($i =~ /$j/)
      {
        $hash{"name"} = $1;
        $hash{"type"} = $title2type{$j};
      }
    }
    
    $ret{$hash{"name"}} = \%hash;
    
    foreach $j (keys %vars)
    {
      $val = &xst_parse_ini ($file, $i, $j);
      $hash{$vars{$j}} = $val if ($val ne undef);
    }
  }
  
  &xst_report_leave ();
  return \%ret;
}

# FIXME: this depends a lot on ifconfig's output.
sub xst_network_active_interfaces_get_info
{
  my ($dev, %ifaces, $fd);

  &xst_report_enter ();
  &xst_report ("network_iface_active_get");

  $fd = &xst_file_run_pipe_read ("ifconfig");
  return {} if $fd eq undef;
  
  while (<$fd>)
  {
    chomp;
    $dev = $1 if /^([^ \t:]+)/;
    if ($dev)
    {
      $ {$ifaces{$dev}}{"hwaddr"}  = $1 if /HWaddr[ \t]+([^ \t]+)/i;
      $ {$ifaces{$dev}}{"addr"}    = $1 if /addr:([^ \t]+)/i;
      $ {$ifaces{$dev}}{"mask"}    = $1 if /mask:([^ \t]+)/i;
      $ {$ifaces{$dev}}{"bcast"}   = $1 if /bcast:([^ \t]+)/i;
    }
  }
  &xst_file_close ($fd);

  &xst_report_leave ();
  return \%ifaces;
}


sub xst_network_active_interfaces_get
{
  my $fd;
  my @ret = ();

  &xst_report_enter ();
  &xst_report ("network_iface_active_get");

  $fd = &xst_file_run_pipe_read ("ifconfig");
  return undef if $fd eq undef;
  
  while (<$fd>)
  {
    chomp;
    s/:? .*//;
    next if /^$/;
    push @ret, $_;
  }

  &xst_file_close ($fd);

  &xst_report_leave ();
  return @ret;
}

sub xst_network_suse70_active_interfaces_get
{
  my (@devs, $dev, @ret, $num);

  @devs = &xst_network_active_interfaces_get ();

  foreach $dev (@devs)
  {
    if ($dev ne "lo")
    {
      $num = &xst_network_suse70_parse_iface_num ("$xst_prefix/etc/rc.config", $dev);
      push @ret, $num if $num != -1;
    }
  }

  return @ret;
}
  
sub xst_network_interface_active
{
  my ($search_iface, $proc) = @_;
  my @ifaces;

  &xst_report_enter ();
  &xst_report ("network_iface_is_active", $search_iface);
  
  @ifaces = &$proc ();
  while ($ifaces[0] ne "")
  {
    return 1 if (shift (@ifaces) eq $search_iface);
  }

  &xst_report_leave ();
  return 0;
}

sub xst_network_interface_ensure_broadcast_and_network
{
  my ($iface) = @_;
    
  if (exists $$iface{"netmask"} &&
      exists $$iface{"address"})
  {
    if (! exists $$iface{"broadcast"})
    {
      $$iface{"broadcast"} = &xst_network_ipv4_calc_bcast ($$iface{"address"}, $$iface{"netmask"});
    }

    if (! exists $$iface{"network"})
    {
      $$iface{"network"} = &xst_network_ipv4_calc_subnet ($$iface{"address"}, $$iface{"netmask"});
    }
  }
}

sub xst_network_sysconfig_ifaces_get_existing
{
  local *IFACE_DIR;
  my (@ret, $i, $name);
  
  if (opendir IFACE_DIR, "$xst_prefix/etc/sysconfig/network-scripts")
  {
    foreach $i (readdir (IFACE_DIR))
    {
      if ($i =~ /^ifcfg-[a-z0-9]+$/)
      {
        $name = $i;
        $name =~ s/ifcfg-//;
        push @ret, $name;
      }
    }

    closedir (IFACE_DIR);
  }

  return @ret;
}

sub xst_network_debian_ifaces_get_existing
{
  my (@ret, @stanzas, $stanza);
  
  @stanzas = &xst_parse_interfaces_stanzas ("$xst_prefix/etc/network/interfaces", "iface");

  foreach $stanza (@stanzas)
  {
    if ($$stanza[1] eq "inet")
    {
      push @ret, $$stanza[0];
    }
  }

  return @ret;
}

sub xst_network_suse70_ifaces_get_existing
{
  my $file = "$xst_prefix/etc/rc.config";
  my ($i, $dev, @ret, $fd);

  $fd = &xst_file_open_read_from_names ($file);
  return @ret if !$fd;
  
  while ($i = <$fd>)
  {
    if ($i =~ /^[ \t]*NETDEV_([0-9]+)=/)
    {
      push @ret, $1 if &xst_parse_sh ($file, "NETDEV_$1") ne "";
    }
  }

  &xst_file_close ($fd);
  return @ret;
}

sub xst_network_suse70_parse_iface_num
{
  my ($file, $dev) = @_;
  my ($i, $ret);

  foreach $i (&xst_network_suse70_ifaces_get_existing ())
  {
    $ret = &xst_parse_sh ($file, "NETDEV_$i");
    return $i if $ret eq $dev;
  }

  &xst_debug_print_string ("\n\nWarning: xst_network_suse70_parse_iface_num: num for $dev not found.\n\n");
  return -1;
}

sub xst_network_suse70_parse_iface_auto
{
  my ($file, $iface, $key) = @_;
  my ($val, $i);
  
  $val = &xst_parse_sh_split ($file, $key, "[ \t]+");

  foreach $i (@$val)
  {
    return 1 if $i eq "_$iface";
  }

  return 0;
}

sub xst_network_suse70_replace_iface_auto
{
  my ($file, $iface, $key, $value) = @_;
  my ($val, $i, $found, @ret);
  
  $val = &xst_parse_sh_split ($file, $key, "[ \t]+");

  foreach $i (@$val)
  {
    $found = 1 if $i eq "_$iface";
    push @ret, $i unless ($i eq "_$iface" && !$value);
  }

  return 0 if ($found == $value);
  push @ret, "_$iface" if (!$found && $value);

  return &xst_replace_sh ($file, $key, join (" ", @ret));
}

sub xst_network_suse70_parse_iface_sh
{
  my ($file, $iface, $key) = @_;
  my ($val, $num);

  return &xst_parse_sh ($file, "${key}_$iface");
}

sub xst_network_suse70_replace_iface_sh
{
  my ($file, $iface, $key, $value) = @_;
  my ($val, $num);

  return &xst_replace_sh ($file, "${key}_$iface", $value);
}

sub xst_network_suse70_get_ifconfig_arg
{
  my ($file, $iface, $key) = @_;
  my ($val);

  $val = &xst_network_suse70_parse_iface_sh ($file, $iface, "IFCONFIG");
  $val =~ /[ \t]+$key[ \t]+([^ \t]+)/;
  return $1;
}

sub xst_network_suse70_set_ifconfig_arg
{
  my ($file, $iface, $key, $value) = @_;
  my ($val);

  $val = &xst_network_suse70_parse_iface_sh ($file, $iface, "IFCONFIG");
  
  return 0 if $val =~ /^dhcpclient$/ || $val =~ /^bootp$/;
  
  if (! ($val =~ s/([ \t]+$key[ \t]+)[^ \t]+/\1$value/))
  {
    $val =~ s/[ \t]+up$//;
    $val .= " " if $val =~ /[^ \t]$/;
    $val .= "$key $value up";
  }

  return &xst_network_suse70_replace_iface_sh ($file, $iface, "IFCONFIG", $val);
}

sub xst_network_suse70_set_ifconfig_ip
{
  my ($file, $iface, $value) = @_;

  $val = &xst_network_suse70_parse_iface_sh ($file, $iface, "IFCONFIG");
  
  return 0 if $val =~ /^dhcpclient$/ || $val =~ /^bootp$/;
  
  if (! ($val =~ s/^[0-9\.]+([ \t])/$value\1/))
  {
    $val = "$value $val";
    $val =~ s/[ \t]+/ /;
  }

  return &xst_network_suse70_replace_iface_sh ($file, $iface, "IFCONFIG", $val);
}

sub xst_network_get_new_dialing_dev
{
  my ($dial_hash, $type) = @_;
  my ($dial, $dev, $maxdev);

  $maxdev = -1;
  foreach $dial (keys %$dial_hash)
  {
    $dev = $ {$$dial_hash{$dial}}{"xst_dev"};
    if ($dev ne "")
    {
      if ($dev =~ s/^$type//)
      {
        $maxdev = $dev if $dev > $maxdev;
      }
    }
  }

  $maxdev ++;
  return "$type$maxdev";
}

sub xst_network_dial2iface
{
  my ($dial_hash, $name) = @_;
  my ($dial, %iface, $i);

  my %map = ("address"        => "address",
             "update_dns"     => "update_dns",
             "login"          => "login",
             "password"       => "password",
             "serial_port"    => "device",
             "serial_speed"   => "speed",
             "set_default_gw" => "set_default_gw",
             "persist"        => "persist",
             "phone_number"   => "phone",
             "dev"            => "xst_dev"
             );

  $dial = $$dial_hash{$name};
  if ($$dial{"xst_dev"} eq "")
  {
    $$dial{"xst_dev"} = "ppp0";
    # = &xst_network_get_new_dialing_dev ($dial_hash, "ppp");
  }
  else
  {
    $iface{"enabled"} = &xst_network_interface_active ($$dial{"xst_dev"},
                                                       \&xst_network_active_interfaces_get);
  }

  foreach $i (keys %map)
  {
    $iface{$i} = $$dial{$map{$i}} if exists $$dial{$map{$i}};
  }

  $iface{"file"} = $iface{"name"} = $iface{"wvsection"} = $name;
  $iface{"update_dns"} = 1 if ($iface{"update_dns"} eq "");
  $iface{"set_default_gw"} = 1 if ($iface{"set_default_gw"} eq "");
  
  return \%iface;
}

sub xst_network_iface2dial
{
  my ($dial_hash, $iface) = @_;
  my ($dial, $i);

  my %map = ("address"        => "address",
             "update_dns"     => "update_dns",
             "device"         => "serial_port",
             "speed"          => "serial_speed",
             "set_default_gw" => "set_default_gw",
             "persist"        => "persist",
             "xst_dev"        => "dev"
             );

  $dial = $$dial_hash{$$iface{"name"}};

  foreach $i (keys %map)
  {
    $$dial{$i} = $$iface{$map{$i}} if exists $$iface{$map{$i}};
  }

  $$dial{"type"} = "dialer";
}

sub xst_network_suse70_get_ppp
{
  my ($dial, $iface) = @_;
  my ($d);

  foreach $d (keys %$dial)
  {
    $$iface{$d} = &xst_network_dial2iface ($dial, $d);
  }

  return $iface;
}

sub xst_network_suse70_set_ppp
{
  my ($wvfile, $dial, $iface) = @_;
  my ($d, $i, @ppp_devs, $section);

  foreach $d (keys %$iface)
  {
    $i = $$iface{$d};
    if ($$i{"dev"} =~ /^ppp/)
    {
      my ($tmp, $wv, $name);
      
      push @ppp_devs, $i;
      
      # This takes care of connection name changes.
      $wv = $$i{"wvsection"};
      $name = $$i{"name"};

      if ($wv ne $name)
      {
        $tmp = $$dial{$wv};
        delete $$dial{$wv};
        $$tmp{"name"} = $name;
        $$dial{$name} = $tmp;
      }
      
      # Then merges interface with dialing.
      &xst_network_iface2dial ($dial, $i);
    }
  }

  # Delete any wvdial sections that are no longer present as ifaces.
  OUTER: foreach $d (keys %$dial)
  {
    foreach $i (@ppp_devs)
    {
      next OUTER if $$i{"name"} eq $ {$$dial{$d}}{"name"};
    }

    # Don't delete the defaults: that's not very polite.
    delete $$dial{$d} unless $ {$$dial{$d}}{"name"} eq "Defaults";
  }

  return 0;
}

sub xst_network_suse70_ppp_iface_activate
{
  my ($name, $enabled);
  my ($wvdial_dod, $tool_ifconfig, @paths);

  @paths = &xst_service_sysv_get_paths ();
  $wvdial_dod = $paths[1] . "/wvdial.dod";
  $tool_ifconfig = &xst_file_locate_tool ("ifconfig");

  if ($enabled)
  {
    &xst_debug_print_string ("\n\nifup ppp iface $name\n\n");
    print STDERR ("\n\nifup ppp iface $name\n\n");
    return -1 if &xst_file_run_bg ("$wvdial_dod start \"$name\"");
  }
  else
  {
    # Hmm... you'd  better not have more than one ppp connection active:
    # this is the only SuSE way of doing it.
    &xst_debug_print_string ("\n\nifdown ppp iface $name\n\n");
    print STDERR ("\n\nifdown ppp iface $name\n\n");
    return -1 if &xst_file_run ("$wvdial_dod stop");
  }

  return 0;
}

sub xst_network_suse70_activate_ppp
{
  my ($iface) = @_;
  my ($d, $i);

  foreach $d (keys %$iface)
  {
    $i = $$iface{$d};
    if ($$i{"dev"} =~ /^ppp/ && (! $$i{"enabled"}))
    {
      &xst_network_suse70_ppp_iface_activate ($$i{"name"}, 0);
      # deleted, so interfaces_set doesn't handle them.
      delete $$iface{$d};
    }
  }

  foreach $d (keys %$iface)
  {
    $i = $$iface{$d};
    if ($$i{"dev"} =~ /^ppp/ && $$i{"enabled"})
    {
      &xst_network_suse70_ppp_iface_activate ($$i{"name"}, 1);
      delete $$iface{$d};
    }
  }

  return 0;
}

sub xst_network_interfaces_get
{
  my (%dist_attrib, %hash, %fn, @ifaces, $iface);
  my ($dist, $value, $file, $proc);
  my ($i, $j);

  %dist_attrib = &xst_network_get_interfaces_parse_table ();
  %fn = %{$dist_attrib{"fn"}};
  $proc = $dist_attrib{"ifaces_get"};
  @ifaces = &$proc ();
  $key = 0;
  
  foreach $i (@ifaces)
  {
    foreach $j (keys (%fn))
    {
      $value = $fn{$j};
      $value =~ s/\#iface\#/$i/;
      $ {$dist_attrib{"fn"}}{$j} = $value;
    }

    $iface = &xst_parse_from_table ($dist_attrib{"fn"},
                                    $dist_attrib{"table"});
    &xst_network_interface_ensure_broadcast_and_network ($iface);
    $$iface{"file"} = $i;
    $hash{$i} = $iface;
  }

  return \%hash;
}

sub xst_network_conf_get
{
  my %dist_attrib;
  my $hash;

  %dist_attrib = &xst_network_get_parse_table ();

  $hash = &xst_parse_from_table ($dist_attrib{"fn"},
                                 $dist_attrib{"table"});
  return $hash;
}

sub xst_network_rh62_get_file
{
  my $dev = $_[0];
  my $pre;
  my $i;

  $pre = "$xst_prefix/etc/sysconfig/network-scripts/ifcfg-";
  
  return $dev if ! -e "$pre$dev";
  
  $dev =~ s/[0-9]*$//;

  $i = 0;
  $i ++ while (-e "$pre$dev$i");
  
  return "$dev$i";
}

sub xst_network_deb22_get_file
{
  my $dev = $_[0];
  
  return $dev;
}

sub xst_network_suse70_get_file
{
  my $file = "$xst_prefix/etc/rc.config";
  my ($i);

  $i = 0;
  $i ++ while (&xst_parse_sh ($file, "NETDEV_$i") ne "");
  
  return $i;
}

sub xst_network_get_file
{
  my $dev = $_[0];
  my $proc;

  my %dist_map =
	 (
	  "redhat-6.0"   => \&xst_network_rh62_get_file,
	  "redhat-6.1"   => \&xst_network_rh62_get_file,
	  "redhat-6.2"   => \&xst_network_rh62_get_file,
	  "redhat-7.0"   => \&xst_network_rh62_get_file,
	  "redhat-7.1"   => \&xst_network_rh62_get_file,
	  "mandrake-7.2" => \&xst_network_rh62_get_file,
		"mandrake-7.1" => \&xst_network_rh62_get_file,
    "debian-2.2"   => \&xst_network_deb22_get_file,
    "debian-woody" => \&xst_network_deb22_get_file,
    "suse-7.0"     => \&xst_network_suse70_get_file,
	  "turbolinux-7.0"   => \&xst_network_rh62_get_file
	  );

  $proc = $dist_map{$xst_dist};

  return &$proc ($dev) if $proc;

  # FIXME: should make us bail.
  &xst_debug_print_string ("\n\nWarning: No network_get_file proc for dist $xst_dist.\n\n");
  return undef;
}


sub xst_network_route_set_default_gw
{
  my ($gatewaydev, $gateway) = @_;
  my ($tool_route, $curr_gateway, $curr_gatewaydev, $fd);

  # Just in case. This means that no static gateway is needed.
  return if $gateway eq "";

  $fd = &xst_file_run_pipe_read ("route -n");
  while (<$fd>)
  {
    if (/^0\.0\.0\.0[ \t]+([0-9.]+) /)
    {
      $curr_gateway = $1;
      if ($gatewaydev ne "")
      {
        /([a-z0-9]+)$/;
        $curr_gatewaydev = $1;
      }
      
      last;
    }
  }
  &xst_file_close ($fd);

  if (($curr_gateway    ne $gateway) ||
      ($curr_gatewaydev ne $gatewaydev))
  {
    &xst_file_run ("route del default gw $curr_gateway");
    &xst_file_run ("route add default gw $curr_gateway $gatewaydev");
  }
}

sub xst_network_run_hostname
{
  my ($hostname) = @_;

  &xst_report_enter ();
  &xst_report ("network_hostname_set", $hostname);
  &xst_file_run ("hostname $hostname");
  &xst_report_leave ();
}

sub xst_network_dialing_get_section_name
{
  my ($dial) = @_;
  
  my %type2title =
	 (
	  "dialer" => "Dialer ",
	  "modem" => "Modem ",
	  "unknown" => ""
	  );

  return $type2title{$$dial{"type"}} . $$dial{"name"};
}

sub xst_network_dialing_set
{
  my ($file, $old_hash, $values_hash) = @_;
  my %vars =
	 (
	  "inherits"       => "Inherits",
	  "device"         => "Modem",
	  "speed"          => "Baud",
	  "init1"          => "Init1",
	  "init2"          => "Init2",
	  "phone"          => "Phone",
	  "login"          => "Username",
	  "password"       => "Password",
	  "dialcmd"        => "Dial Command",
	  "setvol"         => "SetVolume",
	  "stupid"         => "Stupid mode",
    "persist"        => "Auto Reconnect",
    "address"        => "Force Address",
    "update_dns"     => "Auto DNS",
    "set_default_gw" => "Check Def Route",
    "xst_dev"        => "XST Device"
	  );

  my (%hash, $section);
  my $ret;
  my ($i, $j);

  &xst_report_enter ();
  &xst_report ("network_dialing_set");

  # Remove those that are in old, but not in values.
  $old_hash = $$old_hash{"dialing"};
  OUTER: foreach $i (keys %$old_hash)
  {
    foreach $j (keys %$values_hash)
    {
      next OUTER if ($j eq $i) && ($ {$$values_hash{$j}}{"type"} eq $ {$$old_hash{$i}}{"type"});
    }

    $section = xst_network_dialing_get_section_name ($$old_hash{$i});
    $ret = -1 if &xst_replace_remove_ini_section ($file, $section);
  }

  # Now save the current stuff.
  foreach $i (keys %$values_hash)
  {
    %hash = %{$$values_hash{$i}};

    $section = xst_network_dialing_get_section_name (\%hash);
    delete $hash{"type"};
    delete $hash{"name"};

    foreach $j (keys %hash)
    {
      $ret = -1 if &xst_replace_ini ($file, $section, $vars{$j}, $hash{$j});
    }
  }

  &xst_report_leave ();
  return $ret;
}

# This works for all systems that have ifup/ifdown scripts.
sub xst_network_rh62_interface_activate_by_dev
{
  my ($dev, $enabled) = @_;

  &xst_report_enter ();
  
  if ($enabled)
  {
    &xst_report ("network_iface_activate", $dev);
    &xst_debug_print_string ("\n\nifup $dev\n\n");
    print STDERR ("\n\nifup $dev\n\n");
    return -1 if &xst_file_run_bg ("ifup $dev");
  }
  else
  {
    &xst_report ("network_iface_deactivate", $dev);
    &xst_debug_print_string ("\n\nifdown $dev\n\n");
    print STDERR ("\n\nifdown $dev\n\n");
    return -1 if &xst_file_run ("ifdown $dev");
  }
  
  &xst_report_leave ();

  return 0;
}

sub xst_network_rh62_interface_activate
{
  my ($hash, $old_hash, $enabled, $force) = @_;
  my $dev;

  if ($force || &xst_network_interface_changed ($hash, $old_hash))
  {
      if (exists $$hash{"file"})
      {
          $dev = $$hash{"file"};
      }
      else
      {
          $dev = $$hash{"dev"};
      }
      
      &xst_network_rh62_interface_activate_by_dev ($dev, $enabled);
  }
}

sub xst_network_suse70_interface_activate_by_dev
{
  my ($dev, $enabled) = @_;
  my ($network, @paths);

  @paths = &xst_service_sysv_get_paths ();
  $network = $paths[1] . "/network";

  &xst_report_enter ();
  
  if ($enabled)
  {
    &xst_report ("network_iface_deactivate", $hash{"dev"});
    &xst_debug_print_string ("\n\nifup $dev\n\n");
    print STDERR ("\n\nifup $dev\n\n");
    return -1 if &xst_file_run_bg ("$network start $dev");
  }
  else
  {
    &xst_report ("network_iface_activate", $hash{"dev"});
    &xst_debug_print_string ("\n\nifdown $dev\n\n");
    print STDERR ("\n\nifup $dev\n\n");
    return -1 if &xst_file_run ("$network stop $dev");
  }
  
  &xst_report_leave ();

  return 0;
}

sub xst_network_suse70_interface_activate
{
  my ($hash, $old_hash, $enabled, $force) = @_;

  if ($force || &xst_network_interface_changed ($hash, $old_hash))
  {
      &xst_network_rh62_interface_activate_by_dev ($$hash{"dev"}, $enabled);
  }
}

sub xst_network_remove_pap_entry
{
  my ($file, $login) = @_;
  my ($i, $buff);

  &xst_report_enter ();
  &xst_report ("network_remove_pap", $file, $login);
  
  $buff = &xst_file_buffer_load ($file);

  foreach $i (@$buff)
  {
    $i = "" if ($i =~ /^[ \t]*$login[ \t]/);
  }

  &xst_file_buffer_clean ($buff);
  &xst_report_leave ();
  return &xst_file_buffer_save ($buff, $file);
}

sub xst_network_rh62_interface_delete
{
  my ($old_hash) = @_;
  my $dev = $$old_hash{"file"};
  my $file = "$xst_prefix/etc/sysconfig/network-scripts/ifcfg-$dev";
  my $login;

  &xst_network_rh62_interface_activate_by_dev ($dev, 0);

  $login = $old_hash{"login"};
  if ($login ne "")
  {
    &xst_network_remove_pap_entry ("/etc/ppp/pap-secrets", $login);
    &xst_network_remove_pap_entry ("/etc/ppp/chap-secrets", $login);
  }

  unlink ($file);
}

sub xst_network_deb22_interface_delete
{
  my ($old_hash) = @_;
  my $dev = $$old_hash{"dev"};

  &xst_network_rh62_interface_activate_by_dev ($dev, 0);
  &xst_replace_interfaces_iface_stanza_delete ("$xst_prefix/etc/network/interfaces", $dev);
  
  $login = $old_hash{"login"};
  if ($login ne "")
  {
    &xst_network_remove_pap_entry ("/etc/ppp/pap-secrets", $login);
    &xst_network_remove_pap_entry ("/etc/ppp/chap-secrets", $login);
  }
}

sub xst_network_suse70_interface_delete
{
  my ($old_hash) = @_;
  my $dev = $$old_hash{"file"};
  my $file = "$xst_prefix/etc/rc.config";
  my $login;

  &xst_network_suse70_interface_activate_by_dev ($$old_hash{"dev"}, 0);

# Commented until I know what to do with ppp connections.
#  $login = $old_hash{"login"};
#  if ($login ne "")
#  {
#    &xst_network_remove_pap_entry ("/etc/ppp/pap-secrets", $login);
#    &xst_network_remove_pap_entry ("/etc/ppp/chap-secrets", $login);
#  }

  &xst_replace_sh ($file, "IPADDR_$dev", "");
  &xst_replace_sh ($file, "NETDEV_$dev", "");
  &xst_replace_sh ($file, "IFCONFIG_$dev", "");
}

sub xst_network_interface_changed
{
    my ($iface, $iface_old) = @_;
    my ($attr);
    my @attrs = qw(bootproto dev address netmask broadcast network gateway update_dns
                  dns1 dns2 mtu mru remote_address login serial_port serial_speed
                  ppp_options set_default_gw persist serial_hwctl phone_number enabled);

    return 1 if (!$iface_old);
    foreach $attr (@attrs)
    {
        next if (!exists $$iface{$attr}) && (!exists $$iface_old{$attr});
        return 1 if (exists $$iface{$attr}) != (exists $$iface_old{$attr});
        return 1 if $$iface{$attr} ne $$iface_old{$attr};
    }

    return 0;
}

sub xst_network_interfaces_down_changed
{
  my ($proc_iface_set, $old_hash, $values_hash) = @_;

  @ifaces = &xst_network_active_interfaces_get ();
  foreach $i (@ifaces)
  {
    if (&xst_network_interface_changed ($$values_hash{$i}, $$old_hash{$i}))
    {
      &$proc_iface_set ($$values_hash{$i}, $$old_hash{$i}, 0, 1);
    }
  }
}

sub xst_network_interface_set
{
  my ($dev, $values_hash, $old_hash) = @_;
  my (%dist_attrib, %fn);
  my ($proc, $i, $res);
  
  &xst_report_enter ();
  &xst_report ("network_iface_set", $dev);
  %dist_attrib = &xst_network_get_interface_replace_table ();
  $proc = $dist_attrib{"iface_set"};
  %fn = %{$dist_attrib{"fn"}};
  
  foreach $i (keys (%fn))
  {
    $value = $fn{$i};
    $value =~ s/\#iface\#/$dev/;
    $ {$dist_attrib{"fn"}}{$i} = $value;
  }
  
  $res = &xst_replace_from_table ($dist_attrib{"fn"}, $dist_attrib{"table"},
                                  $values_hash, $old_hash);
  
  # if success saving the settings for the interface, set up immediatly.
  &$proc ($values_hash, $old_hash, $$values_hash{"enabled"}, 0) if !$res;

  &xst_report_leave ();

  return $res;
}

sub xst_network_interfaces_set
{
  my ($old_hash, $values_hash) = @_; 
  my (%dist_attrib, @ifaces, %fn);
  my ($value, $proc);
  my ($i, $j);
  my ($tmp, $res);

  &xst_report_enter ();
  &xst_report ("network_ifaces_set");
  
  %dist_attrib = &xst_network_get_interface_replace_table ();
  $old_hash = $$old_hash{"interface"};

  $proc = $dist_attrib{"iface_set"};
  &xst_network_interfaces_down_changed ($proc, $old_hash, $values_hash);

  # Delete all old interfaces that are not in the hash.
  $proc = $dist_attrib{"iface_delete"};
  foreach $i (keys %$old_hash)
  {
    &$proc ($$old_hash{$i}) if !exists ($$values_hash{$i}) && exists ($$old_hash{$i});
  }

  foreach $i (keys %$values_hash)
  {
    $tmp = &xst_network_interface_set ($i, $$values_hash{$i}, $$old_hash{$i});
    $res = $tmp if !$res;
  }

  &xst_report_leave ();
  return $res;
}

sub xst_network_conf_set
{
  my $values_hash = $_[0];
  my $old_hash;
  my %dist_attrib;
  
  &xst_network_ensure_loopback ($values_hash);

  $old_hash = &xst_network_conf_get ();
  %dist_attrib = &xst_network_get_replace_table ();
  $res = &xst_replace_from_table ($dist_attrib{"fn"}, $dist_attrib{"table"},
                                  $values_hash, $old_hash);
  return $res;
}

sub xst_network_get_pap_passwd
{
  my ($file, $login) = @_;
  my (@arr, $passwd);

  $login = '"?' . $login . '"?';
  &xst_report_enter ();
  &xst_report ("network_get_pap_passwd", $login, $file);
  $arr = &xst_parse_split_first_array ($file, $login, "[ \t]+", "[ \t]+");
  $passwd = $$arr[1];
  &xst_report_leave ();

  $passwd =~ s/^\"([^\"]*)\"$/\1/;
  
  return $passwd;
}

# These functions do not honour the file nor call directives.
sub xst_network_get_ppp_options_re
{
  my ($file, $re) = @_;
  my ($fd, @res);

  &xst_report_enter ();
  &xst_report ("network_get_ppp_option", &xst_replace_regexp_to_separator ($re), $file);
  $fd = &xst_file_open_read_from_names ("$file");
  &xst_report_leave ();
  return undef if !$fd;

  while (($_ = &xst_parse_chomp_line_hash_comment ($fd)) != -1)
  {
    $_ = $$_;

    @res = /$re/;
    return $res[0] if $res[0];
  }

  return undef;
}

sub xst_network_set_ppp_options_re
{
  my ($file, $re, $value) = @_;
  my ($buff, $line, $replaced, $ret);
  my ($pre_space, $post_comment);

  &xst_report_enter ();
  &xst_report ("network_set_ppp_option", &xst_replace_regexp_to_separator ($re), $file);
  
  $buff = &xst_file_buffer_load ($file);

  foreach $line (@$buff)
  {
    $pre_space = $post_comment = "";
    chomp $line;
    $pre_space = $1 if $line =~ s/^([ \t]+)//;
    $post_comment = $1 if $line =~ s/([ \t]*\#.*)//;
    
    if ($line =~ /$re/)
    {
      $line = "$value\n";
      $replaced = 1;
      last;
    }

    $line = $pre_space . $line . $post_comment . "\n";
  }

  push @$buff, "$value\n" if !$replaced;
  
  &xst_file_buffer_clean ($buff);
  $ret = &xst_file_buffer_save ($buff, $file);
  &xst_report_leave ();
  return $ret;
}

sub xst_network_set_ppp_options_connect
{
  my ($file, $value) = @_;
  my $ret;

  &xst_report_enter ();
  &xst_report ("network_set_ppp_connect", $file);
  $ret = &xst_network_set_ppp_options_re ($file, "^connect", "connect \"/usr/bin/wvdial --chat $value\"");
  &xst_report_leave ();
  return $ret;
}

sub xst_network_get_ppp_options_unsup
{
  my ($file) = @_;
  my ($fd, $line, $res, $re);
  my @known_options = ("usepeerdns", "mtu", "mru", "user", "/dev/[^ \t]+", "[0-9]+",
                       "defaultroute", "debug", "persist", "escape", "crtscts", "connect",
                       "remotename", "hide-password", "noauth", "noipdefault", "ipparam");

  $res = "";
  &xst_report_enter ();
  &xst_report ("network_get_ppp_unsup", $file);
  $fd = &xst_file_open_read_from_names ("$file");
  &xst_report_leave ();
  return undef if !$fd;

  GET_LINE: while (($line = &xst_parse_chomp_line_hash_comment ($fd)) != -1)
  {
    $_ = $$line;
    next if /^[ \t]*$/;

    foreach $re (@known_options)
    {
      next GET_LINE if /^$re/;
    }

    $res .= "$_ ";
  }

  chop $res;

  return $res;
}

sub xst_network_set_ppp_options_unsup
{
  my ($file, $value) = @_;
  my ($buff, $line, $re, $ret);
  my ($pre_space, $post_comment);
  my @known_options = ("usepeerdns", "mtu", "mru", "user", "/dev/[^ \t]+", "[0-9]+",
                       "defaultroute", "debug", "persist", "escape", "crtscts", "connect",
                       "remotename", "hide-password", "noauth", "noipdefault", "ipparam");
  
  # The options in the last row are those that are on by default in pppd and we don't handle,
  # so we ignore them, as they are set implicitly if not specified.

  &xst_report_enter ();
  &xst_report ("network_set_ppp_unsup", $file);
  $buff = &xst_file_buffer_load ($file);

  GET_LINE: foreach $line (@$buff)
  {
    $pre_space = $post_comment = "";
    $pre_space = $1 if $line =~ s/^([ \t]+)//;
    $post_comment = $1 if $line =~ s/([ \t]*\#.*)//;

    foreach $re (@known_options)
    {
      next GET_LINE if $line =~ /^$re/;
    }
    $line = $pre_space . $post_comment;
    $line = "" if $line =~ /^[ \t]*$/;
  }
  
  $value =~ s/[ \t]+([^0-9])/\n\1/g;
  push @$buff, $value . "\n";
  
  &xst_file_buffer_clean ($buff);
  $ret = &xst_file_buffer_save ($buff, $file);
  &xst_report_leave ();
  return $ret;
}

sub xst_network_rh62_parse_bootproto
{
  my $ret;
  my %rh62_to_proto_name =
	 (
	  "bootp" => "bootp",
	  "dhcp"  => "dhcp",
	  "none"  => "none"
	  );

  $ret = &xst_parse_sh (@_);

  return $rh62_to_proto_name{$ret};
}

sub xst_network_rh62_replace_bootproto
{
  my ($file, $key, $value) = @_;
  my %proto_name_to_rh62 =
	 (
	  "bootp"    => "bootp",
	  "dhcp"     => "dhcp",
	  "none"     => "none"
	  );

  return &xst_replace_sh ($file, $key, $proto_name_to_rh62{$value});
}

sub xst_network_deb22_parse_bootproto
{
  my ($file, $iface) = @_;
  my (@stanzas, $stanza, $method, $bootproto);
  my %debian_to_proto_name =
      (
       "bootp"    => "bootp",
       "dhcp"     => "dhcp",
       "loopback" => "none",
       "ppp"      => "none",
       "static"   => "none"
       );

  &xst_report_enter ();
  @stanzas = &xst_parse_interfaces_stanzas ($file, "iface");

  foreach $stanza (@stanzas)
  {
    if (($$stanza[0] eq $iface) && ($$stanza[1] eq "inet"))
    {
      $method = $$stanza[2];
      last;
    }
  }

  if (exists $debian_to_proto_name {$method})
  {
    $bootproto = $debian_to_proto_name {$method};
  }
  else
  {
    $bootproto = "none";
    &xst_report ("network_bootproto_unsup", $method, $iface);
  }

  &xst_report_leave ();
  return $bootproto;
}

sub xst_network_deb22_replace_bootproto
{
  my ($file, $iface, $value) = @_;
  my (@stanzas, $stanza, $method, $bootproto);
  my %proto_name_to_debian =
      (
       "bootp"    => "bootp",
       "dhcp"     => "dhcp",
       "loopback" => "loopback",
       "ppp"      => "ppp",
       "none"     => "static"
       );

  my %dev_to_method = 
      (
       "lo" => "loopback",
       "ppp" => "ppp"
       );

  foreach $i (keys %dev_to_method)
  {
    $value = $dev_to_method{$i} if $iface =~ /^$i/;
  }

  return &xst_replace_interfaces_stanza_value ($file, $iface, 2, $proto_name_to_debian{$value});
}

sub xst_network_suse70_parse_bootproto
{
  my ($file, $iface) = @_;
  my ($ret, $val);
  my %suse70_to_proto_name =
	 (
	  "bootp"      => "bootp",
	  "dhcpclient" => "dhcp",
	  );

  $val = &xst_network_suse70_parse_iface_sh ($file, $iface, "IFCONFIG");
  $ret = $suse70_to_proto_name {$val};
  return $ret if $ret ne undef;
  return "none";
}

sub xst_network_suse70_replace_bootproto
{
  my ($file, $iface, $value) = @_;
  my ($ret, $val);
  my %proto_name_to_suse70 =
	 (
	  "bootp" => "bootp",
	  "dhcp"  => "dhcpclient",
    "none"  => ""
	  );

  $val = $proto_name_to_suse70{$value};
  return &xst_network_suse70_replace_iface_sh ($file, $iface, "IFCONFIG", $val);
}

sub xst_network_pump_iface_supported
{
  my ($iface) = @_;
  my ($dev);
  my @devs = qw(eth wvlan plip irlan);

  foreach $dev (@devs)
  {
    return 1 if $iface =~ /^$dev/;
  }

  return 0;
}

sub xst_network_pump_get_nodns
{
  my ($file, $iface, $bootproto) = @_;
  
  return undef if (!&xst_network_pump_iface_supported ($iface));

  return &xst_parse_pump_get_iface_kw_not ($file, $iface, "nodns");
}

sub xst_network_pump_set_nodns
{
  my ($file, $iface, $bootproto, $value) = @_;

  return 0 if $bootproto ne "dhcp";
  return 0 if (!&xst_network_pump_iface_supported ($iface));

  return &xst_replace_pump_iface_kw_not ($file, $iface, "nodns", $value);
}

sub xst_network_debian_parse_remote_address
{
  my ($file, $iface) = @_;
  my ($str, @tuples, $tuple, @res);

  &xst_report_enter ();
  &xst_report ("network_get_remote", $iface);
  
  @tuples = &xst_parse_interfaces_option_tuple ($file, $iface, "up", 1);

  &xst_report_leave ();
  
  foreach $tuple (@tuples)
  {
    @res = $$tuple[1] =~ /[ \t]+pointopoint[ \t]+([^ \t]+)/;
    return $res[0] if $res[0];
  }

  return undef;
}

sub xst_network_debian_replace_remote_address
{
  my ($file, $iface, $value) = @_;
  my ($ifconfig, $ret);
  
  &xst_report_enter ();
  &xst_report ("network_set_remote", $iface);
  
  $ifconfig = &xst_file_locate_tool ("ifconfig");

  $ret = &xst_replace_interfaces_option_str ($file, $iface, "up", "$ifconfig $iface pointopoint $value");
  &xst_report_leave ();
  return $ret;
}

sub xst_network_debian_woody_get_auto_by_stanza
{
  my ($file, $iface) = @_;
  my (@stanzas, $stanza, $i);

  @stanzas = &xst_parse_interfaces_stanzas ($file, "auto");

  foreach $stanza (@stanzas)
  {
    foreach $i (@$stanza)
    {
      return $stanza if $i eq $iface;
    }
  }

  return 0;
}

sub xst_network_debian_woody_get_auto
{
  my ($file, $iface) = @_;

  return &xst_network_debian_woody_get_auto_by_stanza ($file, $iface);
}

sub xst_network_debian_woody_set_auto
{
  my ($file, $iface, $value) = @_;
  my ($buff, $line_no, $found);

  $buff = &xst_file_buffer_load ($file);
  &xst_file_buffer_join_lines ($buff);
  $line_no = 0;

  while (($found = &xst_replace_interfaces_get_next_stanza ($buff, \$line_no, "auto")) != -1)
  {
    if ($value)
    {
      if ($$buff[$line_no] =~ /[ \t]$iface([\# \t\n])/)
      {
        return &xst_file_buffer_save ($buff, $file);
      }
    }
    else
    {
      # I'm including the hash here, although the man page says it's not supported.
      last if $$buff[$line_no] =~ s/[ \t]$iface([\# \t\n])/\1/;
    }
		
		$line_no ++;
  }

  if ($found == -1)
  {
    if ($value)
    {
      &xst_replace_interfaces_auto_stanza_create ($buff, $iface);
    }
  }
  else
  {
    if ($value)
    {
      chomp $$buff[$line_no];
      $$buff[$line_no] .= " $iface\n";
    }
    $$buff[$line_no] =~ s/auto[ \t]*$//;
  }
  
  return &xst_file_buffer_save ($buff, $file);
}

# Set dist_map for your distro to "" if you don't want
# loopback ensuring. See suse-7.0 entry for example.
sub xst_network_ensure_loopback_interface
{
  my ($interface) = @_;
  my $dev;
  my %dist_map =
	 (
    "redhat-5.2"   => "lo",
	  "redhat-6.0"   => "lo",
	  "redhat-6.1"   => "lo",
	  "redhat-6.2"   => "lo",
	  "redhat-7.0"   => "lo",
	  "redhat-7.1"   => "lo",
	  "mandrake-7.1" => "lo",
	  "mandrake-7.2" => "lo",
	  "debian-2.2"   => "lo",
    "debian-woody" => "lo",
    "suse-7.0"     => "",
	  "turbolinux-7.0"   => "lo"
	  );

  $dev = $dist_map {$xst_dist};

  return if $dev eq "";

  if (!exists $$interface{$dev})
  {
    my %iface = (
                 "auto" => 1,
                 "user" => 0,
                 "dev" => "lo",
                 "address" => "127.0.0.1",
                 "netmask" => "255.0.0.0",
                 "broadcast" => "127.255.255.255",
                 "network" => "127.0.0.0",
                 "bootproto" => "none",
                 "enabled" => 1,
                 "update_dns" => 0
                 );

    $$interface{$dev} = \%iface;
    &xst_network_interface_set ($dev, \%iface);
  }
  elsif (! $ {$$interface{$dev}}{"enabled"})
  {
    $ {$$interface{$dev}}{"enabled"} = 1;
    &xst_network_interface_set ($dev, $$interface{$dev});
  }
}

sub xst_network_statichost_add_alias
{
  my ($localhost, $alias) = @_;
  my $i;

  foreach $i (@$localhost)
  {
    return if ($i eq $alias);
  }
  
  push @$localhost, $alias;
}
  
sub xst_network_ensure_loopback_statichost
{
  my ($statichost, $hostname, $lo_ip) = @_;
  my $i;

  if (exists $$statichost{$lo_ip})
  {
    my $localhost = $$statichost{$lo_ip};
    &xst_network_statichost_add_alias ($localhost, $hostname);
    &xst_network_statichost_add_alias ($localhost, "localhost");
    &xst_network_statichost_add_alias ($localhost, "localhost.localdomain");
  }
  else
  {
    $$statichost{$lo_ip} = [ ("localhost", "localhost.localdomain", $hostname) ];
  }
}

# lo_ip is the ip for localhost (commonly 127.0.0.1).
sub xst_network_ensure_loopback
{
  my $values_hash = $_[0];
  my $lo_ip = "127.0.0.1";
  my $interface = $$values_hash{"interface"};
  my $hostname = $$values_hash{"hostname"};
  my $statichost = $$values_hash{"statichost"};

  &xst_report_enter ();
  &xst_report ("network_ensure_lo");

  &xst_network_ensure_loopback_statichost ($statichost, $hostname, $lo_ip);
  &xst_network_ensure_loopback_interface ($interface, $lo_ip);

  &xst_report_leave ();
}

sub xst_network_get_parse_table
{
  my %dist_map =
	 (
    "redhat-5.2"   => "redhat-6.2",
	  "redhat-6.0"   => "redhat-6.2",
	  "redhat-6.1"   => "redhat-6.2",
	  "redhat-6.2"   => "redhat-6.2",
	  "redhat-7.0"   => "redhat-7.0",
	  "redhat-7.1"   => "redhat-7.0",
	  "mandrake-7.1" => "redhat-6.2",
	  "mandrake-7.2" => "redhat-6.2",
    "debian-2.2"   => "debian-2.2",
    "debian-woody" => "debian-2.2",
    "suse-7.0"     => "suse-7.0",
	  "turbolinux-7.0"   => "redhat-7.0"
	  );

  my %dist_tables =
	 (
	  "redhat-6.2" =>
	  {
	    fn =>
	    {
        SYSCONFIG_NW => "/etc/sysconfig/network",
        RESOLV_CONF  => "/etc/resolv.conf",
        HOST_CONF    => "/etc/host.conf",
        HOSTS        => "/etc/hosts",
        SMB_CONF     => "/etc/smb.conf",
        WVDIAL       => "/etc/wvdial.conf"
      },
	    table =>
		   [
		    [ "hostname",      \&xst_parse_sh,                SYSCONFIG_NW, HOSTNAME ],
        [ "gateway",       \&xst_parse_sh,                SYSCONFIG_NW, GATEWAY ],
        [ "gatewaydev",    \&xst_parse_sh,                SYSCONFIG_NW, GATEWAYDEV ],
        [ "userifacectl",  \&xst_parse_trivial,           "1" ],
		    [ "nameserver",    \&xst_parse_split_all_unique_hash_comment, RESOLV_CONF,  "nameserver", "[ \t]+" ],
		    [ "searchdomain",  \&xst_parse_split_first_array_unique, RESOLV_CONF,  "search", "[ \t]+", "[ \t]+" ],
		    [ "domain",        \&xst_parse_split_first_str,   RESOLV_CONF,  "domain", "[ \t]+" ],
		    [ "order",         \&xst_parse_split_first_array, HOST_CONF,    "order", "[ \t]+", ",[ \t]*" ],
		    [ "hostmatch",     \&xst_parse_split_first_bool,  HOST_CONF,    "multi", "[ \t]+" ],
		    [ "statichost",    \&xst_parse_split_hash,        HOSTS,        "[ \t]+", "[ \t]+" ],
		    [ "workgroup",     \&xst_parse_ini,               SMB_CONF,     "global", "workgroup" ],     
		    [ "description",   \&xst_parse_ini,               SMB_CONF,     "global", "server string" ],    
		    [ "winsserver",    \&xst_parse_ini,               SMB_CONF,     "global", "wins server" ],
		    [ "winsuse",       \&xst_parse_ini_bool,          SMB_CONF,     "global", "wins support" ],
        [ "smbuse",        \&xst_service_sysv_get_status_any, "smbd", "nmbd" ],
        [ "smbinstalled",  \&xst_service_sysv_installed,  "smb" ],
        [ "smartdhcpcd",   \&xst_file_tool_installed,     "pump" ],
        [ "dialinstalled", \&xst_file_tool_installed,     "wvdial" ],
		    [ "dialing",       \&xst_network_dialing_get,     WVDIAL ],
		    [ "interface",     \&xst_network_interfaces_get ]
		    ]
			 },

	  "redhat-7.0" =>
	  {
	    fn =>
	    {
        SYSCONFIG_NW => "/etc/sysconfig/network",
        RESOLV_CONF  => "/etc/resolv.conf",
        HOST_CONF    => "/etc/host.conf",
        HOSTS        => "/etc/hosts",
        SMB_CONF     => "/etc/samba/smb.conf",
        WVDIAL       => "/etc/wvdial.conf"
      },
	    table =>
		   [
		    [ "hostname",      \&xst_parse_sh,                SYSCONFIG_NW, HOSTNAME ],
        [ "gateway",       \&xst_parse_sh,                SYSCONFIG_NW, GATEWAY ],
        [ "gatewaydev",    \&xst_parse_sh,                SYSCONFIG_NW, GATEWAYDEV ],
        [ "userifacectl",  \&xst_parse_trivial,           "1" ],
		    [ "nameserver",    \&xst_parse_split_all_unique_hash_comment, RESOLV_CONF,  "nameserver", "[ \t]+" ],
		    [ "searchdomain",  \&xst_parse_split_first_array_unique, RESOLV_CONF,  "search", "[ \t]+", "[ \t]+" ],
		    [ "domain",        \&xst_parse_split_first_str,   RESOLV_CONF,  "domain", "[ \t]+" ],
		    [ "order",         \&xst_parse_split_first_array, HOST_CONF,    "order", "[ \t]+", ",[ \t]*" ],
		    [ "hostmatch",     \&xst_parse_split_first_bool,  HOST_CONF,    "multi", "[ \t]+" ],
		    [ "statichost",    \&xst_parse_split_hash,        HOSTS,        "[ \t]+", "[ \t]+" ],
		    [ "workgroup",     \&xst_parse_ini,               SMB_CONF,     "global", "workgroup" ],     
		    [ "description",   \&xst_parse_ini,               SMB_CONF,     "global", "server string" ],    
		    [ "winsserver",    \&xst_parse_ini,               SMB_CONF,     "global", "wins server" ],
		    [ "winsuse",       \&xst_parse_ini_bool,          SMB_CONF,     "global", "wins support" ],
        [ "smbuse",        \&xst_service_sysv_get_status_any, "smbd", "nmbd" ],
        [ "smbinstalled",  \&xst_service_sysv_installed,  "smb" ],
        [ "smartdhcpcd",   \&xst_file_tool_installed,     "pump" ],
        [ "dialinstalled", \&xst_file_tool_installed,     "wvdial" ],
 		    [ "dialing",       \&xst_network_dialing_get,     WVDIAL ],
		    [ "interface",     \&xst_network_interfaces_get ]
		    ]
			 },

	  "debian-2.2" =>
	  {
	    fn =>
	    {
        OPTIONS     => "/etc/network/options",
        RESOLV_CONF => "/etc/resolv.conf",
        HOST_CONF   => "/etc/host.conf",
        HOSTS       => "/etc/hosts",
        HOSTNAME    => "/etc/hostname",
        SMB_CONF    => "/etc/samba/smb.conf",
        WVDIAL      => "/etc/wvdial.conf"
      },
	    table =>
          [
           [ "hostname",      \&xst_parse_line_first,        HOSTNAME ],
           [ "gwdevunsup",    \&xst_parse_trivial,           "1" ],
           [ "userifacectl",  \&xst_parse_trivial,           "0" ],
           [ "domain",				\&xst_parse_split_first_str,   RESOLV_CONF,  "domain", "[ \t]+" ],
           [ "nameserver",    \&xst_parse_split_all_hash_comment, RESOLV_CONF,  "nameserver", "[ \t]+" ],
           [ "searchdomain",  \&xst_parse_split_first_array, RESOLV_CONF,  "search", "[ \t]+", "[ \t]+" ],
           [ "order",         \&xst_parse_split_first_array, HOST_CONF,    "order", "[ \t]+", ",[ \t]*" ],
           [ "hostmatch",     \&xst_parse_split_first_bool,  HOST_CONF,    "multi", "[ \t]+" ],
           [ "statichost",    \&xst_parse_split_hash,        HOSTS,        "[ \t]+", "[ \t]+" ],
           [ "workgroup",     \&xst_parse_ini,               SMB_CONF,     "global", "workgroup" ],     
           [ "description",   \&xst_parse_ini,               SMB_CONF,     "global", "server string" ],    
           [ "winsserver",    \&xst_parse_ini,               SMB_CONF,     "global", "wins server" ],
           [ "winsuse",       \&xst_parse_ini_bool,          SMB_CONF,     "global", "wins support" ],
           [ "smbuse",        \&xst_service_sysv_get_status_any, "smbd", "nmbd" ],
           [ "smbinstalled",  \&xst_service_sysv_installed,  "samba" ],
           [ "smartdhcpcd",   \&xst_file_tool_installed,     "pump" ],
           [ "dialinstalled", \&xst_file_tool_installed,     "wvdial" ],
           [ "dialing",       \&xst_network_dialing_get,     WVDIAL ],
           [ "interface",     \&xst_network_interfaces_get ]
           ]
             },

	  "suse-7.0" =>
	  {
	    fn =>
	    {
        RC_CONFIG    => "/etc/rc.config",
        ROUTE_CONF   => "/etc/route.conf",
        RESOLV_CONF  => "/etc/resolv.conf",
        HOST_CONF    => "/etc/host.conf",
        HOSTS        => "/etc/hosts",
        SMB_CONF     => "/etc/smb.conf",
        WVDIAL       => "/etc/wvdial.conf"
      },
	    table =>
		   [
        [ "hostname",      \&xst_parse_sh_get_hostname,          RC_CONFIG, FQHOSTNAME ],
        [ "gateway",       \&xst_parse_split_first_str,          ROUTE_CONF, "default", "[ \t]+" ],
        [ "gateway",       \&xst_parse_split_first_str,          ROUTE_CONF, "0.0.0.0", "[ \t]+" ],
        [ "gwdevunsup",    \&xst_parse_trivial,                  "1" ],
        [ "userifacectl",  \&xst_parse_trivial,                  "0" ],
		    [ "domain",        \&xst_parse_sh_get_domain,            RC_CONFIG, FQHOSTNAME ],
		    [ "nameserver",    \&xst_parse_split_all_unique_hash_comment, RESOLV_CONF, "nameserver", "[ \t]+" ],
		    [ "searchdomain",  \&xst_parse_split_first_array_unique, RESOLV_CONF, "search", "[ \t]+", "[ \t]+" ],
# This was to take the values from SuSEConfig, but a better solution is to get
# the configuration from /etc/resolv.conf and then replace in rc.config, so those
# files stay in sync.        
#		    [ "nameserver",    \&xst_parse_sh_split,                 RC_CONFIG, NAMESERVER, "[ \t]+" ],
#		    [ "searchdomain",  \&xst_parse_sh_split,                 RC_CONFIG, SEARCHLIST, "[ \t]+" ],
		    [ "order",         \&xst_parse_split_first_array,        HOST_CONF, "order", "[ \t]+", ",[ \t]*" ],
		    [ "hostmatch",     \&xst_parse_split_first_bool,         HOST_CONF, "multi", "[ \t]+" ],
		    [ "statichost",    \&xst_parse_split_hash,               HOSTS,     "[ \t]+", "[ \t]+" ],
		    [ "workgroup",     \&xst_parse_ini,                      SMB_CONF,  "global", "workgroup" ],     
		    [ "description",   \&xst_parse_ini,                      SMB_CONF,  "global", "server string" ],    
		    [ "winsserver",    \&xst_parse_ini,                      SMB_CONF,  "global", "wins server" ],
		    [ "winsuse",       \&xst_parse_ini_bool,                 SMB_CONF,  "global", "wins support" ],
        [ "smbuse",        \&xst_service_sysv_get_status_any,    "smbd",    "nmbd" ],
        [ "smbinstalled",  \&xst_service_sysv_installed,         "smb" ],
        [ "dialinstalled", \&xst_file_tool_installed,            "wvdial" ],
		    [ "dialing",       \&xst_network_dialing_get,            WVDIAL ],
		    [ "interface_tmp", \&xst_network_interfaces_get ],
        [ "interface",     \&xst_network_suse70_get_ppp,         "%dialing%", "%interface_tmp%" ],
		    ]
			 }

	  );
  
  my $dist = $dist_map{$xst_dist};
  return %{$dist_tables{$dist}} if $dist;

  &xst_report ("platform_no_table", $xst_dist);
  return undef;
}

sub xst_network_get_interfaces_parse_table
{
  my %dist_map =
	 (
    "redhat-5.2"   => "redhat-6.2",
	  "redhat-6.0"   => "redhat-6.2",
	  "redhat-6.1"   => "redhat-6.2",
	  "redhat-6.2"   => "redhat-6.2",
	  "redhat-7.0"   => "redhat-6.2",
	  "redhat-7.1"   => "redhat-6.2",
	  "mandrake-7.1" => "redhat-6.2",
    "mandrake-7.2" => "redhat-6.2",
    "debian-2.2"   => "debian-2.2",
    "debian-woody" => "debian-woody",
    "suse-7.0"     => "suse-7.0",
	  "turbolinux-7.0"   => "redhat-6.2"
	  );
  
  my %dist_tables =
	 (
	  "redhat-6.2" =>
	  {
	    ifaces_get => \&xst_network_sysconfig_ifaces_get_existing,
	    fn =>
	    {
        IFCFG => "/etc/sysconfig/network-scripts/ifcfg-#iface#",
        CHAT  => "/etc/sysconfig/network-scripts/chat-#iface#",
        IFACE => "#iface#",
        PAP   => "/etc/ppp/pap-secrets",
        CHAP  => "/etc/ppp/chap-secrets",
        PUMP  => "/etc/pump.conf"
      },
	    table =>
          [
           [ "bootproto",          \&xst_network_rh62_parse_bootproto, IFCFG, BOOTPROTO ],
           [ "auto",               \&xst_parse_sh_bool, IFCFG, ONBOOT ],
           [ "user",               \&xst_parse_sh_bool, IFCFG, USERCTL ],
           [ "name",               \&xst_parse_sh,      IFCFG, NAME ],
           [ "dev",                \&xst_parse_sh,      IFCFG, DEVICE ],
           [ "address",            \&xst_parse_sh,      IFCFG, IPADDR ],
           [ "netmask",            \&xst_parse_sh,      IFCFG, NETMASK ],
           [ "broadcast",          \&xst_parse_sh,      IFCFG, BROADCAST ],
           [ "network",            \&xst_parse_sh,      IFCFG, NETWORK ],
           [ "gateway",            \&xst_parse_sh,      IFCFG, GATEWAY ],
           [ "update_dns",         \&xst_network_pump_get_nodns, PUMP, "%dev%", "%bootproto%" ],
           [ "update_dns",         \&xst_parse_sh_bool, IFCFG, PEERDNS ],
           [ "dns1",               \&xst_parse_sh,      IFCFG, DNS1 ],
           [ "dns2",               \&xst_parse_sh,      IFCFG, DNS2 ],
           [ "mtu",                \&xst_parse_sh,      IFCFG, MTU ],
           [ "mru",                \&xst_parse_sh,      IFCFG, MRU ],
           [ "remote_address",     \&xst_parse_sh,      IFCFG, REMIP ],
           [ "login",              \&xst_parse_sh,      IFCFG, PAPNAME ],
           [ "password",           \&xst_network_get_pap_passwd, PAP,  "%login%" ],
           [ "password",           \&xst_network_get_pap_passwd, CHAP, "%login%" ],
           [ "serial_port",        \&xst_parse_sh,      IFCFG, MODEMPORT ],
           [ "serial_speed",       \&xst_parse_sh,      IFCFG, LINESPEED ],
           [ "ppp_options",        \&xst_parse_sh,      IFCFG, PPPOPTIONS ],
           [ "wvsection",          \&xst_parse_sh,      IFCFG, WVDIALSECT ],
           [ "set_default_gw",     \&xst_parse_sh_bool, IFCFG, DEFROUTE ],
           [ "debug",              \&xst_parse_sh_bool, IFCFG, DEBUG ],
           [ "persist",            \&xst_parse_sh_bool, IFCFG, PERSIST ],
           [ "serial_escapechars", \&xst_parse_sh_bool, IFCFG, ESCAPECHARS ],
           [ "serial_hwctl",       \&xst_parse_sh_bool, IFCFG, HARDFLOWCTL ],
           [ "phone_number",       \&xst_parse_chat,    CHAT, "^atd[^0-9]*([0-9, -]+)" ],
           [ "enabled",            \&xst_network_interface_active, IFACE,
                                                                   \&xst_network_active_interfaces_get ]
           ]
             },

	  "debian-2.2" =>
	  {
	    ifaces_get => \&xst_network_debian_ifaces_get_existing,
	    fn =>
	    {
        INTERFACES  => "/etc/network/interfaces",
        IFACE       => "#iface#",
        CHAT        => "/etc/chatscripts/%wvsection%",
        PPP_OPTIONS => "/etc/ppp/peers/%wvsection%",
        PAP         => "/etc/ppp/pap-secrets",
        CHAP        => "/etc/ppp/chap-secrets",
        PUMP        => "/etc/pump.conf"
      },
	    table =>
          [
           [ "user",               \&xst_parse_trivial,                  0 ], # not supported.
           [ "dev",                \&xst_parse_trivial,                  IFACE ],
           [ "bootproto",          \&xst_network_deb22_parse_bootproto,  [INTERFACES, IFACE]],
           [ "auto",               \&xst_parse_interfaces_option_kw_not, [INTERFACES, IFACE], "noauto" ],
           [ "name",               \&xst_parse_interfaces_option_str,    [INTERFACES, IFACE], "name" ],
           [ "address",            \&xst_parse_interfaces_option_str,    [INTERFACES, IFACE], "address" ],
           [ "netmask",            \&xst_parse_interfaces_option_str,    [INTERFACES, IFACE], "netmask" ],
           [ "broadcast",          \&xst_parse_interfaces_option_str,    [INTERFACES, IFACE], "broadcast" ],
           [ "network",            \&xst_parse_interfaces_option_str,    [INTERFACES, IFACE], "network" ],
           [ "gateway",            \&xst_parse_interfaces_option_str,    [INTERFACES, IFACE], "gateway" ],
           [ "wvsection",          \&xst_parse_interfaces_option_str,    [INTERFACES, IFACE], "provider" ],
           [ "update_dns",         \&xst_network_pump_get_nodns,         PUMP, "%dev%", "%bootproto%" ],
           [ "update_dns",         \&xst_parse_kw,                       PPP_OPTIONS, "usepeerdns" ],
#           [ "dns1",               \&xst_parse_trivial,                  "" ], # not supported.
#           [ "dns2",               \&xst_parse_trivial,                  "" ], # not supported.
           [ "mtu",                \&xst_parse_split_first_str,          PPP_OPTIONS, "mtu", "[ \t]+" ],
           [ "mru",                \&xst_parse_split_first_str,          PPP_OPTIONS, "mru", "[ \t]+" ],
           [ "remote_address",     \&xst_network_debian_parse_remote_address, [INTERFACES, IFACE]],
           [ "login",              \&xst_parse_split_first_str,          PPP_OPTIONS, "user", "[ \t]+" ],
           [ "password",           \&xst_network_get_pap_passwd,         PAP, "%login%" ],
           [ "password",           \&xst_network_get_pap_passwd,         CHAP, "%login%" ],
           [ "serial_port",        \&xst_network_get_ppp_options_re,     PPP_OPTIONS, "^(/dev/[^ \t]+)" ],
           [ "serial_speed",       \&xst_network_get_ppp_options_re,     PPP_OPTIONS, "^([0-9]+)" ],
           [ "ppp_options",        \&xst_network_get_ppp_options_unsup,  PPP_OPTIONS ],
           [ "set_default_gw",     \&xst_parse_kw,                       PPP_OPTIONS, "defaultroute" ],
           [ "debug",              \&xst_parse_kw,                       PPP_OPTIONS, "debug" ],
           [ "persist",            \&xst_parse_kw,                       PPP_OPTIONS, "persist" ],
           [ "serial_escapechars", \&xst_parse_split_first_str,          PPP_OPTIONS, "escape", "[ \t]+" ],
           [ "serial_hwctl",       \&xst_parse_kw,                       PPP_OPTIONS, "crtscts" ],
           [ "phone_number",       \&xst_parse_chat,                     CHAT, "^atd[^0-9]*([0-9, -]+)" ],
           [ "enabled",            \&xst_network_interface_active,       IFACE,
                                                                       \&xst_network_active_interfaces_get ]
           ]
             },

    # Basicly the same as debian-2.2, but the "auto" option changes.
    # Other stuff may be later found to be different.
	  "debian-woody" =>
	  {
	    ifaces_get => \&xst_network_debian_ifaces_get_existing,
	    fn =>
	    {
        INTERFACES  => "/etc/network/interfaces",
        IFACE       => "#iface#",
        CHAT        => "/etc/chatscripts/%wvsection%",
        PPP_OPTIONS => "/etc/ppp/peers/%wvsection%",
        PAP         => "/etc/ppp/pap-secrets",
        CHAP        => "/etc/ppp/chap-secrets",
        PUMP        => "/etc/pump.conf"
      },
	    table =>
          [
           [ "user",               \&xst_parse_trivial,                  0 ], # not supported.
           [ "dev",                \&xst_parse_trivial,                  IFACE ],
           [ "bootproto",          \&xst_network_deb22_parse_bootproto,  [INTERFACES, IFACE]],
           [ "auto",               \&xst_network_debian_woody_get_auto,  [INTERFACES, IFACE]],
           [ "name",               \&xst_parse_interfaces_option_str,    [INTERFACES, IFACE], "name" ],
           [ "address",            \&xst_parse_interfaces_option_str,    [INTERFACES, IFACE], "address" ],
           [ "netmask",            \&xst_parse_interfaces_option_str,    [INTERFACES, IFACE], "netmask" ],
           [ "broadcast",          \&xst_parse_interfaces_option_str,    [INTERFACES, IFACE], "broadcast" ],
           [ "network",            \&xst_parse_interfaces_option_str,    [INTERFACES, IFACE], "network" ],
           [ "gateway",            \&xst_parse_interfaces_option_str,    [INTERFACES, IFACE], "gateway" ],
           [ "wvsection",          \&xst_parse_interfaces_option_str,    [INTERFACES, IFACE], "provider" ],
           [ "update_dns",         \&xst_network_pump_get_nodns,         PUMP, "%dev%", "%bootproto%" ],
           [ "update_dns",         \&xst_parse_kw,                       PPP_OPTIONS, "usepeerdns" ],
#           [ "dns1",               \&xst_parse_trivial,                  "" ], # not supported.
#           [ "dns2",               \&xst_parse_trivial,                  "" ], # not supported.
           [ "mtu",                \&xst_parse_split_first_str,          PPP_OPTIONS, "mtu", "[ \t]+" ],
           [ "mru",                \&xst_parse_split_first_str,          PPP_OPTIONS, "mru", "[ \t]+" ],
           [ "remote_address",     \&xst_network_debian_parse_remote_address, [INTERFACES, IFACE]],
           [ "login",              \&xst_parse_split_first_str,          PPP_OPTIONS, "user", "[ \t]+" ],
           [ "password",           \&xst_network_get_pap_passwd,         PAP, "%login%" ],
           [ "password",           \&xst_network_get_pap_passwd,         CHAP, "%login%" ],
           [ "serial_port",        \&xst_network_get_ppp_options_re,     PPP_OPTIONS, "^(/dev/[^ \t]+)" ],
           [ "serial_speed",       \&xst_network_get_ppp_options_re,     PPP_OPTIONS, "^([0-9]+)" ],
           [ "ppp_options",        \&xst_network_get_ppp_options_unsup,  PPP_OPTIONS ],
           [ "set_default_gw",     \&xst_parse_kw,                       PPP_OPTIONS, "defaultroute" ],
           [ "debug",              \&xst_parse_kw,                       PPP_OPTIONS, "debug" ],
           [ "persist",            \&xst_parse_kw,                       PPP_OPTIONS, "persist" ],
           [ "serial_escapechars", \&xst_parse_split_first_str,          PPP_OPTIONS, "escape", "[ \t]+" ],
           [ "serial_hwctl",       \&xst_parse_kw,                       PPP_OPTIONS, "crtscts" ],
           [ "phone_number",       \&xst_parse_chat,                     CHAT, "^atd[^0-9]*([0-9, -]+)" ],
           [ "enabled",            \&xst_network_interface_active,       IFACE,
                                                                       \&xst_network_active_interfaces_get ]
           ]
             },

	  "suse-7.0" =>
	  {
	    ifaces_get => \&xst_network_suse70_ifaces_get_existing,
	    fn =>
	    {
        IFCFG => "/etc/rc.config",
        IFACE => "#iface#"
      },
	    table =>
          [
           [ "bootproto",          \&xst_network_suse70_parse_bootproto,  [IFCFG, IFACE] ],
           [ "auto",               \&xst_network_suse70_parse_iface_auto, [IFCFG, IFACE], NETCONFIG ],
           [ "user",               \&xst_parse_trivial,                   0 ], # not supported.
           [ "name",               \&xst_network_suse70_parse_iface_sh,   [IFCFG, IFACE], XST_IFACE_NAME ],
           [ "dev",                \&xst_network_suse70_parse_iface_sh,   [IFCFG, IFACE], NETDEV ],
           [ "address",            \&xst_network_suse70_parse_iface_sh,   [IFCFG, IFACE], IPADDR ],
           [ "netmask",            \&xst_network_suse70_get_ifconfig_arg, [IFCFG, IFACE], netmask ],
           [ "broadcast",          \&xst_network_suse70_get_ifconfig_arg, [IFCFG, IFACE], broadcast ],
#          [ "network",            \&xst_parse_trivial,                   0 ], # not supported.
#          [ "gateway",            \&xst_parse_sh,      IFCFG, GATEWAY ], # not supported
           [ "remote_address",     \&xst_network_suse70_get_ifconfig_arg, [IFCFG, IFACE], pointopoint ],
           [ "enabled",            \&xst_network_interface_active,        IFACE,
                                                                \&xst_network_suse70_active_interfaces_get ]
           ]
             }
	  );
  
  my $dist = $dist_map{$xst_dist};
  return %{$dist_tables{$dist}} if $dist;

  &xst_report ("platform_no_table", $xst_dist);
  return undef;
}

sub xst_network_get_replace_table
{
  my %dist_map =
	 (
    "redhat-5.2"   => "redhat-5.2",
	  "redhat-6.0"   => "redhat-6.2",
	  "redhat-6.1"   => "redhat-6.2",
	  "redhat-6.2"   => "redhat-6.2",
	  "redhat-7.0"   => "redhat-7.0",
	  "redhat-7.1"   => "redhat-7.0",
	  "mandrake-7.1" => "redhat-6.2",
	  "mandrake-7.2" => "redhat-6.2",
    "debian-2.2"   => "debian-2.2",
    "debian-woody" => "debian-2.2",
    "suse-7.0"     => "suse-7.0",
	  "turbolinux-7.0"   => "redhat-7.0"
	  );

  my %dist_tables =
	 (
	  "redhat-6.2" =>
	  {
	    fn =>
	    {
        SYSCONFIG_NW => "/etc/sysconfig/network",
        RESOLV_CONF  => "/etc/resolv.conf",
        HOST_CONF    => "/etc/host.conf",
        HOSTS        => "/etc/hosts",
        SMB_CONF     => "/etc/smb.conf",
        WVDIAL       => "/etc/wvdial.conf"
      },
	    table =>
          [
           [ "auto",          \&xst_replace_sh_bool,          SYSCONFIG_NW, NETWORKING ],
           [ "hostname",      \&xst_replace_sh,               SYSCONFIG_NW, HOSTNAME ],
           [ "hostname",      \&xst_network_run_hostname ],
           [ "gateway",       \&xst_replace_sh,               SYSCONFIG_NW, GATEWAY],
           [ "gatewaydev",    \&xst_replace_sh,               SYSCONFIG_NW, GATEWAYDEV],
           [ "domain",        \&xst_replace_sh,               SYSCONFIG_NW, DOMAIN],
           [ "domain",        \&xst_replace_join_first_str,   RESOLV_CONF,  "domain", "[ \t]+" ],
           [ "nameserver",    \&xst_replace_join_all,         RESOLV_CONF,  "nameserver", "[ \t]+" ],
           [ "searchdomain",  \&xst_replace_join_first_array, RESOLV_CONF,  "search", "[ \t]+", "[ \t]+" ],
           [ "order",         \&xst_replace_join_first_array, HOST_CONF,    "order", "[ \t]+", ",[ \t]*" ],
           [ "hostmatch",     \&xst_replace_join_first_bool,  HOST_CONF,    "multi", "[ \t]+", "on", "off" ],
           [ "statichost",    \&xst_replace_join_hash,        HOSTS,        "[ \t]+", "[ \t]+" ],
           [ "workgroup",     \&xst_replace_ini,              SMB_CONF,     "global", "workgroup" ],     
           [ "description",   \&xst_replace_ini,              SMB_CONF,     "global", "server string" ],
           [ "winsserver",    \&xst_replace_ini,              SMB_CONF,     "global", "wins server" ],
           [ "winsuse",       \&xst_replace_ini_bool,         SMB_CONF,     "global", "wins support" ],
           [ "smbuse",        \&xst_service_sysv_set_status,  91, "smb" ],
           [ "dialing",       \&xst_network_dialing_set,      [WVDIAL, OLD_HASH] ],
           [ "interface",     \&xst_network_interfaces_set,		OLD_HASH ],
           [ "gateway",       \&xst_network_route_set_default_gw, "%gatewaydev%" ]
           ]
             },
    
	  "redhat-7.0" =>
	  {
	    fn =>
	    {
        SYSCONFIG_NW => "/etc/sysconfig/network",
        RESOLV_CONF  => "/etc/resolv.conf",
        HOST_CONF    => "/etc/host.conf",
        HOSTS        => "/etc/hosts",
        SMB_CONF     => "/etc/samba/smb.conf",
        WVDIAL       => "/etc/wvdial.conf"
      },
	    table =>
          [
           [ "auto",          \&xst_replace_sh_bool,          SYSCONFIG_NW, NETWORKING ],
           [ "hostname",      \&xst_replace_sh,               SYSCONFIG_NW, HOSTNAME ],
           [ "hostname",      \&xst_network_run_hostname ],
           [ "gateway",       \&xst_replace_sh,               SYSCONFIG_NW, GATEWAY],
           [ "gatewaydev",    \&xst_replace_sh,               SYSCONFIG_NW, GATEWAYDEV],
           [ "domain",        \&xst_replace_sh,               SYSCONFIG_NW, DOMAIN],
           [ "domain",        \&xst_replace_join_first_str,   RESOLV_CONF,  "domain", "[ \t]+" ],
           [ "nameserver",    \&xst_replace_join_all,         RESOLV_CONF,  "nameserver", "[ \t]+" ],
           [ "searchdomain",  \&xst_replace_join_first_array, RESOLV_CONF,  "search", "[ \t]+", "[ \t]+" ],
           [ "order",         \&xst_replace_join_first_array, HOST_CONF,    "order", "[ \t]+", ",[ \t]*" ],
           [ "hostmatch",     \&xst_replace_join_first_bool,  HOST_CONF,    "multi", "[ \t]+", "on", "off" ],
           [ "statichost",    \&xst_replace_join_hash,        HOSTS,        "[ \t]+", "[ \t]+" ],
           [ "workgroup",     \&xst_replace_ini,              SMB_CONF,     "global", "workgroup" ],     
           [ "description",   \&xst_replace_ini,              SMB_CONF,     "global", "server string" ],
           [ "winsserver",    \&xst_replace_ini,              SMB_CONF,     "global", "wins server" ],
           [ "winsuse",       \&xst_replace_ini_bool,         SMB_CONF,     "global", "wins support" ],
           [ "smbuse",        \&xst_service_sysv_set_status,  91, "smb" ],
           [ "dialing",       \&xst_network_dialing_set,      [WVDIAL, OLD_HASH] ],
           [ "interface",     \&xst_network_interfaces_set,		OLD_HASH ],
           [ "gateway",       \&xst_network_route_set_default_gw, "%gatewaydev%" ]
           ]
             },

	  "debian-2.2" =>
	  {
	    fn =>
	    {
        OPTIONS     => "/etc/network/options",
        RESOLV_CONF => "/etc/resolv.conf",
        HOST_CONF   => "/etc/host.conf",
        HOSTS       => "/etc/hosts",
        HOSTNAME    => "/etc/hostname",
        SMB_CONF    => "/etc/samba/smb.conf",
        WVDIAL      => "/etc/wvdial.conf"
      },
	    table =>
          [
           [ "hostname",      \&xst_replace_line_first,       HOSTNAME ],
           [ "hostname",      \&xst_network_run_hostname ],
           [ "domain",        \&xst_replace_join_first_str,   RESOLV_CONF, "domain", "[ \t]+" ],
           [ "nameserver",    \&xst_replace_join_all,         RESOLV_CONF, "nameserver", "[ \t]+" ],
           [ "searchdomain",  \&xst_replace_join_first_array, RESOLV_CONF, "search", "[ \t]+", "[ \t]+" ],
           [ "order",         \&xst_replace_join_first_array, HOST_CONF,   "order", "[ \t]+", ",[ \t]*" ],
           [ "hostmatch",     \&xst_replace_join_first_bool,  HOST_CONF,   "multi", "[ \t]+", "on", "off" ],
           [ "statichost",    \&xst_replace_join_hash,        HOSTS,       "[ \t]+", "[ \t]+" ],
           [ "workgroup",     \&xst_replace_ini,              SMB_CONF,    "global", "workgroup" ],     
           [ "description",   \&xst_replace_ini,              SMB_CONF,    "global", "server string" ],
           [ "winsserver",    \&xst_replace_ini,              SMB_CONF,    "global", "wins server" ],
           [ "winsuse",       \&xst_replace_ini_bool,         SMB_CONF,    "global", "wins support" ],
           [ "smbuse",        \&xst_service_sysv_set_status,  91, "smb" ],
           [ "dialing",       \&xst_network_dialing_set,      [WVDIAL, OLD_HASH] ],
           [ "interface",     \&xst_network_interfaces_set,		OLD_HASH ]
           ]
             },

	  "suse-7.0" =>
	  {
	    fn =>
	    {
        RC_CONFIG    => "/etc/rc.config",
        ROUTE_CONF   => "/etc/route.conf",
        RESOLV_CONF  => "/etc/resolv.conf",
        HOST_CONF    => "/etc/host.conf",
        HOSTS        => "/etc/hosts",
        SMB_CONF     => "/etc/smb.conf",
        WVDIAL       => "/etc/wvdial.conf",
        SUSECONFIG   => "SuSEconfig"
      },
	    table =>
		   [
        [ "hostname",      \&xst_replace_sh_set_hostname,  RC_CONFIG, FQHOSTNAME ],
        [ "hostname",      \&xst_network_run_hostname ],
        [ "gateway",       \&xst_replace_join_first_str,   ROUTE_CONF, "default", "[ \t]+" ],
        [ "gateway",       \&xst_replace_join_first_str,   ROUTE_CONF, "0.0.0.0", "[ \t]+" ],
		    [ "domain",        \&xst_replace_sh_set_domain,    RC_CONFIG, FQHOSTNAME ],
		    [ "nameserver",    \&xst_replace_sh_join,          RC_CONFIG, NAMESERVER, "[ \t]+" ],
		    [ "searchdomain",  \&xst_replace_sh_join,          RC_CONFIG, SEARCHLIST, "[ \t]+" ],
# Remove /etc/resolv.conf so SuSEconfig sets the new values.
        [ "searchdomain",  \&xst_file_remove,              RESOLV_CONF ],
        [ "order",         \&xst_replace_join_first_array, HOST_CONF,    "order", "[ \t]+", ",[ \t]*" ],
        [ "hostmatch",     \&xst_replace_join_first_bool,  HOST_CONF,    "multi", "[ \t]+", "on", "off" ],
        [ "statichost",    \&xst_replace_join_hash,        HOSTS,        "[ \t]+", "[ \t]+" ],
        [ "workgroup",     \&xst_replace_ini,              SMB_CONF,     "global", "workgroup" ],     
        [ "description",   \&xst_replace_ini,              SMB_CONF,     "global", "server string" ],
        [ "winsserver",    \&xst_replace_ini,              SMB_CONF,     "global", "wins server" ],
        [ "winsuse",       \&xst_replace_ini_bool,         SMB_CONF,     "global", "wins support" ],
        [ "smbuse",        \&xst_service_sysv_set_status,  20, "smb" ],
        [ "interface",     \&xst_network_suse70_set_ppp,   [WVDIAL, "%dialing%"] ],
        [ "dialing",       \&xst_network_dialing_set,      [WVDIAL, OLD_HASH] ],
# We're calling this sepparated cuz we are going to call wvdial to activate.           
        [ "interface",     \&xst_network_suse70_activate_ppp ],
        [ "interface",     \&xst_network_interfaces_set,	 OLD_HASH ],
# I use "interface" here to force the execution of SUSECONFIG.
        [ "interface",     \&xst_file_run,                 SUSECONFIG ],
		    ]
			 }
	  );
  
  my $dist = $dist_map{$xst_dist};
  return %{$dist_tables{$dist}} if $dist;

  &xst_report ("platform_no_table", $xst_dist);
  return undef;
}

sub xst_network_get_interface_replace_table
{
  my %dist_map =
	 (
    "redhat-5.2"   => "redhat-5.2",
	  "redhat-6.0"   => "redhat-6.2",
	  "redhat-6.1"   => "redhat-6.2",
	  "redhat-6.2"   => "redhat-6.2",
	  "redhat-7.0"   => "redhat-6.2",
	  "redhat-7.1"   => "redhat-6.2",
	  "mandrake-7.1" => "redhat-6.2",
    "mandrake-7.2" => "redhat-6.2",
    "debian-2.2"   => "debian-2.2",
    "debian-woody" => "debian-woody",
    "suse-7.0"     => "suse-7.0",
	  "turbolinux-7.0"   => "redhat-6.2"
	  );

  my %dist_tables =
	(
    "redhat-6.2" =>
	  {
      iface_set    => \&xst_network_rh62_interface_activate,
      iface_delete => \&xst_network_rh62_interface_delete,
      ifaces_get   => \&xst_network_sysconfig_ifaces_get_existing,
      fn =>
	    {
        IFCFG  => "/etc/sysconfig/network-scripts/ifcfg-#iface#",
        CHAT   => "/etc/sysconfig/network-scripts/chat-#iface#",
        IFACE  => "#iface#",
        WVDIAL => "/etc/wvdial.conf",
        PUMP   => "/etc/pump.conf"
      },
      table =>
       [
        [ "bootproto",          \&xst_network_rh62_replace_bootproto, IFCFG, BOOTPROTO ],
        [ "auto",               \&xst_replace_sh_bool, IFCFG, ONBOOT ],
        [ "user",               \&xst_replace_sh_bool, IFCFG, USERCTL ],
        [ "name",               \&xst_replace_sh,      IFCFG, NAME ],
        [ "dev",                \&xst_replace_sh,      IFCFG, DEVICE ],
        [ "address",            \&xst_replace_sh,      IFCFG, IPADDR ],
        [ "netmask",            \&xst_replace_sh,      IFCFG, NETMASK ],
        [ "broadcast",          \&xst_replace_sh,      IFCFG, BROADCAST ],
        [ "network",            \&xst_replace_sh,      IFCFG, NETWORK ],
        [ "gateway",            \&xst_replace_sh,      IFCFG, GATEWAY ],
        [ "update_dns",         \&xst_network_pump_set_nodns, PUMP, "%dev%", "%bootproto%" ],
        [ "update_dns",         \&xst_replace_sh_bool, IFCFG, PEERDNS ],
        [ "dns1",               \&xst_replace_sh,      IFCFG, DNS1 ],
        [ "dns2",               \&xst_replace_sh,      IFCFG, DNS2 ],
        [ "mtu",                \&xst_replace_sh,      IFCFG, MTU ],
        [ "mru",                \&xst_replace_sh,      IFCFG, MRU ],
        [ "remote_address",     \&xst_replace_sh,      IFCFG, REMIP ],
        [ "login",              \&xst_replace_sh,      IFCFG, PAPNAME ],
        [ "serial_port",        \&xst_replace_sh,      IFCFG, MODEMPORT ],
        [ "serial_speed",       \&xst_replace_sh,      IFCFG, LINESPEED ],
        [ "ppp_options",        \&xst_replace_sh,      IFCFG, PPPOPTIONS ],
        [ "wvsection",          \&xst_replace_sh,      IFCFG, WVDIALSECT ],
        [ "set_default_gw",     \&xst_replace_sh_bool, IFCFG, DEFROUTE ],
        [ "debug",              \&xst_replace_sh_bool, IFCFG, DEBUG ],
        [ "persist",            \&xst_replace_sh_bool, IFCFG, PERSIST ],
        [ "serial_escapechars", \&xst_replace_sh_bool, IFCFG, ESCAPECHARS ],
        [ "serial_hwctl",       \&xst_replace_sh_bool, IFCFG, HARDFLOWCTL ],
        [ "phone_number",       \&xst_replace_chat,    CHAT,  "^atd[^0-9]*([0-9, -]+)" ]
      ]
    },

    "debian-2.2" =>
	  {
      iface_set    => \&xst_network_rh62_interface_activate, # They use the same ifup/ifdown cmds.
      iface_delete => \&xst_network_deb22_interface_delete,
      ifaces_get   => \&xst_network_debian_ifaces_get_existing,
	    fn =>
	    {
        INTERFACES  => "/etc/network/interfaces",
        IFACE       => "#iface#",
        CHAT        => "/etc/chatscripts/%wvsection%",
        PPP_OPTIONS => "/etc/ppp/peers/%wvsection%",
        PAP         => "/etc/ppp/pap-secrets",
        CHAP        => "/etc/ppp/chap-secrets",
        PUMP        => "/etc/pump.conf"
      },
	    table =>
          [
# not sup  [ "user",               \&xst_parse_sh_bool, IFCFG, USERCTL ],
           [ "bootproto",          \&xst_network_deb22_replace_bootproto,  [INTERFACES, IFACE]],
           [ "auto",               \&xst_replace_interfaces_option_kw_not, [INTERFACES, IFACE], "noauto" ],
           [ "name",               \&xst_replace_interfaces_option_str,    [INTERFACES, IFACE], "name" ],
           [ "address",            \&xst_replace_interfaces_option_str,    [INTERFACES, IFACE], "address" ],
           [ "netmask",            \&xst_replace_interfaces_option_str,    [INTERFACES, IFACE], "netmask" ],
           [ "broadcast",          \&xst_replace_interfaces_option_str,    [INTERFACES, IFACE], "broadcast" ],
           [ "network",            \&xst_replace_interfaces_option_str,    [INTERFACES, IFACE], "network" ],
           [ "gateway",            \&xst_replace_interfaces_option_str,    [INTERFACES, IFACE], "gateway" ],
           [ "wvsection",          \&xst_replace_interfaces_option_str,    [INTERFACES, IFACE], "provider" ],
           [ "update_dns",         \&xst_network_pump_set_nodns,           PUMP, "%dev%", "%bootproto%" ],
           [ "update_dns",         \&xst_replace_kw,                       PPP_OPTIONS, "usepeerdns" ],
# not sup  [ "dns1",               \&xst_replace_sh,                       IFCFG,       DNS1 ],
# not sup  [ "dns2",               \&xst_replace_sh,                       IFCFG, DNS2 ],
           [ "mtu",                \&xst_replace_join_first_str,           PPP_OPTIONS, "mtu", "[ \t]+" ],
           [ "mru",                \&xst_replace_join_first_str,           PPP_OPTIONS, "mru", "[ \t]+" ],
           [ "remote_address",     \&xst_network_debian_replace_remote_address, [INTERFACES, IFACE]],
           [ "login",              \&xst_replace_join_first_str,           PPP_OPTIONS, "user", "[ \t]+" ],
           [ "serial_port",        \&xst_network_set_ppp_options_re,       PPP_OPTIONS, "^(/dev/[^ \t]+)" ],
           [ "serial_speed",       \&xst_network_set_ppp_options_re,       PPP_OPTIONS, "^([0-9]+)" ],
           [ "wvsection",          \&xst_network_set_ppp_options_connect,  PPP_OPTIONS ],
           [ "ppp_options",        \&xst_network_set_ppp_options_unsup,    PPP_OPTIONS ],
           [ "set_default_gw",     \&xst_replace_kw,                       PPP_OPTIONS, "defaultroute" ],
           [ "debug",              \&xst_replace_kw,                       PPP_OPTIONS, "debug" ],
           [ "persist",            \&xst_replace_kw,                       PPP_OPTIONS, "persist" ],
           [ "serial_escapechars", \&xst_replace_join_first_str,           PPP_OPTIONS, "escape", "[ \t]+" ],
           [ "serial_hwctl",       \&xst_replace_kw,                       PPP_OPTIONS, "crtscts" ],
           [ "phone_number",       \&xst_replace_chat,                     CHAT, "^atd[^0-9]*([0-9, -]+)" ],
           ]
             },

    # Basicly the same as debian-2.2, but the "auto" option changes.
    # Other stuff may be later found to be different.
    "debian-woody" =>
	  {
      iface_set    => \&xst_network_rh62_interface_activate, # They use the same ifup/ifdown cmds.
      iface_delete => \&xst_network_deb22_interface_delete,
      ifaces_get   => \&xst_network_debian_ifaces_get_existing,
	    fn =>
	    {
        INTERFACES  => "/etc/network/interfaces",
        IFACE       => "#iface#",
        CHAT        => "/etc/chatscripts/%wvsection%",
        PPP_OPTIONS => "/etc/ppp/peers/%wvsection%",
        PAP         => "/etc/ppp/pap-secrets",
        CHAP        => "/etc/ppp/chap-secrets",
        PUMP        => "/etc/pump.conf"
      },
	    table =>
          [
# not sup  [ "user",               \&xst_parse_sh_bool, IFCFG, USERCTL ],
           [ "bootproto",          \&xst_network_deb22_replace_bootproto,  [INTERFACES, IFACE]],
           [ "auto",               \&xst_network_debian_woody_set_auto,    [INTERFACES, IFACE]],
           [ "name",               \&xst_replace_interfaces_option_str,    [INTERFACES, IFACE], "name" ],
           [ "address",            \&xst_replace_interfaces_option_str,    [INTERFACES, IFACE], "address" ],
           [ "netmask",            \&xst_replace_interfaces_option_str,    [INTERFACES, IFACE], "netmask" ],
           [ "broadcast",          \&xst_replace_interfaces_option_str,    [INTERFACES, IFACE], "broadcast" ],
           [ "network",            \&xst_replace_interfaces_option_str,    [INTERFACES, IFACE], "network" ],
           [ "gateway",            \&xst_replace_interfaces_option_str,    [INTERFACES, IFACE], "gateway" ],
           [ "wvsection",          \&xst_replace_interfaces_option_str,    [INTERFACES, IFACE], "provider" ],
           [ "update_dns",         \&xst_network_pump_set_nodns,           PUMP, "%dev%", "%bootproto%" ],
           [ "update_dns",         \&xst_replace_kw,                       PPP_OPTIONS, "usepeerdns" ],
# not sup  [ "dns1",               \&xst_replace_sh,                       IFCFG,       DNS1 ],
# not sup  [ "dns2",               \&xst_replace_sh,                       IFCFG, DNS2 ],
           [ "mtu",                \&xst_replace_join_first_str,           PPP_OPTIONS, "mtu", "[ \t]+" ],
           [ "mru",                \&xst_replace_join_first_str,           PPP_OPTIONS, "mru", "[ \t]+" ],
           [ "remote_address",     \&xst_network_debian_replace_remote_address, [INTERFACES, IFACE]],
           [ "login",              \&xst_replace_join_first_str,           PPP_OPTIONS, "user", "[ \t]+" ],
           [ "serial_port",        \&xst_network_set_ppp_options_re,       PPP_OPTIONS, "^(/dev/[^ \t]+)" ],
           [ "serial_speed",       \&xst_network_set_ppp_options_re,       PPP_OPTIONS, "^([0-9]+)" ],
           [ "wvsection",          \&xst_network_set_ppp_options_connect,  PPP_OPTIONS ],
           [ "ppp_options",        \&xst_network_set_ppp_options_unsup,    PPP_OPTIONS ],
           [ "set_default_gw",     \&xst_replace_kw,                       PPP_OPTIONS, "defaultroute" ],
           [ "debug",              \&xst_replace_kw,                       PPP_OPTIONS, "debug" ],
           [ "persist",            \&xst_replace_kw,                       PPP_OPTIONS, "persist" ],
           [ "serial_escapechars", \&xst_replace_join_first_str,           PPP_OPTIONS, "escape", "[ \t]+" ],
           [ "serial_hwctl",       \&xst_replace_kw,                       PPP_OPTIONS, "crtscts" ],
           [ "phone_number",       \&xst_replace_chat,                     CHAT, "^atd[^0-9]*([0-9, -]+)" ],
           ]
             },

    "suse-7.0" =>
	  {
      iface_set    => \&xst_network_suse70_interface_activate,
      iface_delete => \&xst_network_suse70_interface_delete,
      ifaces_get   => \&xst_network_suse70_ifaces_get_existing,
      fn =>
	    {
        IFCFG       => "/etc/rc.config",
        IFACE       => "#iface#",
        PPP_OPTIONS => "/etc/ppp/options"
      },
	    table =>
          [
# bootproto has to go second for suse, as it uses the same value for bootproto and params.           
           [ "bootproto",          \&xst_network_suse70_replace_bootproto,  [IFCFG, IFACE] ],
           [ "auto",               \&xst_network_suse70_replace_iface_auto, [IFCFG, IFACE], NETCONFIG ],
           [ "dev",                \&xst_network_suse70_replace_iface_sh,   [IFCFG, IFACE], NETDEV ],
# not sup  [ "user",               \&xst_parse_trivial,                   0 ], # not supported.
           [ "name",               \&xst_network_suse70_replace_iface_sh,   [IFCFG, IFACE], XST_IFACE_NAME ],
           [ "address",            \&xst_network_suse70_replace_iface_sh,   [IFCFG, IFACE], IPADDR ],
           [ "address",            \&xst_network_suse70_set_ifconfig_ip,    [IFCFG, IFACE] ],
           [ "netmask",            \&xst_network_suse70_set_ifconfig_arg,   [IFCFG, IFACE], netmask ],
           [ "broadcast",          \&xst_network_suse70_set_ifconfig_arg,   [IFCFG, IFACE], broadcast ],
#          [ "network",            \&xst_parse_trivial,                   0 ], # not supported.
#          [ "gateway",            \&xst_parse_sh,      IFCFG, GATEWAY ], # not supported
           [ "remote_address",     \&xst_network_suse70_set_ifconfig_arg,   [IFCFG, IFACE], pointopoint ],
           [ "update_dns",         \&xst_replace_kw,                        PPP_OPTIONS, "usepeerdns" ]
      ]
    }
  );
  
  my $dist = $dist_map{$xst_dist};
  return %{$dist_tables{$dist}} if $dist;

  &xst_report ("platform_no_table", $xst_dist);
  return undef;
}

1;
