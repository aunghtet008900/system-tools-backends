#!/usr/bin/env perl
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-

# Common stuff for the ximian-setup-tools backends.
#
# Copyright (C) 2000-2001 Ximian, Inc.
#
# Authors: Arturo Espinosa <arturo@ximian.com>,
#          Tambet Ingo <tambet@ximian.com>.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.


$SCRIPTSDIR = "___scriptsdir___";
if ($SCRIPTSDIR =~ /^___scriptsdir__[_]/)
{
    $SCRIPTSDIR = ".";
    $DOTIN = ".in";
}

require "$SCRIPTSDIR/file.pl$DOTIN";

use File::Copy;
use File::Basename;
use IO::File;
use English;

my $XST_FONT_DIR = "/usr/share/fonts/xst";



# This code is some experimental stuff that may be useful on the future.
# Commented due to the dependency to the TTF perl module.i
if (0)
{

# use Font::TTF::Font;

sub regexp_cmp_foreach
{
  my ($map, $value) = @_;
  my ($key);
  
  foreach $key (keys %$map)
  {
    return $$map{$key} if $value =~ /$key/i;
  }

  return undef;
}

# Heuristics to deduct the foundry from a copyright notice.
sub xst_font_info_get_foundry_from_notice
{
  my ($notice) = @_;
  my ($ret);
  
  # Maps from a person (company of physical person) to a foundry.
  my %map =
	 ("hershey"               => "hershey",
    
    # Some of these taken from the X Registry: http://ftp.x.org/pub/DOCS/registry
    "copyright.*acorn"      => "acorn",
    "copyright.*adobe"      => "adobe",
    " aix "                 => "aix", # This is IBM, but maybe we'll determine aix foundry this way.
    "copyright.*apple"      => "apple",
    "copyright.*bigelow.*holmes" => "b&h",
    "copyright.*bitstream"  => "bitstream",
    "copyright.*cognition"  => "cognition",
    "copyright.*cronyx"     => "cronyx",
    "copyright.*fujitsu"    => "fujitsu",
    "copyright.*fuji xerox" => "fujixerox",
    "copyright.*ipsys"      => "ipsys",
    "copyright.*metheus"    => "metheus",
    "copyright.*misc"       => "misc",
    "copyright.*monotype"   => "monotype",
    "copyright.*omron"      => "omron",
    "copyright.*panasonic"  => "panasonic",
    "copyright.*matsushita" => "panasonic",
    "copyright.*sony"       => "sony",
	  "copyright.*urw"        => "urw",
    
    "copyright.*digital equipment" => "dec",
    "copyright.*evans.*sutherland" => "eands",
    "copyright.*international business machines" => "ibm",
    "copyright.*network computing" => "ncd",
    "copyright.*sun microsystems"  => "sun",

    # Those that may give false positives go last.
    "copyright.*dec"        => "dec",
    "copyright.*ibm"        => "ibm",
    "copyright.*ncd"        => "ncd",
    "copyright.*sun"        => "sun",
	  "copyright.*microsoft"  => "microsoft"
    );

  # first aptempt: match sth like "Copyright 1987-1990 as an unpublished work by Bitstream"
  $ret = &regexp_cmp_foreach (\%map, $notice);
  return $ret if $ret ne undef;

  # Give up: use misc.
  return "misc";
}

sub xst_font_info_get_setwidth_from_label
{
  my ($label) = @_;
  my ($ret);
  
  # FIXME: find cases for "semicondensed" and others.
  my %map =
      ("narrow" => "condensed");
  

  $ret = &regexp_cmp_foreach (\%map, $label);
  return $ret if $ret ne undef;

  # The default value.
  return "normal";
}

sub xst_font_info_deduct_extras
{
  my ($info) = @_;
  
  $$info{"foundry"} = &xst_font_info_get_foundry_from_notice ($$info{"notice"});
  $$info{"setwidth"} = &xst_font_info_get_setwidth_from_label ($$info{"label"});
  $$info{"weight"} = " $$info{weight} ";
  $$info{"weight"} =~ s/[ \t]+/ /g;

  # Solve "Oblique" fonts.
  if (!$$info{"weight"} =~ / Italic /)
  {
    if ($$info{"angle"} < 0.0)
    {
      $$info{"weight"} .= "Oblique ";
    }
    elsif ($$info{"angle"} > 0.0)
    {
      $$info{"weight"} .= "ReverseOblique ";
    }
  }
}

# buff is an array with one line of text per entry.
sub xst_font_info_get_from_afm_buff
{
  my ($buff) = @_;
  my ($line, $key, $value, %info);

  my %map =
	 ("FontName"     => "name",
	  "FullName"     => "label",
	  "FamilyName"   => "family",
	  "Weight"       => "weight",
	  "IsFixedPitch" => "fixed",
	  "Notice"       => "notice",
	  "ItalicAngle"  => "angle",
    "CharacterSet" => "charset",
	  );

  foreach $line (@$buff)
  {
    ($key, $value) = split ("[ \t]+", $line, 2);
    chomp $value;
    last if $key eq "StartCharMetrics";
    $info{$map{$key}} = $value if exists $map{$key};
  }

  &xst_font_info_deduct_extras (\%info);

  return \%info;
}

sub xst_font_info_get_from_afm_str
{
  my ($str) = @_;
  my (@buff);

  @buff = split ('\n', $str);

  return &xst_font_info_get_from_afm_buff (\@buff);
}

sub xst_font_info_get_from_afm
{
  my ($file) = @_;
  local *AFM;
  my (@buff, $info);

  open AFM, $file;
  @buff = (<AFM>);
  close AFM;

  $info = &xst_font_info_get_from_afm_buff (\@buff);
  $$info{"file"} = $file;
  $$info{"file"} =~ s/.*\///;
  
  return $info;
}

sub xst_font_info_get_from_ttf2pt1
{
  my ($file) = @_;
  my ($key, $value, @buff, $info);
  my $fd;
  
  $fd = &xst_file_run_pipe_read ("ttf2pt1 -A $file -");
  @buff = <$fd>;
  &xst_file_close ($fd);

  $info = &xst_font_info_get_from_afm_buff (\@buff);
  $$info{"file"} = $file;
  $$info{"file"} =~ s/.*\///;

  return $info;
}

sub namerec_value
{
  my ($table, $idx) = @_;
  my ($ms, $apple, $uni);

  # As documented in http://fonts.apple.com/TTRefMan/RM06/Chap6name.html
  # Get the Unicode (0) value, trying any semantic.
  $uni = $ {$$table[$idx]}[0];
  if ($uni)
  {
    my $i;

    # FIXME: dunno if we are following the way the structure comes built.
    $uni = $$uni[0];
    for ($i = 0; $i < 4; $i++)
    {
      return $$uni{$i} if $$uni{$i} ne undef;
    }
  }
  
  # Get the Microsoft (3) value, western encoding (1033).
  $ms = $ {$ {$ {$$table[$idx]}[3]}[1]}{"1033"};
  return $ms if $ms ne undef;

  # Get the Apple (1) value, Roman encoding (0).
  $apple = $ {$ {$ {$$table[$idx]}[1]}[0]}{"0"};
  return $apple if $apple ne undef;
}

sub xst_font_info_get_from_ttf
{
  my ($file) = @_;
  my ($font, $t, $post, %info);

  $font = Font::TTF::Font->open($file);
  return undef if !$font;

  $post = $$font{"post"}->read;
  $t = $$font{"name"}->read;
  $t = $$t{"strings"};

  # As documented in http://fonts.apple.com/TTRefMan/RM06/Chap6name.html
  $info{"name"} = &namerec_value ($t, 6);
  $info{"label"} = &namerec_value ($t, 4);
  $info{"family"} = &namerec_value ($t, 1);
  $info{"weight"} = &namerec_value ($t, 2);
  $info{"notice"} = &namerec_value ($t, 0);
  $info{"angle"} = $$post{"italicAngle"};
  $info{"fixed"} = $$post{"isFixedPitch"}? "true": "false";
  
  $info{"file"} = $file;
  $info{"file"} =~ s/.*\///;

  &xst_font_info_deduct_extras (\%info);

  $font->DESTROY;

  return \%info;
}

sub xst_font_info_to_fontdir
{
  my ($info) = @_;
  my ($line, $i);
  my (%map);
  my ($weight, $slant, $addstyle, $pitch, $charmap);

  $i = $info;
  
  %map = (" Light "    => "light",
          " Regular "  => "regular",
          " Roman "    => "medium",
          " Normal "   => "medium",
          " Medium "   => "medium",
          " Book "     => "book",
          " DemiBold " => "demibold",
          " Demi "     => "demibold",
          " Bold "     => "bold",
          " Black "    => "black");
  $weight = &regexp_cmp_foreach (\%map, $$i{"weight"});

  %map = (" Italic "        => "i",
          " ReverseItalic " => "ri",
          " Oblique "       => "o",
          " ReverseOblique" => "ro");
  $slant = &regexp_cmp_foreach (\%map, $$i{"weight"});
  $slant = "r" if $slant eq undef;

  # No way to know addstyle for now.
  $addstyle = "";
  $pitch = ($$i{"fixed"} eq "false")? "p" : "m";
  # FIXME: no way to tell charactermap. Should use X encodings in get funcs
  # or see how ttmkfdir takes care of this.
  $charmap = "-";

  # We're using 0's because we assume we are dealing with scalable fonts.
  return "$$i{file} -$$i{foundry}-$$i{family}-$weight-$slant-$$i{setwidth}-$addstyle-0-0-0-0-$pitch-0-$charmap";
}

} # if (0)


use strict;


# XFS Config

my $xfs_boolean = {
    'parse' => \&xfs_parse_boolean,
  };

my $xfs_cardinal = {
    'parse' => \&xfs_parse_cardinal,
  };

my $xfs_string = {
    'parse' => \&xfs_parse_string,
  };

my $xfs_string_list = {
    'parse' => \&xfs_parse_string_list,
  };

my $xfs_resol_list = {
    'parse' => \&xfs_parse_string_list,
  };

my $xfs_trans_type = {
    'parse' => \&xfs_parse_string,
  };

my $xfs_table = {
    'catalogue'           => $xfs_string_list,
    'alternate-servers'   => $xfs_string_list,
    'client-limit'        => $xfs_cardinal,
    'clone-self'          => $xfs_boolean,
    'default-point-size'  => $xfs_cardinal,
    'default-resolutions' => $xfs_resol_list,
    'error-file'          => $xfs_string,
    'no-listen'           => $xfs_trans_type,
    'port'                => $xfs_cardinal,
    'use-syslog'          => $xfs_boolean,
    'deferglyphs'         => $xfs_string,
  };

# XFS boolean

sub xfs_parse_boolean
{
  my $val = shift;
  my $buf = shift;

  unless ($val eq 'on' || $val eq 'off')
  {
    # TODO: Give error;
    return;
  }

  return $val;
}


# XFS cardinal (integer)

sub xfs_parse_cardinal
{
  my $val = shift;
  my $buf = shift;

  unless ($val =~ /^\d+$/)
  {
    # TODO: Give error;
    return;
  }

  return $val;
}


# XFS string

sub xfs_parse_string
{
  my $val = shift;
  my $buf = shift;

  # TODO: Dunno what do check here
#  unless ($val =~ /^\d+$/)
#  {
    # TODO: Give error;
#    return;
#  }

  return $val;
}

# XFS string list

sub xfs_parse_string_list
{
  my $val = shift;
  my $buf = shift;
  my $last;
  my $list = [];

  while (1)
  {
    $val =~ s/\s+$//;
    $val =~ s/^\s+//;

    $last++ unless $val =~ s/,$//;
    if ($val)
    {
      my @tmp = split (/[ \t]*,[ \t]*/, $val);
      push @$list, @tmp;
    }
    else
    {
      # TODO: Give error;
      last;
    }
    shift @$buf;
    last if $last;
    $val = $$buf[0];
  }

  return $list;
}

sub xfs_parse
{
  my $fname = shift;
  $fname = $fname || '/etc/X11/fs/config';
  my $config = {};
  return unless $fname;

  my $buf = &xst_file_buffer_load ($fname);
  return unless $buf;

  while (@$buf)
  {
    my $line = shift @$buf;
    next if &xst_ignore_line ($line);

    chomp ($line);
    my ($kw, $val) = split (/[ \t]*=[ \t]*/, $line, 2);
    if (exists ($xfs_table->{$kw}))
    {
      my $func = $xfs_table->{$kw}{'parse'};
      my $val = &$func ($val, $buf);
      if ($val)
      {
        $config->{$kw} = $val;
      }
      else
      {
        # TODO: Give error;
        1;
      }
    }
    else
    {
      # TODO: report error;
      1;
    }
  }

  return $config;
}




# Check if valid ttf file.
# TODO: Improve checking.
sub font_check_ttf
{
  my $file = shift;

  if ($file =~ /\.ttf$/i || $file =~ /\.ttc/i)
  {
    return { 'type' => 'ttf' };
  }
  return;
}

# Check if valid type1 file.
# TODO: Improve checking.
sub font_check_t1
{
  my $file = shift;

  if ($file =~ /\.pfb$/i ||
      $file =~ /\.afm$/i ||
      $file =~ /\.pfa$/i ||
      $file =~ /\.pfm$/i)
  {
    return { 'type' => 't1' };
  }
  return;
}

# Check that all files exist.
sub font_check_install
{
  my $file = shift;

  if (-f $file)
  {
    my $type;

    $type = &font_check_ttf ($file);
    $type = &font_check_t1 ($file) unless $type;

    if ($type) {
      $type->{'file'} = $file;
      return $type;
    }
  }

  # TODO: add reporting.
  &xst_debug_print_line ("font_check_install: '$file' doesn't seem to be a known font file.");
  return;
}

sub font_xml_parse_install
{
  my $config = shift;
  my $xml = shift;
  my $entry = {};

  my $file = &xst_xml_get_attribute ($xml, 'file');
  unless ($file)
  {
    # TODO: add reporing.
    &xst_debug_print_line ("font_xml_parse_install: missing xml tag 'file'.");
    return;
  }

  $config->{'install'} = [] unless exists $config->{'install'};

  
  
  if (-f $file)
  {
    my $font;
    push @{$config->{'install'}}, $font if $font = &font_check_install ($file);
  }
  elsif (-d $file)
  {
    opendir (DIR, $file);
    while (defined (my $f = readdir (DIR)))
    {
      next if $f =~ /^\.+$/;
      my $font;
      push @{$config->{'install'}}, $font if $font = &font_check_install ("$file/$f");
    }
    closedir(DIR);
  }
  else
  {
    # TODO: add reporing.
    &xst_debug_print_line ("font_xml_parse_install: '$file' doesn't exist.");
  }
}

sub font_check_remove
{
  my $file = shift;
  my $fonttypes = {
    'TrueType' => 'ttf',
    'Type1'    => 't1',
    };

  foreach my $font (keys %$fonttypes)
  {
    my $path = "$XST_FONT_DIR/$font/$file";
    return { 'type' => $fonttypes->{$font}, 'file' => $path } if (-f $path);
  }
}

sub font_xml_parse_remove
{
  my $config = shift;
  my $xml = shift;
  my $entry = {};

  my $file = &xst_xml_get_attribute ($xml, 'file');
  unless ($file)
  {
    # TODO: add reporting.
    &xst_debug_print_line ("font_xml_parse_remove: missing xml tag.");
    return;
  }

  $config->{'remove'} = [] unless exists $config->{'remove'};

  if (-f $file)
  {
    my $font;
    push @{$config->{'remove'}}, $font if $font = &font_check_remove ($file);
  }
  elsif (-d $file)
  {
    opendir (DIR, $file);
    while (defined (my $f = readdir (DIR)))
    {
      next if $f =~ /^\.+$/;
      my $font;
      push @{$config->{'remove'}}, $font if $font = &font_check_remove ($f);
    }
  }
  else
  {
    # TODO: add reporting.
    &xst_debug_print_line ("font_xml_parse_remove: '$file' doesn't exist.");
  }
}

sub font_xml_parse_old
{
  my $tree = shift;
  my @known_operation = qw (install remove);

  shift @$tree;  # Skip attributes.
  my $hash = {};

  while (@$tree) {
    my $tag = shift @$tree;

    if (&xst_item_is_in_list ($tag, @known_operation))
    {
      $hash->{$tag} = [] unless exists $hash->{$tag};

      my $path = &xst_xml_get_attribute ($$tree[0], 'file');
      if ($path)
      {
        push @{$hash->{$tag}}, $path;
      }
      else
      {
        # TODO: add reporing.
        &xst_debug_print_line ("font_xml_parse_install: missing xml tag 'file'.");
      }
    }

    else
    {
      my $msg = "received unknown xml tag $$tree[0]";
      &xst_report ('xml_unexp_tag', $tag);
      &xst_debug_print_line ("font_xml_parse: $msg");
    }

    shift @$tree;
  }

  my $config = {};
  foreach my $operation (keys %$hash)
  {
    my $paths = join (" ", @{$hash->{$operation}});
    $config->{$operation} = &gp_invoke ($paths);
  }

  return $config;
}

sub font_add
{
  my $config = shift;

  return unless exists $config->{'install'};
  my @install = @{$config->{'install'}};

  foreach my $entry (@install)
  {
    my $new_file;
    for ($entry->{'format'})
    {
      /ttf/ and do
      {
        $new_file = 'TrueType';
        last;
      };

      /type1/ and do
      {
        $new_file = 'Type1';
        last;
      };

      # default
      &xst_debug_print_line ("font_add: unknown font type '$_'");
      next;
    }

    $new_file = "$XST_FONT_DIR/$new_file/";
    &xst_file_create_path ($new_file, 0777) unless (-d $new_file);

    foreach my $fname (@{$entry->{'file'}})
    {
      copy ($fname, $new_file . lc (basename ($fname)));
      &xst_report ('font_install_success', $fname);
    }
  }
}

sub font_remove
{
  my $config = shift;

  return unless exists $config->{'remove'};
  my @remove = @{$config->{'remove'}};

  foreach my $entry (@remove)
  {
    foreach my $fname (@{$entry->{'file'}})
    {
      unlink ($fname);
      &xst_report ('font_remove_success', $fname);
    }
  }
}

sub font_update_fontdir
{
  my $ttf_dir = "$XST_FONT_DIR/TrueType";
  my $t1_dir = "$XST_FONT_DIR/Type1";

  my $map = {
    $ttf_dir => {
      'ttmkfdir'  => "-d $ttf_dir -o $ttf_dir/fonts.scale",
      'mkfontdir' => "$ttf_dir",
    },
    $t1_dir => {
      'type1inst' => "-nolog -q -d $t1_dir",
    }
  };

  foreach my $type (keys %$map)
  {
    if (-d $type)
    {
      my $commands = $map->{$type};

      foreach my $key (keys %$commands)
      {
        my $cmd = &xst_file_locate_tool ($key);
        if ($cmd)
        {
          &xst_file_run ("$cmd $commands->{$key}");
          &xst_report ('font_dir_update_success', $type);
        }
        else
        {
          &xst_report ('font_dir_update_fail', $type);
          &xst_debug_print_line ("font_update_fontdir: Couldn't find '$key'");
        }
      }
    }
  }
}

sub font_install_rh
{
  # TODO: make sure xfs is running, X really uses it.

  my $cmd = &xst_file_locate_tool ('chkfontpath');
  if ($cmd)
  {
    &xst_file_run ("$cmd -q -a $XST_FONT_DIR/TrueType/");
    &xst_file_run ("$cmd -q -a $XST_FONT_DIR/Type1/");
  }

#  &xst_file_run ("/etc/rc.d/init.d/xfs restart");
}

sub font_remove_rh
{
  # TODO: make sure xfs is running, X really uses it.
  &xst_file_run ("/etc/rc.d/init.d/xfs restart");
}


my $rh_map = {
  'install' => \&font_install_rh,
  'remove'  => \&font_remove_rh,
};

my $font_distro_map = {
  'redhat-6.0' => $rh_map,
  'redhat-6.1' => $rh_map,
  'redhat-6.2' => $rh_map,
  'redhat-7.0' => $rh_map,
  'redhat-7.1' => $rh_map,
};

sub font_mungle
{
  my $config = shift;
  my $distro = shift;
  my $map;

  return unless $config || $distro;

  if (exists ($font_distro_map->{$distro}))
  {
    $map = $font_distro_map->{$distro};
  }
  return unless $map;

  my @operations = qw (install remove);
  foreach my $operation (@operations)
  {
    my $func = $map->{$operation};
    unless ($func)
    {
      # TODO: add report.
      &xst_debug_print_line ("font_mungle: ERROR!");
      next;
    }

    for ($operation)
    {
      /install/ and do
      {
        &font_add ($config);
        &font_update_fontdir ();
        &$func ($config);
        last;
      };

      /remove/ and do
      {
        &font_remove ($config);
        &$func ($config);
        &font_update_fontdir ();
        last;
      };

      # default:
      # TODO: Add report.
      &xst_debug_print_line ("font_mungle: unknown operation '$operation'.");
    }
  }
}





################################
#                              #
#         MAIN PROGRAM         #
#                              #
################################

BEGIN {
  &xst_report_table ({
    'font_install_success'    => ['info',  _('Font [%s] installed successfully.')],
    'font_install_fail'       => ['warn',  _('File [%s] not installed.')],
    'font_remove_success'     => ['info',  _('Font [%s] removed successfully.')],
    'font_dir_update_success' => ['info',  _('Font dir [%s] updated successfully.')],
    'font_dir_update_fail'    => ['warn',  _('Couldn\'t update font dir [%s].')],

    'font_list'               => ['info',  _('[%s] fonts read successfully.')],

  });
}

my $font_map = {
  'name' => [],
  'get'  => [],
  'set'  => [],
};

# Gets a hash of all fonts we currently support.
# Hash keys are name of modules, values are lists of fonts.
sub font_list
{
  my $names = $font_map->{'name'};
  my $list = $font_map->{'get'};
  my $fonts = {};

  for (my $i = 0; $i < scalar @$list; $i++)
  {
    my $func = $$list[$i];

    &xst_report ("font_list", $$names[$i]);

    my $tmp = &$func ();
    $fonts->{$$names[$i]} = $tmp if $tmp;
  }

  return $fonts;
}

# Check whether font exists in font list.
# Returns true if yes, undef if not.
sub font_exists
{
  my $font_list = shift;
  my $font = shift;

  foreach my $tmp (@$font_list)
  {
    # Maybe we should check for more things here.
    return 1 if $tmp->{'name'} eq $font->{'name'};
  }

  return;
}

# Returns a hash of all fonts.
# Unifies different systems, abstracts font systems.
sub font_get_all
{
  my $font_list = [];
  my $fonts = &font_list ();

  foreach my $system (keys %$fonts)
  {
    my $tmp_list = $fonts->{$system};

    foreach my $font (@$tmp_list)
    {
      push @$font_list, $font unless &font_exists ($font_list, $font);
    }
  }

  return $font_list;
}

#
sub font_lists_compare
{
  my $sys_fonts = shift;
  my $xml_fonts = shift;

  my $del = [];
  my $add = [];

  # Build list of removals
  for (my $i = 0; $i < scalar @$sys_fonts; $i++)
  {
    my $font = $$sys_fonts[$i];

    if (&font_exists ($xml_fonts, $font))
    {
      delete $$sys_fonts[$i];
    }
    else
    {
      push @$del, $font;
    }
  }

  # Build list of additions
  foreach my $font (@$sys_fonts)
  {
    next unless $font;
    push @$add, $font;
  }

  return ($del, $add);
}

# Copy new font files to our fonts dir.
# Pass a fontslist as single argument and modifies it's file locations.
sub font_file_copy
{
  my $add = shift;
  return unless $add;

  foreach my $font (@$add)
  {
    my $type = $font->{'format'};
    foreach my $file (@{$font->{'file'}})
    {
      my $path = $file->{'path'};
      my $new_path = "$XST_FONT_DIR/$type/";
      &xst_file_create_path ($new_path, 0755) unless (-d $new_path);
      $new_path .= lc (basename ($new_path));
      unless (-f $new_path)
      {
        copy ($path, $new_path);
        $file->{'path'} = $new_path;
      }
    }
  }
}

#
sub font_file_del
{
  my $del = shift;
  return unless $del;

  foreach my $font (@$del)
  {
    foreach my $file (@{$font->{'file'}})
    {
      unlink $file->{'path'} if (-f $file->{'path'});
    }
  }
}

#
sub font_set
{
  my $xml_fonts = shift;
  return unless $xml_fonts;
  return unless ref ($xml_fonts) eq 'ARRAY';

  my $names = $font_map->{'name'};
  my $get_functions = $font_map->{'get'};
  my $set_functions = $font_map->{'set'};

  for (my $i = 0; $i < scalar @$names; $i++)
  {
    my $get = $$get_functions[$i];
    my $set = $$set_functions[$i];

    my $sys_fonts = &$get ();
    my ($del, $add) = &font_lists_compare ($sys_fonts, $xml_fonts);
    &font_file_copy ($add);
    &$set ($del, $add);
    &font_file_del ($del);
  }
}

# Pass list of fonts, prints out XML
sub font_xml_print
{
  my $fonts = shift;

  foreach my $font (@$fonts)
  {
    &xst_xml_print_line ("<font format=\"$font->{format}\" name=\"$font->{name}\" version=\"$font->{version}\"" .
                         " familyname=\"$font->{familyname}\" speciesname=\"$font->{speciesname}\"" .
                         " psname=\"$font->{psname}\" weight=\"$font->{weight}\" italicangle=\"$font->{italicangle}\">");

    &xst_xml_enter ();
    foreach my $file (@{$font->{'file'}})
    {
      &xst_xml_print_line ("<file type=\"$file->{type}\" path=\"$file->{path}\"" .
                           " size=\"$file->{size}\" mtime=\"$file->{mtime}\"/>");
    }
    &xst_xml_leave ();
    &xst_xml_print_line ("</font>");
  }
}

# Just a dumb wrapper due to fact that we are using gnome-print's XML.
sub font_xml_parse
{
  my $fname = shift;
  my $font_list;

  $font_list = &gp_parse ($fname);
  return $font_list;
}

sub font_test
{
  my $dir = shift;
  my $fonts = [];

  $fonts = &gp_invoke ($dir, 0) if (-e $dir);

  return $fonts;
}


################################
#                              #
#           MODULES            #
#                              #
################################

# Each 'module' should register itself in their own BEGIN {} block. It should add
# a name of the module and 3 function references
# to $font_map global variable: list, install, and remove.
# List function takes no arguments and returns ref to array of fonts.
# Install function takes a ref to ARRAY containing fonts.
# Remove function takes a ref to ARRAY containing fonts.


################################
#                              #
#    Gnome-print module.       #
#                              #
################################

# Module info:
# This is THE MODULE since we use gnome-print's
# XML format to interact with frontend.

# Register.
push @{$font_map->{'name'}}, 'Gnome-print';
push @{$font_map->{'get'}}, \&gp_read_fontmaps;
push @{$font_map->{'set'}}, \&gp_font_set;


sub gp_run
{
  my $dir = shift;
  my $user = shift;
  my $set = shift;
  $user = $user ? "--user " : "--dynamic ";
  $set = $set ? "" : "--clean --target - ";

  my $command = &xst_file_locate_tool ('/home/tambet/cvs/gnome-print/installer/gnome-font-install');
  return unless $command;
  $command = "$command --debug --recursive " . $set . $user . $dir;

  open (FD, "$command 2>&1 |");
  if (FD)
  {
    my @output = (<FD>);
    close (FD);
    return \@output;
  }

  # TODO: Give error;
  return;
}

sub gp_parse_xml
{
  my $data = shift;
  my $toplevel;

  my $xml = shift @$data;
  while (@$data)
  {
    my $tag = shift @$data;
    unless ($toplevel)
    {
      $toplevel = $1 if $tag =~ /<(\S+)/;
    }

    last if $tag =~ /<\/$toplevel[ \t]+/;

    $xml .= $tag;
  }
  return &gp_parse ($xml);
}

sub gp_run_collect
{
  my $data = shift;
  my $xml;

  return unless ($data || scalar @$data < 1);

  while (@$data)
  {
    local $_ = $$data[0];

    if (/<\?xml version/) { $xml = &gp_parse_xml ($data); };
    # TODO: Add parser for all output messages and report them.

    shift @$data;
  }

  return $xml;
}

sub gp_invoke
{
  my $dir = shift || '/';
  my $set = shift;
  my $user = $UID; # Used as a boolean here, we care only for root (uid 0, false) or other (!0, true).

  my $proc = &xst_process_fork (\&gp_run, $dir, $user, $set);
  &xst_process_list_check_ready (60, $proc);
  my $list = &xst_process_result_collect ($proc, \&gp_run_collect);

  return $list;
}


# gnome-font-installer output's (XML) parser.


sub gp_parse_font
{
  my $font_list = shift;
  my $tree = shift;
  my $font;

  $font = shift @$tree;
  while (@$tree)
  {
    my $tag = shift @$tree;
    my $data = shift @$tree;

    $font->{$tag} = [] unless exists $font->{$tag};
    push @{$font->{$tag}}, $$data[0];
  }

  push @$font_list, $font;
}


sub gp_parse
{
  my $fname = shift;
  my $font_list = [];

  my $tree = &xst_xml_scan ($fname);

  unless ($$tree[0] eq 'fontmap')
  {
    # TODO: report
    &xst_debug_print_line ("gp_parse: File '$fname' doesn't seem to be fontmap file.");
    return;
  }

  $tree = $$tree[1];
  unless (&xst_xml_get_attribute ($tree, 'version') >= 2)
  {
    # TODO: report
    &xst_debug_print_line ("gp_parse: File '$fname' fontmap version should be 2.0 or higher.");
    return;
  }

  shift @$tree;
  while (@$tree)
  {
    my $tag = shift @$tree;
    unless ($tag eq 'font')
    {
      # TODO: report
      next;
    }

    &gp_parse_font ($font_list, shift @$tree);
  }

  return $font_list;
}

# Read gnome-print's fontmap files:
#  $HOME/.gnome/fonts      (user)
#  $SYSCONFDIR/gnome/fonts (dynamic)
#  $DATADIR/gnome/fonts    (static)
sub gp_read_fontmaps
{
  my $fontmap = 'gnome-print.fontmap';
  my $home = $ENV{'HOME'};
  my $prefix = '/opt'; # FIXME!
  my $sysconfdir = "$prefix/etc";
  my $datadir = "$prefix/share";

  my @dirs = ("$home/.gnome/fonts", "$sysconfdir/gnome/fonts", "$datadir/gnome/fonts");

  my @fontlist;
  foreach my $dir (@dirs)
  {
    my @files;
    push @files, "$dir/$fontmap";
    opendir(DIR, $dir);
    foreach my $file (grep { /\.fontmap$/ } readdir(DIR))
    {
      next if $file eq $fontmap;
      push @files, "$dir/$file";
    }
    closedir(DIR);

    foreach (@files)
    {
      my $font_ref = &gp_parse ($_);
      push @fontlist, @$font_ref if $font_ref;
    }
  }

  return \@fontlist;
}

sub gp_font_set
{
  my $del = shift;
  my $add = shift;
  my $font;

  foreach $font (@$del)
  {
    1;
  }

  foreach $font (@$add)
  {
    1;
  }
}



################################
#                              #
#          xfs module.         #
#                              #
################################

# Module info:
# This module is distro and version specific. Some xfs implementations (older?)
# doesn't have truetype support.

# Register.
#push @{$font_map->{'name'}}, 'xfs';
#push @{$font_map->{'get'}}, \&x_read_fonts;
#push @{$font_map->{'set'}}, \&gp_font_install;


sub xfs_get_fontpath
{
  my $cmd = &xst_file_locate_tool ('chkfontpath');
  return unless $cmd;

  my $fh = IO::File->new ("$cmd |");
  return unless $fh;

  my @output = <$fh>;
  $fh->close;

  my @fonts;
  foreach (@output)
  {
    my $path = $1 if (/^\d+: (.+)$/);
    $path =~ s/:unscaled$//;
    push @fonts, $path if $path;
  }

  return \@fonts;
}



################################
#                              #
#         XFree module.        #
#                              #
################################

# Module info:
# Depends on:
# Gnome-print module
# xfs module

# Register.
push @{$font_map->{'name'}}, 'XFree';
push @{$font_map->{'get'}}, \&x_read_fonts;
push @{$font_map->{'set'}}, \&x_font_set;


sub x_fontpath_get
{
  my $cmd = &xst_file_locate_tool ('xset');
  return unless $cmd;

  my $output = &xst_file_run_backtick ("$cmd q");
  return unless $output;

  $output = $1 if $output =~ /Font Path:\n\s+(.+)/;
  unless ($output)
  {
    &xst_debug_print_line ("x_fontpath_get: Couldn't find 'Font Path' from 'xset q' output.");
    return;
  }

  my @tmp =  split (/[ \t]*,[ \t]*/, $output);
  my $fonts = [];
  foreach (@tmp)
  {
    if (/^unix\/:/)
    {
      my $xfs_fonts = &xfs_get_fontpath ();
      push @$fonts, @$xfs_fonts;
    }
    else
    {
      push @$fonts, $_;
    }
  }

  return $fonts;
}

sub x_fontpath_add
{
  my $paths = shift || return;

  my $line = join (",", @$paths);
  &xst_file_run ("xset fp+ $line");
}

sub x_fonts_refresh
{
  &xst_file_run ("xset fp rehash");
}

sub x_fonts_dir_parse
{
  my $path = shift;
  return unless $path;
  my $file = shift || 'fonts.dir';

  my $fh = IO::File->new ("$path/$file");
  return unless $fh;

  my @fonts;
  while (<$fh>)
  {
    next if /^\d+\s+$/; # Probably the first line, showing the number of fonts.

    if (/^(\S+) (\S+)/)
    {
      push @fonts, "$path/$1";
    }
  }

  $fh->close ();
  return @fonts;
}

sub x_fonts_dir_modify
{
  my $del = shift;
  my $add = shift;
  my $path = shift;
  return unless $path;
  my $file = shift || 'fonts.dir';

  my $buf = &xst_file_buffer_load ("$path/$file");
  return unless $buf;

  # Find files which are to be removed
  my @del_files;
  foreach my $font (@$del)
  {
    foreach my $file (@{$font->{'path'}})
    {
      push @del_files, $file;
    }
  }

  for (my $i = 1; $i < scalar @$buf; $i++)
  {
    my $line = $$buf[$i];
    my ($fname, $xname) = split ('/ /', $line);

    if (&xst_item_is_in_list ($fname, @del_files))
    {
      $line = '';
      $$buf[0]--;
    }
  }

  # Add
  # FIXME: we don't have x fontname yet.

  &xst_file_buffer_save ($buf, $file);
}


sub x_get_fonts
{
  my $x_font_path = &x_fontpath_get ();
  return unless $x_font_path;

  my $x_fonts = [];
  foreach (@$x_font_path)
  {
    my @fonts = &x_fonts_dir_parse ($_);
    push @$x_fonts, @fonts;
  }

  return $x_fonts;
}

sub x_read_fonts
{
  my $x_font_paths = &x_get_fonts ();
  return unless $x_font_paths || scalar @$x_font_paths > 1;

  return &gp_invoke (join (" ", @$x_font_paths), 0);
}

# Maybe it should be common function:
# Scans font_list and returns list of different directories
# these fotns are in.
sub x_font_dirs
{
  my $font_list = shift;
  my $dirlist = [];
  my %seen = ();

  foreach my $font (@$font_list)
  {
    foreach my $file (@{$font->{'file'}})
    {
      my $item = dirname ($file->{'path'});
      push @$dirlist, $item unless $seen{$item}++; # It's a kinda magic! Oh wait, it's just perl :)
    }
  }

  return $dirlist;
}

sub x_font_set
{
  my $del = shift;
  my $add = shift;

  my @tmp = @$del;
  push @tmp, @$add;

  my $path = &x_font_dirs (\@tmp);
  &x_font_dir_modify ($del, $add, $path);

  &x_font_refresh ();
}



1;
