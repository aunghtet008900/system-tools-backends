#!/usr/bin/env perl
#-*-perl-*-
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: f; c-basic-offset: 2 -*-

# replace.pl: Common in-line replacing stuff for the ximian-setup-tools backends.
#
# Copyright (C) 2000-2001 Ximian, Inc.
#
# Authors: Hans Petter Jansson <hpj@ximian.com>
#          Arturo Espinosa <arturo@ximian.com>
#          Michael Vogt <mvo@debian.org> - Debian 2.[2|3] support.
#          David Lee Ludwig <davidl@wpi.edu> - Debian 2.[2|3] support.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

require "___scriptsdir___/be.pl";

# General rules: all replacing is in-line. Respect unsupported values, and even comments.
# Return 0 if success, and -1 for failure.

sub xst_replace_from_table
{
  my ($fn, $table) = @_;
  my ($key, $proc, @param);
  my ($i, @cp, $res, $res2);

  foreach $i (@$table)
  {
    @cp = @$i;
    $key = shift (@cp);
    $proc = shift (@cp);
    $cp[0] = $$fn{$cp[0]};
    push (@cp, $key);

    $res = -1 if &$proc (@cp);
  }

  return $res;
}

# Edit a $file, wich is assumed to have a column-based format, with $re matching field separators
# and one record per line. Search for $key, and if $arr is false, replace its value with $value,
# else all the values for $key occurrences will be substituted with an element for $value, and
# exceeding or missing $key lines will be replaced or added accordingly.
sub xst_replace_split
{
  my ($file, $key, $re, $arr, $value) = @_;
  my ($fd, @line, @res);
  my $buff;

  $buff = &be_buffer_load ($file);
  return -1 if $buff eq undef;
  
  foreach $_ (@$buff)
  {
    chomp;
    s/^[ \t]+//;
    next if (/^\#/ || /^$/);
    @line = split ($re);

    if (shift (@line) eq $key)
    {
	 if ($all) {
	   push @res, $line[0];
	 }
	 else
	 {
	   close $fd;
	   return $line[0];
	 }
    }
  }

  close $fd;
  return @res if ($all);
  return undef;
}

