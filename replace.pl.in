#!/usr/bin/env perl
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-

# replace.pl: Common in-line replacing stuff for the ximian-setup-tools backends.
#
# Copyright (C) 2000-2001 Ximian, Inc.
#
# Authors: Hans Petter Jansson <hpj@ximian.com>
#          Arturo Espinosa <arturo@ximian.com>
#          Michael Vogt <mvo@debian.org> - Debian 2.[2|3] support.
#          David Lee Ludwig <davidl@wpi.edu> - Debian 2.[2|3] support.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.


require "___scriptsdir___/util.pl";
require "___scriptsdir___/file.pl";


# General rules: all replacing is in-line. Respect unsupported values, and even comments.
# Return 0 if success, and -1 for failure.

sub xst_replace_from_table
{
  my ($fn, $table, $values_hash, $old_hash) = @_;
  my ($key, $proc, @param);
  my ($i, @cp, $res, $res2);

  $$fn{"OLD_HASH"} = $old_hash;
  
  foreach $i (@$table)
  {
    @cp = @$i;
    $key = shift (@cp);
    if (exists $$values_hash{$key})
    {
      $proc = shift (@cp);
      unshift @cp, &xst_parse_replace_files (shift (@cp), $fn);
      push (@cp, $$values_hash{$key});
	 
      &xst_debug_print_line ("xst_replace_from_table: $key");
      &xst_parse_replace_hash_values (\@cp, $values_hash);
      $res = -1 if &$proc (@cp);
    }
  }

  return $res;
}

# Wacky function that tries to create a field separator from a regular expression.
# Doesn't work with all possible regular expressions: just with the ones we are working with.
sub xst_replace_regexp_to_separator
{
  $_ = $_[0];

  s/\[([^^])([^\]])[^\]]*\]/$1/g;
  s/\+//g;
  s/\$//g;
  s/[^\*]\*//g;

  return $_;
}

sub is_array_ref
{
  my $val;

  return 1 if (ref ($val) eq "ARRAY");
  return 0 if (ref ($val) eq undef);

  &xst_debug_print_line ("Error: We shouldn't be here!");

  return 0;
}

sub set_value
{
  my ($key, $val, $re) = @_;
  
  return $key . &xst_replace_regexp_to_separator ($re) . $val;
}

# Edit a $file, wich is assumed to have a column-based format, with $re matching field separators
# and one record per line. Search for lines with the corresponding $key.
# The last arguments can be any number of standard strings.
sub xst_replace_split
{
  my ($file, $key, $re, @value) = @_;
  my ($fd, @line, @res);
  my ($buff, $i);
  my ($pre_space, $post_comment);
  my ($line_key, $val, $ret);

  &xst_report_enter ();
  &xst_report ("replace_split", $key, $file);

  $buff = &xst_file_buffer_load ($file);
  
  foreach $i (@$buff)
  {
    $pre_space = $post_comment = "";
    
    chomp $i;
    $pre_space = $1 if $i =~ s/^([ \t]+)//;
    $post_comment = $1 if $i =~ s/([ \t]*\#.*)//;
    
    if ($i ne "")
    {
      @line = split ($re, $i, 2);
      $line_key = shift (@line);
      
      # found the key?
      if ($line_key eq $key)
      {
        if ($#value < 0)
        {
          $i = "";
          next;
        }
        
        $val = shift (@value);
        $i = &set_value ($key, $val, $re);
      }
    }
    $i = $pre_space . $i . $post_comment . "\n";
  }

  foreach $i (@value)
  {
    push (@$buff, &set_value ($key, $i, $re) . "\n");
  }

  &xst_file_buffer_clean ($buff);
  $ret = &xst_file_buffer_save ($buff, $file);
  &xst_report_leave ();
  return $ret;
}

# Replace all key/values in file with those in @$value,
# deleting exceeding ones and appending those required.
sub xst_replace_join_all
{
  my ($file, $key, $re, $value) = @_;

  return &xst_replace_split ($file, $key, $re, @$value);
}

# Find first $key value and replace with $value. Append if not found.
sub xst_replace_join_first_str
{
  my ($file, $key, $re, $value) = @_;

  return &xst_replace_split ($file, $key, $re, $value);
}

# Treat value as a bool value, using val_off and val_on as corresponding
# boolean representations.
sub xst_replace_join_first_bool
{
  my ($file, $key, $re, $val_on, $val_off, $value) = @_;

  # Fixme: on and off should be a parameter.
  $value = ($value == 1)? $val_on: $val_off;
  
  return &xst_replace_split ($file, $key, $re, $value);
}

# Find first key in file, and set array join as value.
sub xst_replace_join_first_array
{
  my ($file, $key, $re1, $re2, $value) = @_;

  return &xst_replace_split ($file, $key, $re1, join (&xst_replace_regexp_to_separator ($re2), @$value));
}

# Escape value in /bin/sh way, find/append key and set escaped value.
sub xst_replace_sh
{
  my ($file, $key, $value) = @_;
  my $ret;

  $value =~ s/([\"\'\`\&\$\|\*\?\[\]\{\}\(\)<>\\])/\\$1/g;
  $value = "\"$value\"" if ($value =~ /[ \t]/);

  &xst_report_enter ();
  &xst_report ("replace_sh", $key, $file);
  $ret = &xst_replace_split ($file, $key, "[ \t]*=[ \t]*", $value);
  &xst_report_leave ();
  return $ret;
}

# Treat value as a yes/no bool, replace in shell style.
sub xst_replace_sh_bool
{
  my ($file, $key, $value) = @_;

  $value = ($value == 1)? "yes": "no";
  
  return &xst_replace_sh ($file, $key, $value);
}

# Get a fully qualified hostname from a $key shell var in $file
# and set the hostname part. e.g.: suse70's /etc/rc.config's FQHOSTNAME.
sub xst_replace_sh_set_hostname
{
  my ($file, $key, $value);
  my ($domain);

  $domain = &xst_parse_sh_get_domain ($file, $key);
  return &xst_replace_sh ($file, $key, "$value.$domain");
}

# Get a fully qualified hostname from a $key shell var in $file
# and set the domain part. e.g.: suse70's /etc/rc.config's FQHOSTNAME.
sub xst_replace_sh_set_domain
{
  my ($file, $key);
  my ($hostname);

  $hostname = &xst_parse_sh_get_hostname ($file, $key);
  return &xst_replace_sh ($file, $key, "$hostname.$value");
}

# Quick trick to set a keyword $key in $file.
sub xst_replace_kw
{
  my ($file, $key) = @_;
  my $ret;

  &xst_report_enter ();
  &xst_report ("replace_kw", $key, $file);
  $ret = &xst_replace_split ($file, $key, "\$", "");
  &xst_report_leave ();
  return $ret;
}

# The kind of $file whose $value is its first line contents.
sub xst_replace_line_first
{
  my ($file, $value) = @_;
  my $fd;

  &xst_report_enter ();
  &xst_report ("replace_line_first", $file);
  $fd = &xst_file_open_write_from_names ($file);
  &xst_report_leave ();
  return -1 if !$fd;

  print $fd $value;
  close $fd;
  
  return 0;
}

# For every key in %$value, replace/append the corresponding key/value pair.
sub xst_replace_join_hash
{
  my ($file, $re1, $re2, $value) = @_;
  my ($i, $res, $tmp, $val);

  $res = 0;
  
  foreach $i (keys (%$value))
  {
    $val = join (&xst_replace_regexp_to_separator ($re2), @{$$value{$i}});
    $tmp = &xst_replace_split ($file, $i, $re1, $val);
    $res = $tmp if !$res;
  }

  return $res;
}

# Find $re matching send string and replace parenthesyzed
# part of $re with $value. FIXME: apply meeks' more general impl.
sub xst_replace_chat
{
  my ($file, $re, $value) = @_;
  my ($buff, $i, $bak, $found, $substr, $ret);

  &xst_report_enter ();
  &xst_report ("replace_chat", $file);
  $buff = &xst_file_buffer_load ($file);

  SCAN: foreach $i (@$buff)
  {
    $bak = "";
    $found = "";
    chomp $i;

    while ($i ne "")
    {
	 # If it uses quotes. FIXME: Assuming they surround the whole string.
	 if ($i =~ /^\'/)
	 {
	   $i =~ s/\'([^\']*)\' ?//;
	   $found = $1;
	 }
	 else
	 {
	   $i =~ s/([^ \t]*) ?//;
	   $found = $1;
	 }
	 
	 # If it looks like what we're looking for,
	 # substitute what is in parens with value.
	 if ($found =~ /$re/i)
	 {
	   $substr = $1;
	   $found =~ s/$substr/$value/i;
	   $i = $bak . "\'$found\' " . $i . "\n";
	   last SCAN;
	 }

	 $bak .= "\'$found\'";
	 $bak .= " " if $bak ne "";
    }
    
    $i = $bak . "\n";
  }

  $ret = &xst_file_buffer_save ($buff, $file);
  &xst_report_leave ();
  return $ret;
}


# Find/append $section in ini $file and replace/append
# $var = $value pair. FIXME: should reimplement with
# interfaces style. This is too large.
sub xst_replace_ini
{
  my ($file, $section, $var, $value) = @_;
  my ($buff, $i, $found_flag, $ret);
  my ($pre_space, $post_comment, $sec_save);

  &xst_report_enter ();
  &xst_report ("replace_ini", $var, $section, $file);

  $buff = &xst_file_buffer_load ($file);

  &xst_file_buffer_join_lines ($buff);
  $found_flag = 0;
  
  foreach $i (@$buff)
  {
    $pre_space = $post_comment = "";
    
    chomp $i;
    $pre_space = $1 if $i =~ s/^([ \t]+)//;
    $post_comment = $1 if $i =~ s/([ \t]*[\#;].*)//;
    
    if ($i ne "")
    {
      if ($i =~ /\[$section\]/i)
      {
        $i =~ s/(\[$section\][ \t]*)//i;
        $sec_save = $1;
        $found_flag = 1;
      }

      if ($found_flag)
      {
        if ($i =~ /\[[^\]]+\]/)
        {
          $i = "$var = $value\n$i";
          $found_flag = 2;
        }
        
        if ($found_flag && $i =~ /^$var[ \t]*=/i)
        {
          if ($value ne "")
          {
            $i =~ s/^($var[ \t]*=[ \t]*).*/$1$value/i;
          }
          else
          {
            $i = "";
          }
          $found_flag = 2;
        }
      }
    }
    
    if ($found_flag && $sec_save ne "")
    {
      $i = $sec_save . $i;
      $sec_save = "";
    }
    
    $i = $pre_space . $i . $post_comment . "\n";
    last if $found_flag == 2;
  }

  push @$buff, "\n[$section]\n" if (!$found_flag);
  push @$buff, "$var = $value\n" if ($found_flag < 2 && $value ne "");
  
  &xst_file_buffer_clean ($buff);
  $ret = &xst_file_buffer_save ($buff, $file);
  &xst_report_leave ();
  return $ret;
}

sub xst_replace_remove_ini_section
{
  my ($file, $section) = @_;
  my ($buff, $i, $found_flag, $ret);
  my ($pre_space, $post_comment, $sec_save);

  &xst_report_enter ();
#  &xst_report ("replace_ini", $var, $section, $file);

  $buff = &xst_file_buffer_load ($file);

  &xst_file_buffer_join_lines ($buff);
  $found_flag = 0;

  foreach $i (@$buff)
  {
    $pre_space = $post_comment = "";

    chomp $i;
    $pre_space = $1 if $i =~ s/^([ \t]+)//;
    $post_comment = $1 if $i =~ s/([ \t]*[\#;].*)//;
    
    if ($i ne "")
    {
      if ($i =~ /\[$section\]/i)
      {
        $i =~ s/(\[$section\][ \t]*)//i;
        $found_flag = 1;
      }
      elsif ($found_flag && $i =~ /\[.+\]/i)
      {
        $i = $pre_space . $i . $post_comment . "\n";
        last;
      }
    }

    if ($found_flag)
    {
      $i = $post_comment . "\n";
    }
    else
    {
      $i = $pre_space . $i . $post_comment . "\n";
    }
  }

  &xst_file_buffer_clean ($buff);
  $ret = &xst_file_buffer_save ($buff, $file);
#  &xst_report_leave ();
  return $ret;
}

sub xst_replace_remove_ini_var
{
  my ($file, $section, $var) = @_;
  &xst_replace_ini ($file, $section, $var, "");
}

# Replace using boolean $value with a yes/no representation,
# ini style.
sub xst_replace_ini_bool
{
  my ($file, $section, $var, $value) = @_;

  $value = ($value == 1)? "yes": "no";

  return &xst_replace_ini ($file, $section, $var, $value);
}


# From loaded buffer, starting at $line_no, find next debian
# interfaces format stanza. Return array ref with all stanza args.
# -1 if not found.
# NOTE: $line_no is a scalar ref. and gives the position of next stanza.
sub xst_replace_interfaces_get_next_stanza
{
  my ($buff, $line_no, $stanza_type) = @_;
  my ($i, $line);

  while ($$line_no <= $#$buff)
  {
    $_ = $$buff[$$line_no];
    $_ = &xst_parse_interfaces_line_clean ($_);
    if (/^$stanza_type[ \t]+[^ \t]/)
    {
      s/^$stanza_type[ \t]+//;
      return [ split ("[ \t]+", $_) ];
    }
    $$line_no ++;
  }

  return -1;
}

sub xst_replace_interfaces_line_is_stanza
{
  my ($line) = @_;

  return 1 if $line =~ /^(iface|auto|mapping)[ \t]+[^ \t]/;
  return 0;
}

# Scan for next option. An option is something that is
# not a stanza. Return key/value tuple ref, -1 if not found.
# $$line_no will contain position.
sub xst_replace_interfaces_get_next_option
{
  my ($buff, $line_no) = @_;
  my ($i, $line, $empty_lines);

  $empty_lines = 0;
  
  while ($$line_no <= $#$buff)
  {
    $_ = $$buff[$$line_no];
    $_ = &xst_parse_interfaces_line_clean ($_);
    
    if (!/^$/)
    {
      return [ split ("[ \t]+", $_, 2) ] if (! &xst_replace_interfaces_line_is_stanza ($_));
      $$line_no -= $empty_lines;
      return -1;
    }
    else
    {
      $empty_lines ++;
    }
    
    $$line_no ++;
  }

  $$line_no -= $empty_lines;

  return -1;
}

# Search buffer for option with key $key, starting
# at $$line_no position. Return 1/0 found result.
# $$line_no will show position.
sub xst_replace_interfaces_option_locate
{
  my ($buff, $line_no, $key) = @_;
  my $option;

  while (($option = &xst_replace_interfaces_get_next_option ($buff, $line_no)) != -1)
  {
    return 1 if ($$option[0] eq $key);
    $$line_no ++;
  }
  
  return 0;
}

# Locate stanza line for $iface in $buff, starting at $$line_no.
sub xst_replace_interfaces_iface_stanza_locate
{
  my ($buff, $line_no, $iface) = @_;
  my $stanza;

  while (($stanza = &xst_replace_interfaces_get_next_stanza ($buff, $line_no, "iface")) != -1)
  {
    return 1 if ($$stanza[0] eq $iface);
    $$line_no ++;
  }
  
  return 0;
}

sub xst_replace_interfaces_auto_stanza_create
{
  my ($buff, @ifaces) = @_;

  push @$buff, "\n";
  push @$buff, "auto " . join (" ", @ifaces) . "\n";
}

# Append a stanza for $iface to buffer.
sub xst_replace_interfaces_iface_stanza_create
{
  my ($buff, $iface) = @_;

  push @$buff, "\n";
  push @$buff, "iface $iface inet static\n";
}

# Delete $iface stanza and all its option lines.
sub xst_replace_interfaces_iface_stanza_delete
{
  my ($file, $iface) = @_;
  my ($buff, $line_no, $stanza);

  $buff = &xst_file_buffer_load ($file);
  &xst_file_buffer_join_lines ($buff);
  $line_no = 0;

  return -1 if (!&xst_replace_interfaces_iface_stanza_locate ($buff, \$line_no, $iface));
  
  $$buff[$line_no] = "";
  $line_no ++;
  while (&xst_replace_interfaces_get_next_option ($buff, \$line_no) != -1)
  {
    $$buff[$line_no] = "";
    $line_no ++;
  }
  
  &xst_file_buffer_clean ($buff);
  return &xst_file_buffer_save ($buff, $file);
}

# Find $iface stanza line and replace $pos value (ie the method).
sub xst_replace_interfaces_stanza_value
{
  my ($file, $iface, $pos, $value) = @_;
  my ($buff, $line_no, $stanza);
  my ($pre_space, $line, $line_arr);

  $buff = &xst_file_buffer_load ($file);
  &xst_file_buffer_join_lines ($buff);
  $line_no = 0;

  if (!&xst_replace_interfaces_iface_stanza_locate ($buff, \$line_no, $iface))
  {
    $line_no = 0;
    &xst_replace_interfaces_iface_stanza_create ($buff, $iface);
    &xst_replace_interfaces_iface_stanza_locate ($buff, \$line_no, $iface);
  }

  $line = $$buff[$line_no];
  chomp $line;
  $pre_space = $1 if $line =~ s/^([ \t]+)//;
  $line =~ s/^iface[ \t]+//;
  @line_arr = split ("[ \t]+", $line);
  $line_arr[$pos] = $value;
  $$buff[$line_no] = $pre_space . "iface " . join (' ', @line_arr) . "\n";

  &xst_file_buffer_clean ($buff);
  return &xst_file_buffer_save ($buff, $file);
}

# Find/append $key option in $iface stanza and set $value.
sub xst_replace_interfaces_option_str
{
  my ($file, $iface, $key, $value) = @_;
  my ($buff, $line_no, $stanza, $ret);
  my ($pre_space, $line, $line_arr);

  &xst_report_enter ();
  &xst_report ("replace_ifaces_str", $key, $iface);
  
  $buff = &xst_file_buffer_load ($file);
  &xst_file_buffer_join_lines ($buff);
  $line_no = 0;

  if (!&xst_replace_interfaces_iface_stanza_locate ($buff, \$line_no, $iface))
  {
    $line_no = 0;
    &xst_replace_interfaces_iface_stanza_create ($buff, $iface);
    &xst_replace_interfaces_iface_stanza_locate ($buff, \$line_no, $iface);
  }

  $line_no++;

  if (&xst_replace_interfaces_option_locate ($buff, \$line_no, $key))
  {
    if ($value eq "") # Delete option if value is empty.
    {
      $$buff[$line_no] = "";
    }
    else
    {
      chomp $$buff[$line_no];
      $$buff[$line_no] =~ s/^([ \t]*$key[ \t]).*/$1/;
    }
  }
  elsif ($value ne "")
  {
    $line_no --;
    chomp $$buff[$line_no];
    $$buff[$line_no] =~ s/^([ \t]*)(.*)/$1$2\n$1$key /;
  }

  $$buff[$line_no] .= $value . "\n" if $value ne "";
  
  &xst_file_buffer_clean ($buff);
  $ret = &xst_file_buffer_save ($buff, $file);
  &xst_report_leave ();
  return $ret;
}

# $key option is keyword. $value says if it should exist or not.
sub xst_replace_interfaces_option_kw
{
  my ($file, $iface, $key, $value) = @_;

  return &xst_replace_interfaces_option_str ($file, $iface, $key, $value? " ": "");
}

# !$value says if keyword should exist or not (ie noauto).
sub xst_replace_interfaces_option_kw_not
{
  my ($file, $iface, $key, $value) = @_;

  return &xst_replace_interfaces_option_kw ($file, $iface, $key, !$value);
}

