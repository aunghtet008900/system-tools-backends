#!/usr/bin/env perl
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-

# Display configurator. Designed to be architecture and distribution independent.
#
# Copyright (C) 2000-2001 Ximian, Inc.
#
# Authors: Tambet Ingo <tambet@ximian.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

# Best viewed with 100 columns of width.

# Configuration files affected:
#
# /etc/X11/XF86Config

# Running programs affected:
#


BEGIN {
require "___scriptsdir___/platform.pl";
require "___scriptsdir___/x.pl";
}

# use strict;

# --- Tool information --- #

$name = "display";
$version = "___version___";
@platforms = qw(redhat-6.2 redhat-7.0 redhat-7.1 turbolinux-7.0 debian-2.2 debian-woody);

$description =<<"end_of_description;";
       Configures XFree86 version 4.
end_of_description;

# --- Platform handling --- #

$platmap =
{
  "redhat-6.2"     => XFree3,
  "redhat-7.0"     => XFree4,
  "redhat-7.1"     => XFree4,
  "turbolinux-7.0" => XFree4,
  "debian-woody"   => XFree4,
  "debian-2.2"     => XFree3
};

$filemap = {
  XFree3 => '/etc/X11/XF86Config',
  XFree4 => '/etc/X11/XF86Config-4',
};

@display_sections = qw(Device Monitor Screen Display ServerLayout);

sub distro_file
{
  return $$filemap{$$platmap{$xst_dist}};
}

# --- XML parsing ---
# Scan XML from standard input to an internal tree.

sub xml_parse
{
  my $fname = shift;
  my ($tree, $hash);

  $tree = &xst_xml_scan ($fname);

  # Find the first interesting value.
  while ($$tree[0] eq undef) {
    shift @$tree;
  }

  while (@$tree) {
    if ($$tree[0] eq $name) { $hash = &x_xml_parse ($$tree[1], $hash); }
    
    shift @$tree;
    shift @$tree;
  }

  return($hash);
}

sub xml_print
{
  my $config = shift;
  my ($section, $hash);

  if (ref ($config) ne "XstXConfig") {
    # TODO: give error
    return;
  }
  
  &xst_xml_print_begin ();
  &xst_xml_print_vspace ();

  foreach $section (keys %$config) {
    my ($arrayref) = $$config{$section};

    foreach $hash (@$arrayref) {      
      &x_xml_print_section ($hash, $section, \@display_sections);
      &xst_xml_print_vspace ();
    }
  }
  
  &xst_xml_print_end ();
}

# Top-level actions.

sub get
{
  my $config = &x_parse (&distro_file ());  

  &x_config_fix ($config, 1);

  &xst_report_end ();
  &xml_print ($config);
}

sub set
{
  my $config = &x_parse (&distro_file ());
  my $xml_config = &xml_parse ();
  &x_config_fix ($xml_config, 0);
  
  &x_config_set (&distro_file (), $config, $xml_config);
  &xst_report_end ();
}

sub filter
{
  my $config = &xml_parse ();
  
  &xst_report_end ();
  &xml_print ($config);
}

sub test
{
  my $testX_cmd = "___scriptsdir___/testX";
  my $tmp_file = "/tmp/XF86Config-tmp";
  my $real_file = &distro_file ();

  # TODO: Check $res after xst_file_run
  
  my $res = &xst_file_run ("cp $real_file $tmp_file");
  
  my $config = &x_parse ($tmp_file);
  my $xml_config = &xml_parse ();
  &x_config_fix ($xml_config, 0);
  
  &x_config_set ($tmp_file, $config, $xml_config);

  $res = &xst_file_run ("$testX_cmd --config=$tmp_file");
  $res = &xst_file_run ("rm -f $tmp_file");
  
  &xst_report_end ();
}

sub probe
{
  my $cfg_file = &distro_file ();
  return unless $cfg_file;
  
  my $config = &x_parse ($cfg_file);
  &x_probe ($cfg_file, $config);
}

# --- Main --- #

# get, set and filter are special cases that don't need more parameters than a ref to their function.
# Read general.pl.in:xst_run_directive to know about the format of this hash.

$directives = {
  "get"    => [ \&get,    [], "" ],
  "set"    => [ \&set,    [], "" ],
  "filter" => [ \&filter, [], "" ],
  "test"   => [ \&test,   [], "Test settings." ],
  "probe"  => [ \&probe,  [], "Return list of valid standard modelines." ],
};

$tool = &xst_init ($name, $version, $description, $directives, @ARGV);
&xst_platform_ensure_supported ($tool, @platforms);
&xst_run ($tool);
