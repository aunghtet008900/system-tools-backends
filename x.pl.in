#!/usr/bin/env perl
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-

# Common functions for XF86Config file.
#
# Copyright (C) 2000-2001 Ximian, Inc.
#
# Authors: Tambet Ingo <tambet@ximian.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

require "___scriptsdir___/general.pl";
require "___scriptsdir___/file.pl";
require "___scriptsdir___/xml.pl";

use Text::ParseWords;
use strict;

my $sections = {};
my $version;

# Keywords are hashes with name as key, and values containing lists of:
# function_to_parse_from_conf, function_to_parse_from_xml, quoted (1/0).

# XFree86 version 4 sections:
# Files
# ServerFlags
# Module
# InputDevice
# Device
# VideoAdaptor
# Monitor
# Modes
# Screen
# ServerLayout
# DRI
# Vendor

my $x4_sections = {
  Monitor => {
    KEY => 'Identifier',
    keywords => {
      Identifier => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      VendorName => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      ModelName  => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      HorizSync  => [ \&parse_range_hz,  \&xml_parse_kw_unique, 0 ],
      VertRefresh =>[ \&parse_range_hz,  \&xml_parse_kw_unique, 0 ],
      ModeLine   => [ \&parse_modeline,  \&xml_parse_modeline,  1 ],
    },
    options => {},
  },
  Device => {
    KEY => 'Identifier',
    keywords => {
      Identifier => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      Driver     => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      BusID      => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      Screen     => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
      Chipset    => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      Ramdac     => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      ClockChip  => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      VideoRam   => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
      BiosBase   => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
      MemBase    => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
      IOBase     => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
      ChipID     => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
      ChipRev    => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
      TextClockFreq => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
    },
    options => {},
  },
  Screen => {
    KEY => 'Identifier',
    keywords => {
      Identifier => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      Device     => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      Monitor    => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      DefaultDepth => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
      DefaultFbBpp => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
    },
    options => {},
    Display => {
      KEY => 'Depth',
      keywords => {
        Depth   => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
        Modes   => [ \&parse_kw_list, \&xml_parse_display_modes, 1 ],
        Virtual => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0],
      }
    }
  },
  ServerLayout => {
    KEY => 'Identifier',
    keywords => {
      Identifier => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      Screen     => [ \&parse_serverlayout_screen, \&xml_parse_kw_unique, 1 ],
    },
    options => {},
  }
};

# XFree86 version 3 sections:
# Files
# Module
# ServerFlags
# Keyboard
# Pointer
# Monitor
# Device
# Screen
# XInput




my $x3_sections = {
  Monitor => {
    KEY => 'Identifier',
    keywords => {
      Identifier => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      VendorName => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      ModelName  => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      HorizSync  => [ \&parse_range_hz,  \&xml_parse_kw_unique, 0 ],
      VertRefresh =>[ \&parse_range_hz,  \&xml_parse_kw_unique, 0 ],
      ModeLine   => [ \&parse_modeline,  \&xml_parse_modeline,  1 ],
    },
    options => {},
  },
  Device => {
    KEY => 'Identifier',
    keywords => {
      Identifier => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      Chipset    => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      Ramdac     => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      ClockChip  => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      VideoRam   => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
      BiosBase   => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
      MemBase    => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
      IOBase     => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
    },
    options => {},
  },
  Screen => {
    KEY => 'Driver',
    keywords => {
      Driver            => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      Device            => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      Monitor           => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      DefaultColorDepth => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
    },
    options => {},
    Display => {
      KEY => 'Depth',
      keywords => {
        Depth   => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
        Modes   => [ \&parse_kw_list, \&xml_parse_display_modes, 1 ],
        Virtual => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0],
      }
    }
  },
};

my @x_colordepths = (8, 15, 16, 24);

# Standard modelines (VESA plus couple extras)

my $standard_modes = q (
                        
# 640x350 @ 85Hz (VESA) hsync: 37.9kHz
ModeLine "640x350@85"    31.5  640  672  736  832    350  382  385  445 +hsync -vsync

# 640x400 @ 85Hz (VESA) hsync: 37.9kHz
ModeLine "640x400@85"    31.5  640  672  736  832    400  401  404  445 -hsync +vsync

# 720x400 @ 85Hz (VESA) hsync: 37.9kHz
ModeLine "720x400@85"    35.5  720  756  828  936    400  401  404  446 -hsync +vsync

# 640x480 @ 60Hz (Industry standard) hsync: 31.5kHz
ModeLine "640x480@60"    25.2  640  656  752  800    480  490  492  525 -hsync -vsync

# 640x480 @ 72Hz (VESA) hsync: 37.9kHz
ModeLine "640x480@72"    31.5  640  664  704  832    480  489  491  520 -hsync -vsync

# 640x480 @ 75Hz (VESA) hsync: 37.5kHz
ModeLine "640x480@75"    31.5  640  656  720  840    480  481  484  500 -hsync -vsync

# 640x480 @ 85Hz (VESA) hsync: 43.3kHz
ModeLine "640x480@85"    36.0  640  696  752  832    480  481  484  509 -hsync -vsync

# 800x600 @ 56Hz (VESA) hsync: 35.2kHz
ModeLine "800x600@56"    36.0  800  824  896 1024    600  601  603  625 +hsync +vsync

# 800x600 @ 60Hz (VESA) hsync: 37.9kHz
ModeLine "800x600@60"    40.0  800  840  968 1056    600  601  605  628 +hsync +vsync

# 800x600 @ 72Hz (VESA) hsync: 48.1kHz
ModeLine "800x600@72"    50.0  800  856  976 1040    600  637  643  666 +hsync +vsync

# 800x600 @ 75Hz (VESA) hsync: 46.9kHz
ModeLine "800x600@75"    49.5  800  816  896 1056    600  601  604  625 +hsync +vsync

# 800x600 @ 85Hz (VESA) hsync: 53.7kHz
ModeLine "800x600@85"    56.3  800  832  896 1048    600  601  604  631 +hsync +vsync

# 1024x768i @ 43Hz (industry standard) hsync: 35.5kHz
ModeLine "1024x768@43"   44.9 1024 1032 1208 1264    768  768  776  817 +hsync +vsync Interlace

# 1024x768 @ 60Hz (VESA) hsync: 48.4kHz
ModeLine "1024x768@60"   65.0 1024 1048 1184 1344    768  771  777  806 -hsync -vsync

# 1024x768 @ 70Hz (VESA) hsync: 56.5kHz
ModeLine "1024x768@70"   75.0 1024 1048 1184 1328    768  771  777  806 -hsync -vsync

# 1024x768 @ 75Hz (VESA) hsync: 60.0kHz
ModeLine "1024x768@75"   78.8 1024 1040 1136 1312    768  769  772  800 +hsync +vsync

# 1024x768 @ 85Hz (VESA) hsync: 68.7kHz
ModeLine "1024x768@85"   94.5 1024 1072 1168 1376    768  769  772  808 +hsync +vsync

# 1152x864 @ 75Hz (VESA) hsync: 67.5kHz
ModeLine "1152x864@75"  108.0 1152 1216 1344 1600    864  865  868  900 +hsync +vsync

# 1280x960 @ 60Hz (VESA) hsync: 60.0kHz
ModeLine "1280x960@60"  108.0 1280 1376 1488 1800    960  961  964 1000 +hsync +vsync

# 1280x960 @ 85Hz (VESA) hsync: 85.9kHz
ModeLine "1280x960@85"  148.5 1280 1344 1504 1728    960  961  964 1011 +hsync +vsync

# 1280x1024 @ 60Hz (VESA) hsync: 64.0kHz
ModeLine "1280x1024@60" 108.0 1280 1328 1440 1688   1024 1025 1028 1066 +hsync +vsync

# 1280x1024 @ 75Hz (VESA) hsync: 80.0kHz
ModeLine "1280x1024@75" 135.0 1280 1296 1440 1688   1024 1025 1028 1066 +hsync +vsync

# 1280x1024 @ 85Hz (VESA) hsync: 91.1kHz
ModeLine "1280x1024@85" 157.5 1280 1344 1504 1728   1024 1025 1028 1072 +hsync +vsync

# 1400x1050 @ 60Hz (VESA GFT) hsync: 65.5kHz
ModeLine "1400x1050@60" 122.0 1400 1488 1640 1880   1050 1052 1064 1082 +hsync +vsync

# 1400x1050 @ 75Hz (VESA GFT) hsync: 82.2kHz
ModeLine "1400x1050@75" 155.8 1400 1464 1784 1912   1050 1052 1064 1090 +hsync +vsync

# 1600x1200 @ 60Hz (VESA) hsync: 75.0kHz
ModeLine "1600x1200@60" 162.0 1600 1664 1856 2160   1200 1201 1204 1250 +hsync +vsync

# 1600x1200 @ 65Hz (VESA) hsync: 81.3kHz
ModeLine "1600x1200@65" 175.5 1600 1664 1856 2160   1200 1201 1204 1250 +hsync +vsync

# 1600x1200 @ 70Hz (VESA) hsync: 87.5kHz
ModeLine "1600x1200@70" 189.0 1600 1664 1856 2160   1200 1201 1204 1250 +hsync +vsync

# 1600x1200 @ 75Hz (VESA) hsync: 93.8kHz
ModeLine "1600x1200@75" 202.5 1600 1664 1856 2160   1200 1201 1204 1250 +hsync +vsync

# 1600x1200 @ 85Hz (VESA) hsync: 106.3kHz
ModeLine "1600x1200@85" 229.5 1600 1664 1856 2160   1200 1201 1204 1250 +hsync +vsync

# 1792x1344 @ 60Hz (VESA) hsync: 83.6kHz
ModeLine "1792x1344@60" 204.8 1792 1920 2120 2448   1344 1345 1348 1394 -hsync +vsync

# 1792x1344 @ 75Hz (VESA) hsync: 106.3kHz
ModeLine "1792x1344@75" 261.0 1792 1888 2104 2456   1344 1345 1348 1417 -hsync +vsync

# 1856x1392 @ 60Hz (VESA) hsync: 86.3kHz
ModeLine "1856x1392@60" 218.3 1856 1952 2176 2528   1392 1393 1396 1439 -hsync +vsync

# 1856x1392 @ 75Hz (VESA) hsync: 112.5kHz
ModeLine "1856x1392@75" 288.0 1856 1984 2208 2560   1392 1393 1396 1500 -hsync +vsync

# 1920x1440 @ 60Hz (VESA) hsync: 90.0kHz
ModeLine "1920x1440@60" 234.0 1920 2048 2256 2600   1440 1441 1444 1500 -hsync +vsync

# 1920x1440 @ 75Hz (VESA) hsync: 112.5kHz
ModeLine "1920x1440@75" 297.0 1920 2064 2288 2640   1440 1441 1444 1500 -hsync +vsync

                        );



sub x_version
{
  my $version;
  my $command = &xst_file_locate_tool ("X");
#  my $command = &xst_file_locate_tool ("/usr/X11R6/bin/XF86_SVGA");

  my ($number, $driver) = (0, "");
  
  open (FD, "$command -version 2>&1 |");
  while (<FD>) {
    if (/^XFree86 Version (\d+)\.(\d+)\.(\d+)/) {
      $number = $1 . $2 . $3;
    }
    elsif ($number > 0 && $number < 400 && /^[ \t]*(\w+): (accelerated)?[ ]*server/) {
      $driver = $1;
      $driver = 'Accel' if $2;
      last;
    }
  }
  close (FD);

  $version->{'number'} = $number;
  $version->{'driver'} = $driver if $driver;
  
  return $version;
}
  
# Difference from xst_item_is_in_list is that XF86Config keywords are
# case-insensitive and "_" characters are ignored.
# Returns found value from list or 0.
sub xst_x_keyword_in_list
{
  my $keyword = shift @_;

  $keyword =~ s/\_//g; # We don't care about underscores (_)
  
  foreach my $item (@_)
  {
    return $item if ($keyword =~ /^$item$/i);
  }

  return 0;
}

sub xst_x_option_in_list
{
  my $keyword = shift @_;

  $keyword =~ s/\"//g; # We don't care about quotes (")
  $keyword =~ s/^No//i; # and it could start with optional "No"
  
  foreach my $item (@_)
  {
    return 1 if ($keyword =~ /^$item$/i);
  }

  return 0;
}

# Returns "SectionName" if $line is section beginning, 0 otherwise.
sub x_section_start
{
  my $line = shift;
  my $subsection = shift;
  my (@section_list) = keys %$sections;

  if ($subsection) {
    return $1 if ($line =~ /^\s*Subsection\s+\"([a-zA-Z]+)\"/i);
  }

  else {
    if ($line =~ /^\s*Section\s+\"([a-zA-Z]+)\"/i) {
      my ($section) = $1;

      return $section if (&xst_item_is_in_list ($section, @section_list));
    }
  }

  return 0;
}

sub x_section_end
{
  my $line = shift;
  my $subsection = shift;

  if ($subsection) {
    return 1 if ($line =~ /^\s*EndSubsection/i);
  }

  else {
    return 1 if ($line =~ /^\s*EndSection/i);
  }

  return 0;
}

sub general_parse_section
{
  my $buff = shift;
  my $tmp;
  
  while (<$buff>) {
    s/^[ \t]*//;
    next if &xst_ignore_line ($_); # Comment or empty line.
    next if &x_section_start ($_, 0); # First line with beginning of section.

    return $tmp if $tmp = &x_section_start ($_, 1); # Start of subsection, return it's name.

    return if &x_section_end ($_, 0);
    return if &x_section_end ($_, 1);
    
    chomp;
    s/^[ \t]*//g;
    
    return &quotewords('[ \t]+', 1, $_);
  }
  return;
}

# Parse general unique value 
sub parse_kw_unique
{  
  my ($line) = shift;
  my ($kw) = shift @$line;
  my ($val);

  foreach (@$line) {
    last if /^\#/;
    $val .= $_ . ' ';
  }
  
  chop $val;                # Remove trailing space
  $val =~ s/\"//g if $val;  # Remove quotes.
  
  bless [ $kw, $val ], "XstXKeywordUnique";
}

# Parse general value with non-unique value
sub parse_kw
{  
  my ($line) = shift;
  my ($kw) = shift @$line;
  my ($val);

  foreach (@$line) {
    last if /^\#/;
    $val .= $_ . ' ';
  }
  
  chop $val;                # Remove trailing space
  $val =~ s/\"//g if $val;  # Remove quotes.
  
  bless [ $kw, $val ], "XstXKeyword";
}

# Parse something like: 'Modes "640x480" "800x600" "1024x768" "1280x1024"'
sub parse_kw_list
{  
  my ($line) = shift;
  my ($kw) = shift @$line;
  my (@val);

  push @val, $kw;
  
  foreach (@$line) {
    last if /^\#/;
    s/\"//g;    
    push @val, $_ if defined $_;
  }
  
  bless \@val, "XstXKeywordList";
}

# Parse VertRefresh and HorizSync
sub parse_range_hz
{
  my ($line) = shift;
  my (@array) = ();

  push @array, shift @$line;

  while (@$line) {
    my $val = shift @$line;
    last if $val =~ /^\#/; # Start of comment

    # We have a range here, concatenate
    if ($line->[0] eq "-") {
      $val .= shift (@$line); # '-'
      $val .= shift (@$line); # max value
    }

    $val =~ s/,//; # We don't need commas
    push @array, $val;
  }
  
  bless \@array, "XstXRange";
}

# parse_option
# Parses "Option" line form XF86Config.
# Arguments:
#  $line - ref to array containing the actual line split by \s. 
# Returns hash with one key (Option) containing hash with option
# name as key and option value as val.
sub parse_option
{
  my $line = shift;
  my ($name, $value);
  my ($val, $bool);

  shift @$line; # Remove "Option"

  $name = shift @$line;
  $value = shift @$line;

  $name =~ s/\"//g;
  $value =~ s/\"//g;

  if ($value =~ /^(1|on|true|yes)$/i) {
    $val = 1;
    $bool = 1;
  } elsif ($value =~ /^(0|off|false|no)$/i) {
    $val = 0;
    $bool = 1;
  } else {
    $val = $value;
  }

  if ($bool) {
    $val = !$val if ($name =~ s/^No//i);

    $val = 'true' if $val;
    $val = 'false' if not $val;
  }

  bless [ $name, $val ], "XstXOption";
}

sub parse_modeline
{
  # TODO: We don't support Mode "name" and multiline Modeline definitions

  my $line = shift;
  my (%hash, $i, $name);
  my @fields = qw (dotclock hdisp hsyncstart hsyncend htotal
                   vdisp vsyncstart vsyncend vtotal);
  my $field_count = scalar @fields;

  shift @$line; # Dump 'ModeLine' keyword

  # Get name, remove quotes
  $name = shift @$line;
  $name =~ s/\"//g;
  $hash{'name'} = $name;

  # Get all other stuff (except falgs)
  for ($i = 0; @$line, $i < $field_count; $i++) {
    $hash{$fields[$i]} = shift @$line;
  }

  unless ($i == $field_count) {
    # TODO give error, something is missing
    1;
    return undef;
  }

  # Get flags if any
  while (@$line) {
    my $val = shift @$line;

    # HSkew is only flag with parameter
    $val .= " " . shift @$line if ($val =~ /^HSkew/i);
    push @{$hash{'flags'}}, $val;
  }

  bless \%hash, "XstXModeLine";
}

sub parse_serverlayout_screen
{
  my $line = shift;
  my (%hash);

  # TODO: Supports screen identifier only, screen_num and
  # screen_position are missing.
  
  shift @$line; #Dump "Screen" keyword.

  foreach (@$line) {
    $hash{'name'} = $1 if (/^\"(.+)\"$/);
  }
  
  bless \%hash, "XstXServerLayoutScreen";
}
  
sub section2config
{
  my $config = shift;
  my $hash = shift;
  my $section = shift;

  push @{$config->{$section}}, $hash;

  if (ref ($config) eq "XstXConfig") {
    bless $config->{$section}, "XstXSection";
  }

  else {
    bless $config->{$section}, "XstXSubsection";
  }
}


sub add2section
{
  my $dest = shift;
  my $source = shift;
  my $type = ref ($source);

  if ($type eq "XstXKeywordUnique") {
    $dest->{$$source[0]} = $$source[1];
  }

  elsif ($type eq "XstXKeyword") {    
    push @ {$dest->{$$source[0]}}, $$source[1];
    bless $dest->{$$source[0]}, $type;
  }

  elsif ($type eq "XstXKeywordList") {
    my $kw = shift @$source;

    foreach (@$source) { push @{$dest->{$kw}}, $_; }
    bless $dest->{$kw}, $type;
  }

  elsif ($type eq "XstXOption") {
    $dest->{'Option'}{$$source[0]} = $$source[1];
    bless $dest->{'Option'}, $type;
  }

  elsif ($type eq "XstXRange") {
    my $kw = shift @$source;
    
    foreach (@$source) { push @{$dest->{$kw}}, $_; }
    bless $dest->{$kw}, $type;
  }
  
  elsif ($type eq "XstXModeLine") {
    push @{$dest->{'ModeLine'}}, $source;
    bless $dest->{'ModeLine'}, "XstXModeLines";
  }

  elsif ($type eq 'XstXDisplayMode') {
    my $kw = shift @$source;
    
    foreach (@$source) { push @{$dest->{$kw}}, $_; }
    bless $dest->{$kw}, $type;
  }   

  elsif ($type eq "XstXServerLayoutScreen") {
    $dest->{'Screen'} = $source;
    bless $dest->{'Screen'}, $type;
  }
  
  else {
    # TODO: give warning
    1;
  }
}

# x_parse_section:
# Parses Sections from XF86Config.
#
# Returns hash containg the section.
sub x_parse_section
{
  my ($config, $buff, $section_desc, $section) = @_;
  my ($keywords) = $section_desc->{keywords};
  my ($options) = $section_desc->{options};  
  my (@line, $ref);

  my $hash = bless {}, "XstX" . $section;
  
  while (@line = &general_parse_section ($buff)) {    
    my ($kw, $func);
    
    if ($kw = &xst_x_keyword_in_list ($line[0], keys %$keywords)) {
      $func = $keywords->{$kw}[0];
    }
    
    elsif ($line[0] =~ /^Option/i && &xst_x_option_in_list ($line[1], keys %$options)) {
      $func = \&parse_option;
    }

    elsif (exists $section_desc->{$line[0]}) {
      &x_parse_section ($hash, $buff, $section_desc->{$line[0]}, $line[0]);
    }
    
    if ($func) {
      my ($ref) = &$func (\@line);

      &add2section ($hash, $ref);
    }
  }
  
  &section2config ($config, $hash, $section);
}

# Main parser from XF86Config file to XstXConfig
sub x_parse
{
  my $fname = shift;
  my ($file, $section);
  local *FILE;

  $version = &x_version;
  return undef unless $version;
  $sections = $x4_sections if ($version->{'number'} >= 400);
  $sections = $x3_sections if ($version->{'number'} > 0 && $version->{'number'} < 400);
  return undef unless $sections;

  my ($config) = bless {}, "XstXConfig";

  $file = &xst_file_open_read_from_names ($fname);
  return undef unless $file;
  *FILE = $file;

  while (<FILE>)
  {
    next if &xst_ignore_line ($_);
    chomp;

    $section = &x_section_start ($_, 0);
    if ($section) {
      &x_parse_section ($config, \*FILE, $sections->{$section}, $section);
    }
  }
  
  close (FILE);
  
  return $config;
}



# XML Printing.

# Internal
sub x_xml_print_array
{
  my $key = shift;
  my $array = shift;

  foreach (@$array) {
    &xst_xml_print_pcdata ($key, $_);
  }
}

# Internal
sub x_xml_print_hash
{
  my $key = shift;
  my $hash = shift;
  my ($subkey, $val);
  
  foreach $subkey (keys %$hash) {
    $val = &xst_xml_quote ($hash->{$subkey});
    &xst_xml_print_line ("<$key name='$subkey' value='$val'/>");
  }
}

# Internal
sub x_xml_print_serverlayout_screen
{
  my $key = shift;
  my $hash = shift;

  # TODO: Supports currently only screen name.

  &xst_xml_print_pcdata ($key, $hash->{'name'});
}

# Internal
sub x_xml_print_modelines
{
  my $key = shift;
  my $modelines = shift;
  my ($mode);
  my @kws = qw(name dotclock hdisp hsyncstart hsyncend htotal
               vdisp vsyncstart vsyncend vtotal);

  &xst_xml_container_enter ("Modes");
  
  foreach $mode (@$modelines) {
    my $type = ref ($mode);
    my ($kw);

    if ($type ne "XstXModeLine") {
      # TODO: Give warning
      next;
    }
    
    &xst_xml_container_enter ("Mode");

    foreach $kw (@kws) {
      my $val = &xst_xml_quote ($mode->{$kw});
      &xst_xml_print_line ("<$kw>$val</$kw>");
    }

    if (exists ($mode->{'flags'})) {
      foreach $kw (@{$mode->{'flags'}}) {
        my $val = &xst_xml_quote ($kw);
        &xst_xml_print_line ("<flag>$val</flag>");
      }
    }
    
    &xst_xml_container_leave ();
  }
  &xst_xml_container_leave ();
}

sub x_xml_print_section
{
  my $hash = shift;
  my $section = shift;
  my $section_list = shift;
  my ($key);

  return if (!&xst_x_keyword_in_list ($section, @$section_list));
  
  &xst_xml_container_enter ("$section");

  foreach $key (keys %$hash) {
    my $type = ref ($hash->{$key});

    if (!$type) {
      &xst_xml_print_pcdata ($key, $$hash{$key});
    }
    
    elsif ($type eq "XstXKeyword") {
      &x_xml_print_array ($key, $hash->{$key});
    }

    elsif ($type eq "XstXKeywordList") {
      &x_xml_print_array ($key, $hash->{$key});
    }

    elsif ($type eq "XstXOption") {
      &x_xml_print_hash ($key, $hash->{$key});
    }

    elsif ($type eq "XstXRange") {
      &x_xml_print_array ($key, $hash->{$key});
    }

    elsif ($type eq "XstXDisplay") {
      &x_xml_print_hash ($key, $hash->{$key});
    }

    elsif ($type eq "XstXModeLines") {
      &x_xml_print_modelines ($key, $hash->{$key});
    }

    elsif ($type eq "XstXServerLayoutScreen") {
      &x_xml_print_serverlayout_screen ($key, $hash->{$key});
    }

    elsif ($type eq "XstXSubsection") {
      my ($tmp);
      
      foreach $tmp (@{$hash->{$key}}) {
        &x_xml_print_section ($tmp, $key, $section_list);
      }
    }
    
    else {
      # TODO: Give warning
      1;
    }
  }  

  &xst_xml_container_leave ();  
}

# XML parser

# Internal
sub xml_parse_kw_unique
{
  my $kw = shift;
  my $val = &xst_xml_get_text (shift);

  bless [ $kw, $val ], "XstXKeywordUnique";
}

# Internal
sub xml_parse_kw_list
{
  my $kw = shift;
  my $val = &xst_xml_get_text (shift);

  bless [ $kw, $val ], "XstXKeywordList";
}

# Internal
sub xml_parse_display_modes
{
  my $kw = shift;
  my $val = &xst_xml_get_text (shift);

  bless [ $kw, $val ], "XstXDisplayMode";
}

# Internal
sub x_xml_parse_section
{
  my ($config, $tree, $section_desc, $section) = @_;
  my ($keywords) = $section_desc->{'keywords'};
  my ($options) = $section_desc->{'options'};

  my $hash = bless {}, "XstX" . $section;
  shift @$tree;

  while (@$tree) {
    my ($ref, $func);
    
    if (exists $keywords->{$$tree[0]}) {
      $func = $keywords->{$$tree[0]}[1];
      if ($func eq "") { print STDERR "$tree->[0]\n"; }
      else { $ref = &$func ($$tree[0], $$tree[1]); }
    }
    
    elsif (exists $options->{$$tree[0]}) {
      $func = $options->{$$tree[0]}[1];
      $ref = &$func ($$tree[0], $$tree[1]);
    }

    elsif (exists $section_desc->{$$tree[0]}) {
      &x_xml_parse_section ($hash, $$tree[1], $section_desc->{$$tree[0]}, $$tree[0]);
    }
    
    if ($ref) {
      &add2section ($hash, $ref);
    }
  
    shift @$tree;
    shift @$tree;
  }
  
  &section2config ($config, $hash, $section);
}

sub x_xml_parse
{  
  my $tree = shift;
  my $config = shift;
  my $sections = $x4_sections; # XML uses always X4 format.
  
  shift @$tree;  # Skip attributes.

  $config = bless {}, "XstXConfig";
  
  while (@$tree) {
    my ($section);
    
    if ($section = &xst_x_keyword_in_list ($$tree[0], keys %$sections)) {
      &x_xml_parse_section ($config, $$tree[1], $sections->{$section}, $section);
    }
    
    else {
      # TODO: Probably give a warning.
      1;
    }

    shift @$tree;
    shift @$tree;
  }

  return $config;
}

# ---------------------------------------------------------------------------
# Add value functions.

# Internal
sub x_add_scalar
{
  my ($val, $quote) = @_;

  if (ref $val) {
    # TODO: give error, wrong arguments.
    return;
  }

  return $quote . $val . $quote;
}

# Internal
sub x_add_array
{
  my ($val, $quote) = @_;

  unless (ref $val) {
    # TODO: give error, wrong arguments.
    return;
  }

  my $value;
  
  foreach (@$val) {
    $value .= $quote . $_ . $quote . ' ';
  }
  chop $value;

  return $value;
}

# Internal
sub x_add_modelines
{
  my ($fd, $modelines, $pre_space, $val_col, $quote) = @_;

  unless (ref ($modelines) eq "XstXModeLines") {
    # TODO: give error, wrong arguments.
    return;
  }

  foreach my $val (@$modelines) {
    my $value = $quote . $val->{'name'} . $quote;
    $value .= " " . $val->{'dotclock'};
    $value .= " " . $val->{'hdisp'};
    $value .= " " . $val->{'hsyncstart'};
    $value .= " " . $val->{'hsyncend'};
    $value .= " " . $val->{'htotal'};
    $value .= " " . $val->{'vdisp'};
    $value .= " " . $val->{'vsyncstart'};
    $value .= " " . $val->{'vsyncend'};
    $value .= " " . $val->{'vtotal'};

    foreach (@{$val->{'flags'}}) {
      $value .= " " . $_;
    }

    print $fd " " x $pre_space, 'ModeLine';

    my $spaces = ($val_col = length ('ModeLine'));
    $spaces = 1 if $spaces <= 0;
    print $fd " " x $spaces, $value . "\n";
  }
}

# Internal
sub x_add_values
{
  my ($fd, $section, $pre_space, $val_col, $section_list) = @_;

  foreach my $key (keys %$section) {
    my $quote;

    if (exists $section_list->{'keywords'}{$key}) {
      $quote = $section_list->{'keywords'}{$key}[2] ? "\"" : "";
    }

    my $type = ref ($section->{$key});
    my $f;

    if    (!$type)                       { $f = \&x_add_scalar; }
    elsif ($type eq "XstXKeywordList")   { $f = \&x_add_array; }
    elsif ($type eq "XstXDisplayMode")   { $f = \&x_add_array; }
    elsif ($type eq "XstXRange")         { $f = \&x_add_array; }

    elsif ($type eq "XstXModeLines")     {
      &x_add_modelines ($fd, $section->{$key}, $pre_space, $val_col, $quote);
    }

    elsif ($type eq "XstXSubsection") {
      &x_add_section ($fd, $section, $key, $pre_space + 8, $val_col + 8, $section_list, 1);
    }

    else {
      #TODO: Give warning!
      1;
    } 
    
    if ($f) {
      my $value = &$f ($section->{$key}, $quote);
      print $fd " " x $pre_space, $key;

      if ($value) {
        my $spaces = ($val_col = length ($key));
        $spaces = 1 if $spaces <= 0;
        print $fd " " x $spaces, $value;
      }

      print $fd "\n";
    }

    delete $section->{$key};
  }
}

# Internal
sub x_add_section
{
  my ($fd, $config, $section_name, $pre_space, $val_col, $section_list, $sub_sec) = @_;

  return unless $fd;

  my $section_str;
  if ($sub_sec) {
    $section_str = "Subsection";
  } else {
    $section_str = "Section";
  }

  foreach my $section (@{$config->{$section_name}}) {
    next unless $section;
    
    print $fd "\n$section_str \"$section_name\"\n";
    &x_add_values ($fd, $section, $pre_space, $val_col, $section_list->{$section_name});
    print $fd "End$section_str\n";
  }

  delete $config->{$section_name};
}

# -----------------------------------------------------------------------------------------
# Update functions

sub x_delete_section
{
  my $infd = shift;
  my $sub_sec = shift;

  while (<$infd>) {
    return if &x_section_end ($_, $sub_sec);
  }
}

sub x_update_kw_list
{
  my ($line, $section, $new_section, $kw, $quoted) = @_;
  my $quote = $quoted ? "\"" : "";

  if (exists ($new_section->{$kw})) {
    my $type = ref ($new_section->{$kw});

    if ($type && $type eq "XstXKeywordList") {
      my $array = $section->{$kw};
      my $new_array = $new_section->{$kw};
      my $i = 0;

      # Take the name of keyword.
      my $new_line = $1 if $line =~ s/^([ \t]*\S+[ \t]*)//;
      
      while (1) {
        my $a = $1 if $line =~ s/^(\S+[ \t]*)//;
        
        if ($$new_array[$i]) {
          # If in old array replace, else add
          if ($a) {
            $a =~ s/$$array[$i]/$$new_array[$i]/;
          } else {
            $a = $quote . $$new_array[$i] . $quote;
          }
          # Remove spaces from the end of a and add to the end new_line. 
          $a =~ s/[ \t]+$//;
          $new_line .= "$a ";
        } else {
          last;
        }
        $i++;
      }

      return $new_line;
    }
  }

  else {
    #TODO: Give error
    1;
  }

  return "";
}

sub x_update_display_mode
{
  my ($line, $section, $new_section, $kw, $quoted) = @_;
  my $quote = $quoted ? "\"" : "";

  if (exists ($new_section->{$kw})) {
    my $type = ref ($new_section->{$kw});

    if($type && $type eq "XstXDisplayMode") {
      my $array = $section->{$kw};
      my $new_array = $new_section->{$kw};
      my $i = 0;

      # Check if initial resolution is changed
      if ($$array[0] ne $$new_array[0]) {
        my ($x, $y) = ($1, $2) if ($$new_array[0] =~ /(\d+)x(\d+)/);
        $new_section->{'Virtual'} = "$x $y";
      }

      # Take the name of keyword.
      my $new_line = $1 if $line =~ s/^([ \t]*\S+[ \t]*)//;

      while (1) {
        my $a = $1 if $line =~ s/^(\S+[ \t]*)//;
        
        if ($$new_array[$i]) {
          # If in old array replace, else add
          if ($a) {
            $a =~ s/$$array[$i]/$$new_array[$i]/;
          } else {
            $a = $quote . $$new_array[$i] . $quote;
          }
          # Remove spaces from the end of a and add to the end new_line. 
          $a =~ s/[ \t]+$//;
          $new_line .= "$a ";
        } else {
          last;
        }
        $i++;
      }

      chop $new_line; # It has always extra space at the end.
      return $new_line . "\n";
    }
  }
  
  #TODO: Give error

  return "";
}

sub x_update_keyword
{
  my ($line, $section, $new_section, $kw, $quoted) = @_;
  my $quote = $quoted ? "\"" : "";
  
  if (exists ($new_section->{$kw})) {
    my $type = ref ($new_section->{$kw});

    if (!$type) {
      $line =~ s/$section->{$kw}/$new_section->{$kw}/;
    }

    elsif ($type eq "XstXKeywordList") {
      $line = &x_update_kw_list ($line, $section, $new_section, $kw, $quoted);
    }

    elsif ($type eq "XstXDisplayMode") {
      $line = &x_update_display_mode ($line, $section, $new_section, $kw, $quoted);
    }

    elsif ($type eq "XstXModeLines") {
      # TODO:
      1;
    }
    
    else {
      # TODO: Implement, give warning.
      print STDERR "x_update_keyword: $type\n";
      1;
    }

    delete $new_section->{$kw};
    return $line;
  }
  
  # Known keyword, doesn't exist, let's remove.
  return "";
}

# Internal
sub x_update_section
{
  my ($infd, $outfd, $config, $xml_config, $section_name, $section_list, $sub_sec, $section_start) = @_;
  my ($section, $new_section, $ident_str, $line, $s);
  my ($pre_space, $val_col);
  
  my $section = shift @{$config->{$section_name}};
  my $ident_str = $section_list->{$section_name}{KEY};

  # Find section from xml config
  foreach (@{$xml_config->{$section_name}}) {
    if ($_->{$ident_str} eq $section->{$ident_str}) {
      $new_section = $_;
      $_ = undef;
      last;
    }
  }
  
  unless ($new_section) {
    &x_delete_section ($infd, $sub_sec);
    return;
  }

  # Remove empty old data structs
  if ($#{$xml_config->{$section_name}} < 1) {
    delete $xml_config->{$section_name};
  }
  
  print $outfd $section_start;
  
  while ($line = <$infd>) {
    if (&x_section_end ($line, $sub_sec)) {
      if (scalar keys %$new_section) {
        &x_add_values ($outfd, $new_section, $pre_space, $val_col, $section_list->{$section_name});
      }
      
      print $outfd $line;
      return;
    }

    my $kw = $2 if ($line =~ /^([ \t]*)(\w+)([ \t]+)/);
    
    if ($kw) {

      $pre_space = length ($1);
      $val_col = length ($kw) + length ($3);
      
      # Keyword
      if ($s = &xst_x_keyword_in_list ($kw, keys %{$section_list->{$section_name}{'keywords'}})) {
        my $quoted = $section_list->{$section_name}{'keywords'}{$s}[2];
        $line = &x_update_keyword ($line, $section, $new_section, $s, $quoted);
      }
        
      # Option
      elsif ($s = &xst_x_option_in_list ($kw, keys %{$section_list->{$section_name}{'options'}})) {
        # TODO: Implement.
        1;
      }
          
      # Subsection
      elsif ($s = &x_section_start ($line, 1)) {
        &x_update_section ($infd, $outfd, $section, $new_section,
                           $s, $section_list->{$section_name}, 1, $line);
        next;
      }

      else {
        #TODO: Give error;
        print STDERR "x_update_section: $kw\n";
      }
    }
    
    print $outfd $line;
  }
}

sub x_config_set
{
  my $fname = shift;
  my $config = shift;
  my $xml_config = shift;

  unless ($fname) {
    # TODO: Give warning.
    return;
  }

  unless ($config) {
    # TODO: Give warning.
    return;
  }

  unless ($xml_config) {
    # TODO: Give warning.
    return;
  }

  my ($infd, $outfd) = &xst_file_open_filter_write_from_names ($fname);
  return undef unless $outfd;

  while (<$infd>)
  {
    if (&xst_ignore_line ($_)) {
      print $outfd $_ ;
      next;
    }

    my $section = &x_section_start ($_, 0);
    if ($section) {
      &x_update_section ($infd, $outfd, $config, $xml_config, $section, $sections, 0, $_);
      next;
    }
    print $outfd $_;
  }

  # Add new sections
  foreach my $key (keys %$xml_config) {
    &x_add_section ($outfd, $xml_config, $key, 8, 24, $sections, 0);
  }

  close ($infd);
  close ($outfd);
}

#-------------------------------------------------------

# internal.
sub x3_get_active_screen
{
  my $config = shift;
  
  return unless $config;

  unless (exists ($config->{'Screen'})) {
    # TODO: No 'Screen's found. give error or add one.
    return undef;
  }
  
  my $section = $config->{'Screen'};
  foreach my $screen (@$section) {
    # Find screen with right 'Identifier'.
    return $screen if ($screen->{'Identifier'} =~ /$version->{'driver'}/i);
  }
  
  # Didn't find screen.
  # TODO: give error or add a screen
  
  return undef;
}

# internal. X versions before 4.0 didn't have section "ServerLayout",
# this functions 'fixes' old config.
sub x3_fix_serverlayout
{
  my $config = shift;
  my $get = shift;
  
  return unless $config;
  
  if ($get) {
    my $section = "ServerLayout";
    my $hash = bless {}, "XstX" . $section;

    # Add 'Identifier'
    $hash->{'Identifier'} = 'Xst Configured';

    # Add 'Screen'
    my $ref = &x3_get_active_screen ($config, $version);
    if ($ref) {
      $hash->{'Screen'} = $ref->{'Identifier'};
    }
    
    &section2config ($config, $hash, $section);
  } else {
    # SET
    delete $config->{'XstXServerLayout'} if (exists ($config->{'XstXServerLayout'}));
  }
}

# internal. X verisions earlier than 4.0 didn't have 'Identifier' in 'Screen' section but
# 'Driver' was used as one.
sub x3_fix_screen
{
  my $config = shift;
  my $get = shift;
  
  return unless $config;
  
  unless (exists ($config->{'Screen'})) {
    # TODO: No 'Screen's found. give error or add one.
    return;
  }
  
  my $section = $config->{'Screen'};
  foreach my $screen (@$section) {
    if ($get) {
      # Driver -> Identifier
      $screen->{'Identifier'} = $screen->{'Driver'};
      delete $screen->{'Driver'};
    } else {
      # Identifier -> Driver
      $screen->{'Driver'} = $screen->{'Identifier'};
      delete $screen->{'Identifier'};
    }

    # Color depth
    if ($get) {
      # GET
      if (exists $screen->{'DefaultColorDepth'}) {
        # DefaultColorDepth -> DefaultDepth
        $screen->{'DefaultDepth'} = $screen->{'DefaultColorDepth'};
        delete $screen->{'DefaultColorDepth'};
      } else {
        # Add default depth
        $screen->{'DefaultDepth'} = 8;
      }
    } else {
      # SET
      # DefaultDepth -> DefaultColorDepth
      $screen->{'DefaultColorDepth'} = $screen->{'DefaultDepth'};
      delete $screen->{'DefaultDepth'};
    }
  }
}

sub x_config_fix
{
  my $config = shift;
  my $get = shift;

  return unless $config;

  if ($version->{'number'} < 400) {
    # Order of calling these functions is IMPORTANT. Some sections depend on others...
    &x3_fix_screen ($config, $get);
    &x3_fix_serverlayout ($config, $get);
  }
}


# -----------------------------------------------------------------------------------
# Probe functions

# Internal
sub x_probe_get_modelines
{
  my $config = shift;
  my $std_modelines;

  return unless $config;

  my @arr = split ('\n', $standard_modes);
  foreach my $line (@arr) {
    next if &xst_ignore_line ($line);

    my @modeline = &quotewords('[ \t]+', 1, $line);    
    my $ref = &parse_modeline (\@modeline);
    push @$std_modelines, $ref;
  }

  return bless $std_modelines, 'XstXModeLines';
}

# Internal
sub x_probe_get_screen
{
  my $config = shift;
  my $screen;

  return unless $config;

  my $active_screen = $config->{'ServerLayout'}[0]{'Screen'}{'name'};
  foreach my $screen (@{$config->{'Screen'}}) {
    if ($screen->{'Identifier'} eq $active_screen) {
      return $screen;
    }
  }

  return undef;
}

# Internal
sub x_probe_get_monitor
{
  my $config = shift;
  my $screen = shift;
  my $monitor;

  return unless $config;
  return unless $screen;

  my $active_monitor = $screen->{'Monitor'};
  foreach $monitor (@{$config->{'Monitor'}}) {
    if ($monitor->{'Identifier'} eq $active_monitor) {
      return $monitor;
    }
  }

  return undef;
}

# Internal
sub x_probe_add_monitor
{
  my $config = shift;
  my $monitor = shift;
  my $modes = shift;

  return unless $config;
  return unless $monitor;

  my $new;
  $new->{'Identifier'} = 'XstTestMonitor';
  $new->{'HorizSync'} = $monitor->{'HorizSync'};
  $new->{'VertRefresh'} = $monitor->{'VertRefresh'};
  $new->{'ModeLine'} = ();
  
  foreach my $mode (@$modes) {
    push @{$new->{'ModeLine'}}, $mode;
  }

  bless $new->{'ModeLine'}, 'XstXModeLines';
  bless $new, 'XstXMonitor';
  
  push @{$config->{'Monitor'}}, $new;

  return $new;
}

# Internal
sub x_probe_add_screen
{
  my $config = shift;
  my $screen = shift;
  my $monitor = shift;

  return unless $config;
  return unless $screen;
  return unless $monitor;

  my $new;
  $new->{'Identifier'} = 'XstTestScreen';
  $new->{'Device'} = $screen->{'Device'};
  $new->{'Monitor'} = 'XstTestMonitor';

  foreach my $depth (@x_colordepths) {
    my $display;    
    
    $display->{'Depth'} = $depth;
    foreach my $mode (@{$monitor->{'ModeLine'}}) {
      push @{$display->{'Modes'}}, $mode->{'name'};
    }

    bless $display->{'Modes'}, 'XstXKeywordList';
    bless $display, 'XstXDisplay';
    push @{$new->{'Display'}}, $display;
  }

  bless $new->{'Display'}, 'XstXSubsection';
  bless $new, 'XstXScreen';
  push @{$config->{'Screen'}}, $new;
}

# Internal
sub x_probe_save
{
  my $orig_file = shift;
  my $config = shift;

  return unless $orig_file;
  return unless $config;

  my $cfg_fname = '/tmp/gewgv';
  my $res = &xst_file_run ("cp $orig_file $cfg_fname");
  my $orig_cfg = &x_parse ($cfg_fname);

  &x_config_set ($cfg_fname, $orig_cfg, $config);
  
  return $cfg_fname;
}

# Internal
sub x_probe_run
{
  my $cfg_file = shift;
  my $modes = shift;

  return unless $cfg_file;

  my $list = {};
  
  my $command = &xst_file_locate_tool ("XFree86");
  foreach my $depth (@x_colordepths) {
    open (FD, "$command :9 -xf86config $cfg_file -probeonly -depth $depth -screen XstTestScreen -logfile log 2>&1 |");
    if (FD) {
      my @content = (<FD>);
      close (FD);

      my @lines = grep (/^\(\*\*\) \w+\(0\): Mode \"/, @content);      

      foreach (@$modes) {
        my $mode = $_;

        foreach (@lines) {
          my $modename = $1 if /\"(.+)\"/;

          if ($modename eq $mode->{'name'}) {
            push @{$list->{$depth}}, $mode;
            last;
          }
        }
      }
    }
  }

  return $list;
}

# Internal
sub x_probe_print_xml
{
  my $list = shift;

  return unless $list;

  foreach my $depth (keys %$list) {
    &xst_xml_container_enter ("$depth");
    &x_xml_print_modelines (0, $list->{$depth});
    &xst_xml_container_leave ();

  }
}

sub x_probe
{
  my $orig_file = shift;
  my $config = shift;  

  return unless $orig_file;
  return unless $config;

  my $modes = &x_probe_get_modelines ($config);
  my $screen = &x_probe_get_screen ($config);
  my $monitor = &x_probe_get_monitor ($config, $screen);
  
  $monitor = &x_probe_add_monitor ($config, $monitor, $modes);
  &x_probe_add_screen ($config, $screen, $monitor);

  my $cfg_file = &x_probe_save ($orig_file, $config);
  my $list = &x_probe_run ($cfg_file, $modes);
  # TODO: delete_file ($cfg_file);
  
  &x_probe_print_xml ($list);
}


1;
