#!/usr/bin/env perl
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-

# Common functions for XF86Config file.
#
# Copyright (C) 2000-2001 Ximian, Inc.
#
# Authors: Tambet Ingo <tambet@ximian.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.


require "___scriptsdir___/general.pl";
require "___scriptsdir___/file.pl";
require "___scriptsdir___/xml.pl";

use Text::ParseWords;

# XFree86 version 4 sections:
# Files
# ServerFlags
# Module
# InputDevice
# Device
# VideoAdaptor
# Monitor
# Modes
# Screen
# ServerLayout
# DRI
# Vendor


# Keywords are hashes with name as key, and values containing lists of:
# function_to_parse_from_conf, function_to_parse_from_xml, quoted (1/0).

$sections = {};

$sections = {
  Monitor => {
    KEY => Identifier,
    keywords => {
      Identifier => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      VendorName => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      ModelName  => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      HorizSync  => [ \&parse_range_hz,  \&xml_parse_kw_unique, 0 ],
      VertRefresh =>[ \&parse_range_hz,  \&xml_parse_kw_unique, 0 ],
    },
    options => {},
  },
  Device => {
    KEY => Identifier,
    keywords => {
      Identifier => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      Driver     => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      BusID      => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      Screen     => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
      Chipset    => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      Ramdac     => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      ClockChip  => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      VideoRam   => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
      BiosBase   => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
      MemBase    => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
      IOBase     => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
      ChipID     => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
      ChipRev    => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
      TextClockFreq => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
    },
    options => {},
  },
  Screen => {
    KEY => Identifier,
    keywords => {
      Identifier => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      Device     => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      Monitor    => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      DefaultDepth => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
      DefaultFbBpp => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
    },
    options => {},
    Display => {
      KEY => Depth,
      keywords => {
        Depth => [ \&parse_kw_unique, \&xml_parse_kw_unique, 0 ],
        Modes => [ \&parse_kw_list, \&xml_parse_kw_list, 1 ],
      }
    }
  },
  ServerLayout => {
    KEY => Identifier,
    keywords => {
      Identifier => [ \&parse_kw_unique, \&xml_parse_kw_unique, 1 ],
      Screen     => [ \&parse_serverlayout_screen, \&xml_parse_kw_unique, 1 ],
    },
    options => {},
  }
};


# Difference from xst_item_is_in_list is that XF86Config keywords are
# case-insensitive and "_" characters are ignored.
# Returns found value from list or 0.
sub xst_x_keyword_in_list
{
  my $keyword = shift @_;

  $keyword =~ s/\_//g; # We don't care about underscores (_)
  
  foreach my $item (@_)
  {
    return $item if ($keyword =~ /^$item$/i);
  }

  return 0;
}

sub xst_x_option_in_list
{
  my $keyword = shift @_;

  $keyword =~ s/\"//g; # We don't care about quotes (")
  $keyword =~ s/^No//i; # and it could start with optional "No"
  
  foreach my $item (@_)
  {
    return 1 if ($keyword =~ /^$item$/i);
  }

  return 0;
}

# Returns "SectionName" if $line is section beginning, 0 otherwise.
sub x_section_start
{
  my $line = shift;
  my $subsection = shift;
  my (@section_list) = keys %$sections;

  if ($subsection) {
    return $1 if ($line =~ /^\s*Subsection\s+\"([a-zA-Z]+)\"/i);
  }

  else {
    if ($line =~ /^\s*Section\s+\"([a-zA-Z]+)\"/i) {
      my ($section) = $1;

      return $section if (&xst_item_is_in_list ($section, @section_list));
    }
  }

  return 0;
}

sub x_section_end
{
  my $line = shift;
  my $subsection = shift;

  if ($subsection) {
    return 1 if ($line =~ /^\s*EndSubsection/i);
  }

  else {
    return 1 if ($line =~ /^\s*EndSection/i);
  }

  return 0;
}

sub general_parse_section
{
  my $buff = shift;
  my $tmp;
  
  while (<$buff>) {
    s/^[ \t]*//;
    next if &xst_ignore_line ($_); # Comment or empty line.
    next if &x_section_start ($_, 0); # First line with beginning of section.

    return $tmp if $tmp = &x_section_start ($_, 1); # Start of subsection, return it's name.

    return if &x_section_end ($_, 0);
    return if &x_section_end ($_, 1);
    
    chomp;
    s/^[ \t]*//g;
    
    return &quotewords('[ \t]+', 1, $_);
  }
  return;
}

# Parse general unique value 
sub parse_kw_unique
{  
  my ($line) = shift;
  my ($kw) = shift @$line;
  my ($val);

  foreach (@$line) {
    last if /^\#/;
    $val .= $_ . ' ';
  }
  
  chop $val;                # Remove trailing space
  $val =~ s/\"//g if $val;  # Remove quotes.
  
  bless [ $kw, $val ], "XstXKeywordUnique";
}

# Parse general value with non-unique value
sub parse_kw
{  
  my ($line) = shift;
  my ($kw) = shift @$line;
  my ($val);

  foreach (@$line) {
    last if /^\#/;
    $val .= $_ . ' ';
  }
  
  chop $val;                # Remove trailing space
  $val =~ s/\"//g if $val;  # Remove quotes.
  
  bless [ $kw, $val ], "XstXKeyword";
}

# Parse something like: 'Modes "640x480" "800x600" "1024x768" "1280x1024"'
sub parse_kw_list
{  
  my ($line) = shift;
  my ($kw) = shift @$line;
  my (@val);

  push @val, $kw;
  
  foreach (@$line) {
    last if /^\#/;
    s/\"//g;    
    push @val, $_ if defined $_;
  }
  
  bless \@val, "XstXKeywordList";
}

# Parse VertRefresh and HorizSync
sub parse_range_hz
{
  my ($line) = shift;
  my (@array) = ();
  my ($val);

  push @array, shift @$line;

  foreach $val (@$line) {
    last if $val =~ /^\#/; # Start of comment
    $val =~ s/,//; # We don't need commas
    push @array, $val;
  }
  
  bless \@array, "XstXRange";
}

# parse_option
# Parses "Option" line form XF86Config.
# Arguments:
#  $line - ref to array containing the actual line split by \s. 
# Returns hash with one key (Option) containing hash with option
# name as key and option value as val.
sub parse_option
{
  my $line = shift;
  my ($name, $value);
  my ($val, $bool);

  shift @$line; # Remove "Option"

  $name = shift @$line;
  $value = shift @$line;

  $name =~ s/\"//g;
  $value =~ s/\"//g;

  if ($value =~ /^(1|on|true|yes)$/i) {
    $val = 1;
    $bool = 1;
  } elsif ($value =~ /^(0|off|false|no)$/i) {
    $val = 0;
    $bool = 1;
  } else {
    $val = $value;
  }

  if ($bool) {
    $val = !$val if ($name =~ s/^No//i);

    $val = 'true' if $val;
    $val = 'false' if not $val;
  }

  bless [ $name, $val ], "XstXOption";
}

sub parse_modeline
{
  my $line = shift;
  my (@array);

  shift @$line; # Dump "ModeLine" keyword.  
  my $name = shift @$line;

  $name =~ s/\"//g;
  push @array, $name;

  # TODO: make it work with "Mode"s and multiline ModeLines

  foreach (@$line) {
    push @array, $_;
  }
  
  bless \@array, "XstXModeLine";
}

sub parse_serverlayout_screen
{
  my $line = shift;
  my (%hash);

  # TODO: Supports screen identifier only, screen_num and
  # screen_position are missing.
  
  shift @$line; #Dump "Screen" keyword.

  foreach (@$line) {
    $hash{'name'} = $1 if (/^\"(.+)\"$/);
  }
  
  bless \%hash, "XstXServerLayoutScreen";
}
  
sub section2config
{
  my $config = shift;
  my $hash = shift;
  my $section = shift;

  push @{$config->{$section}}, $hash;

  if (ref ($config) eq "XstXConfig") {
    bless $config->{$section}, "XstXSection";
  }

  else {
    bless $config->{$section}, "XstXSubsection";
  }
}


sub add2section
{
  my $dest = shift;
  my $source = shift;
  my $type = ref ($source);

  if ($type eq "XstXKeywordUnique") {
    $dest->{$$source[0]} = $$source[1];
  }

  elsif ($type eq "XstXKeyword") {    
    push @ {$dest->{$$source[0]}}, $$source[1];
    bless $dest->{$$source[0]}, $type;
  }

  elsif ($type eq "XstXKeywordList") {
    my $kw = shift @$source;

    foreach (@$source) { push @{$dest->{$kw}}, $_; }
    bless $dest->{$kw}, $type;
  }

  elsif ($type eq "XstXOption") {
    $dest->{'Option'}{$$source[0]} = $$source[1];
    bless $dest->{'Option'}, $type;
  }

  elsif ($type eq "XstXRange") {
    my $kw = shift @$source;
    
    foreach (@$source) { push @{$dest->{$kw}}, $_; }
    bless $dest->{$kw}, $type;
  }

  elsif ($type eq "XstXModeLine") {
    my ($name) = shift @$source;

    foreach (@$source) { push @{$dest->{'ModeLine'}{$name}}, $_; }
    bless $dest->{'ModeLine'}, $type;
  }

  elsif ($type eq "XstXServerLayoutScreen") {
    $dest->{'Screen'} = $source;
    bless $dest->{'Screen'}, $type;
  }
  
  else {
    # TODO: give warning
    1;
  }
}

# x_parse_section:
# Parses Sections from XF86Config.
#
# Returns hash containg the section.
sub x_parse_section
{
  my ($config, $buff, $section_desc, $section) = @_;
  my ($keywords) = $section_desc->{keywords};
  my ($options) = $section_desc->{options};  
  my (@line, $ref);

  my $hash = bless {}, "XstX" . $section;
  
  while (@line = &general_parse_section ($buff)) {    
    my ($kw, $func);
    
    if ($kw = &xst_x_keyword_in_list ($line[0], keys %$keywords)) {
      $func = $keywords->{$kw}[0];
    }
    
    elsif ($line[0] =~ /^Option/i && &xst_x_option_in_list ($line[1], @$options)) {
      $func = \&parse_option;
    }

    elsif (exists $section_desc->{$line[0]}) {
      &x_parse_section ($hash, $buff, $section_desc->{$line[0]}, $line[0]);
    }
    
    if ($func) {
      my ($ref) = &$func (\@line);

      &add2section ($hash, $ref);
    }
  }
  
  &section2config ($config, $hash, $section);
}

# Main parser from XF86Config file to XstXConfig
sub x_parse
{
  my $fname = shift;
  my ($file, $section);
  local *FILE;
  my ($config) = bless {}, "XstXConfig";

  $file = &xst_file_open_read_from_names ($fname);
  return undef unless $file;
  *FILE = $file;

  while (<FILE>)
  {
    next if &xst_ignore_line ($_);
    chomp;

    $section = &x_section_start ($_, 0);
    if ($section) {
      &x_parse_section ($config, \*FILE, $sections->{$section}, $section);
    }
  }
  
  close (FILE);

  return $config;
}



# XML Printing.

# Internal
sub x_xml_print_array
{
  my $key = shift;
  my $array = shift;

  foreach (@$array) {
    &xst_xml_print_pcdata ($key, $_);
  }
}

# Internal
sub x_xml_print_hash
{
  my $key = shift;
  my $hash = shift;
  my ($subkey, $val);
  
  foreach $subkey (keys %$hash) {
    $val = &xst_xml_quote ($hash->{$subkey});
    &xst_xml_print_line ("<$key name='$subkey' value='$val'/>");
  }
}

# Internal
sub x_xml_print_serverlayout_screen
{
  my $key = shift;
  my $hash = shift;

  # TODO: Supports currently only screen name.

  &xst_xml_print_pcdata ($key, $hash->{'name'});
}

sub x_xml_print_section
{
  my $hash = shift;
  my $section = shift;
  my $section_list = shift;
  my ($key);

  return if (!&xst_x_keyword_in_list ($section, @$section_list));
  
  &xst_xml_container_enter ("$section");

  foreach $key (keys %$hash) {
    my $type = ref ($hash->{$key});

    if (!$type) {
      &xst_xml_print_pcdata ($key, $$hash{$key});
    }
    
    elsif ($type eq "XstXKeyword") {
      &x_xml_print_array ($key, $hash->{$key});
    }

    elsif ($type eq "XstXKeywordList") {
      &x_xml_print_array ($key, $hash->{$key});
    }

    elsif ($type eq "XstXOption") {
      &x_xml_print_hash ($key, $hash->{$key});
    }

    elsif ($type eq "XstXRange") {
      &x_xml_print_array ($key, $hash->{$key});
    }

    elsif ($type eq "XstXDisplay") {
      &x_xml_print_hash ($key, $hash->{$key});
    }

    elsif ($type eq "XstXModeLine") {
      &x_xml_print_hash ($key, $hash->{$key});
    }

    elsif ($type eq "XstXServerLayoutScreen") {
      &x_xml_print_serverlayout_screen ($key, $hash->{$key});
    }
    
    elsif ($type eq "XstXSubsection") {
      my ($tmp);
      
      foreach $tmp (@{$hash->{$key}}) {
        &x_xml_print_section ($tmp, $key, $section_list);
      }
    }
    
    else {
      # TODO: Give warning
      1;
    }
  }  

  &xst_xml_container_leave ();  
}

# XML parser

# Internal
sub xml_parse_kw_unique
{
  my $kw = shift;
  my $val = &xst_xml_get_text (shift);

  bless [ $kw, $val ], "XstXKeywordUnique";
}

# Internal
sub xml_parse_kw_list
{
  my $kw = shift;
  my $val = &xst_xml_get_text (shift);

  bless [ $kw, $val ], "XstXKeywordList";
}

# Internal
sub x_xml_parse_section
{
  my ($config, $tree, $section_desc, $section) = @_;
  my ($keywords) = $section_desc->{'keywords'};
  my ($options) = $section_desc->{'options'};
  my ($val, $type);

  my $hash = bless {}, "XstX" . $section;
  shift @$tree;

  while (@$tree) {
    my ($ref, $func);

    if (exists $keywords->{$$tree[0]}) {
      $func = $keywords->{$$tree[0]}[1];
      $ref = &$func ($$tree[0], $$tree[1]);
    }
    
    elsif (exists $options->{$$tree[0]}) {
      $func = $options->{$$tree[0]}[1];
      $ref = &$func ($$tree[0], $$tree[1]);
    }

    elsif (exists $section_desc->{$$tree[0]}) {
      &x_xml_parse_section ($hash, $$tree[1], $section_desc->{$$tree[0]}, $$tree[0]);
    }
    
    if ($ref) {
      &add2section ($hash, $ref);
    }
  
    shift @$tree;
    shift @$tree;
  }
  
  &section2config ($config, $hash, $section);
}

sub x_xml_parse
{  
  my $tree = shift;
  my $config = shift;  
  
  shift @$tree;  # Skip attributes.

  $config = bless {}, "XstXConfig";
  
  while (@$tree) {
    my ($section);

    if ($section = &xst_x_keyword_in_list ($$tree[0], keys %$sections)) {
      &x_xml_parse_section ($config, $$tree[1], $sections->{$section}, $section);
    }
    
    else {
      # TODO: Probably give a warning.
      1;
    }

    shift @$tree;
    shift @$tree;
  }

  return $config;
}

# Update functions

sub x_delete_section
{
  my $infd = shift;
  my $sub_sec = shift;

  while (<$infd>) {
    return if &x_section_end ($_, $sub_sec);
  }
}

sub x_update_keyword
{
  my ($line, $section, $new_section, $kw, $quoted) = @_;
  my $quote = $quoted ? "\"" : "";
  
  if (exists ($new_section->{$kw})) {
    my $type = ref ($new_section->{$kw});

    if (!$type) {
      $line =~ s/$section->{$kw}/$new_section->{$kw}/;
    }

    elsif ($type eq "XstXKeywordList") {
      my $array = $section->{$kw};
      my $new_array = $new_section->{$kw};
      my $i = 0;

      # Take the name of keyword.
      my $new_line = $1 if $line =~ s/^([ \t]*\S+[ \t]*)//;
                               
      while (1) {
        my $a = $1 if $line =~ s/^(\S+[ \t]*)//;
        
        if ($$new_array[$i]) {
          # If in old array replace, else add
          if ($a) {
            $a =~ s/$$array[$i]/$$new_array[$i]/;
          } else {
            $a = $quote . $$new_array[$i] . $quote;
          }
          # Remove spaces from the end of a and add to the end new_line. 
          $a =~ s/[ \t]+$//;
          $new_line .= "$a ";
        } else {
          last;
        }
        $i++;
      }
      $line = $new_line . "\n";
    }

    else {
      # TODO: Implement, give warning.
      1;
    }

    delete $new_section->{$kw};
    return $line;
  }
  
  # Known keyword, doesn't exist, let' remove.
  return "";
}

sub x_add_keyword
{
  my ($outfd, $new_section, $pre_space, $val_col, $section_list) = @_;
  my ($key);

  foreach $key (keys %$new_section) {
    my ($kw, $val);
    my $quote = $section_list->{keywords}{$key}[2] ? "\"" : "";
    my $type = ref ($new_section->{$key});

    if (!$type) {
      $kw = "$key";
      $val = $quote . "$new_section->{$key}". $quote;
    }

    elsif ($type eq "XstXKeywordList") {
      foreach (@{$new_section->{$key}}) {
        $val .= $quote . $_ . $quote . " ";
      }
      chop $val;
      $kw = "$key";
    }

    elsif ($type eq "XstXSubsection") {
      my $sub_space = $pre_space . " " x 4;

      foreach (@{$new_section->{$key}}) {
        if (scalar keys %$_) {
          print $outfd $pre_space, "Subsection \"$key\"\n";
          &x_add_keyword ($outfd, $_, $sub_space, $val_col, $section_list->{$key});
          print $outfd $pre_space, "EndSubsection\n";
        }
      }
    }

    else {
      # TODO: give warning.
      1;
    }

    if ($kw) {
      print $outfd $pre_space, $kw;

      if ($val) {
        my $spaces = " " x ($val_col - length ($kw));
        print $outfd $spaces, $val;
      }

      print $outfd "\n";
    }
  }
}

sub x_update_section
{
  my ($infd, $outfd, $config, $xml_config, $section_name, $section_list, $sub_sec, $section_start) = @_;
  my ($section, $new_section, $ident_str);
  my ($pre_space, $val_col);
  
  my $section = shift @{$config->{$section_name}};
  my $ident_str = $section_list->{$section_name}{KEY};

  # Find section from xml config
  foreach (@{$xml_config->{$section_name}}) {
    if ($_->{$ident_str} eq $section->{$ident_str}) {
      $new_section = $_;
      last;
    }
  }
  
  unless ($new_section) {
    &x_delete_section ($infd, $sub_sec);
    return;
  }

  print $outfd $section_start;
  
  while ($line = <$infd>) {
    if (&x_section_end ($line, $sub_sec)) {

      &x_add_keyword ($outfd, $new_section, $pre_space, $val_col, $section_list->{$section_name});
      
      print $outfd $line;
      return;
    }

    my $kw = $2 if ($line =~ /^([ \t]*)(\w+)([ \t]+)/);
    
    if ($kw) {

      $pre_space = $1;
      $val_col = length ($kw) + length ($3);
      
      # Keyword
      if (exists $section_list->{$section_name}{'keywords'}{$kw}) {
        my $quoted = $section_list->{$section_name}{'keywords'}{$kw}[2];
        $line = &x_update_keyword ($line, $section, $new_section, $kw, $quoted);
      }

      # Option
      elsif (exists $section_list->{$section_name}{'options'}{$kw}) {
        # TODO: Implement.
        1;
      }
          
      # Subsection
      elsif ($s = &x_section_start ($line, 1)) {
        &x_update_section ($infd, $outfd, $section, $new_section,
                           $s, $section_list->{$section_name}, 1, $line);
        next;
      }
      
    }
    
    print $outfd $line;
  }
}

sub x_config_set
{
  my $fname = shift;
  my $config = shift;
  my $xml_config = shift;

  unless ($fname) {
    # TODO: Give warning.
    return;
  }

  unless ($config) {
    # TODO: Give warning.
    return;
  }

  unless ($xml_config) {
    # TODO: Give warning.
    return;
  }
    
  ($infd, $outfd) = &xst_file_open_filter_write_from_names ($fname);
  return undef unless $outfd;

  while (<$infd>)
  {
    if (&xst_ignore_line ($_)) {
      print $outfd $_ ;
      next;
    }

    $section = &x_section_start ($_, 0);
    if ($section) {
      &x_update_section ($infd, $outfd, $config, $xml_config, $section, $sections, 0, $_);
      next;
    }
    print $outfd $_;
  }

  close ($infd);
  close ($outfd);
}



1;
