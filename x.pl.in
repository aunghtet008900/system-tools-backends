#!/usr/bin/env perl
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-

# Common functions for XF86Config file.
#
# Copyright (C) 2000-2001 Ximian, Inc.
#
# Authors: Tambet Ingo <tambet@ximian.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

require "___scriptsdir___/general.pl";
require "___scriptsdir___/file.pl";
require "___scriptsdir___/xml.pl";

# XFree86 version 4 sections:
# Files
# ServerFlags
# Module
# InputDevice
# Device
# VideoAdaptor
# Monitor
# Modes
# Screen
# ServerLayout
# DRI
# Vendor



# Difference from xst_item_is_in_list is that XF86Config keywords are
# case-insensitive and "_" characters are ignored.
# Returns found value from list or 0.
sub xst_x_keyword_in_list ($@)
{
  my $keyword = shift @_;

  $keyword =~ s/\_//g; # We don't care about underscores (_)
  
  foreach my $item (@_)
  {
    return $item if ($keyword =~ /^$item$/i);
  }

  return 0;
}

sub xst_x_option_in_list ($@)
{
  my $keyword = shift @_;

  $keyword =~ s/\"//g; # We don't care about quotes (")
  $keyword =~ s/^No//i; # and it could start with optional "No"
  
  foreach my $item (@_)
  {
    return 1 if ($keyword =~ /^$item$/i);
  }

  return 0;
}

# Returns "SectionName" if $line is section beginning, 0 otherwise.
sub x_section_start ($$@)
{
  my $line = shift;
  my $subsection = shift;
  my (@section_list) = @_;

  if ($subsection) {
    return $1 if ($line =~ /^\s*Subsection\s+\"([a-zA-Z]+)\"/i);
  }

  else {
    if ($line =~ /^\s*Section\s+\"([a-zA-Z]+)\"/i) {
      my ($section) = $1;

      return $section if (&xst_item_is_in_list ($section, @section_list));
    }
  }

  return 0;
}

sub x_section_end ($$)
{
  my $line = shift;
  my $subsection = shift;

  if ($subsection) {
    return 1 if ($line =~ /^\s*EndSubsection/i);
  }

  else {
    return 1 if ($line =~ /^\s*EndSection/i);
  }

  return 0;
}

sub general_parse_section ($)
{
  my $buff = shift;
  my $tmp;
  
  while (<$buff>) {
    s/^[ \t]*//;
    next if &xst_ignore_line ($_); # Comment or empty line.
    next if &x_section_start ($_, 0); # First line with beginning of section.

    return $tmp if $tmp = &x_section_start ($_, 1); # Start of subsection, return it's name.

    return if &x_section_end ($_, 0);
    return if &x_section_end ($_, 1);
    
    chomp;
    s/^[ \t]*//g;
    
    return split (/[ \t]+/);    
  }
}

# Parse general unique value 
sub general_parse_kw ($)
{  
  my ($line) = shift;
  my ($kw) = shift @$line;
  my ($val);

  foreach (@$line) {
    last if /^\#/;
    $val .= $_ . ' ';
  }
  
  chop $val;                # Remove trailing space
  $val =~ s/\"//g if $val;  # Remove quotes.
  
  bless [ $kw, $val ], "XstXKeyword";
}

# Parse general value with non-unique value
sub parse_kw_list ($)
{  
  my ($line) = shift;
  my ($kw) = shift @$line;
  my ($val);

  foreach (@$line) {
    last if /^\#/;
    $val .= $_ . ' ';
  }
  
  chop $val;                # Remove trailing space
  $val =~ s/\"//g if $val;  # Remove quotes.
  
  bless [ $kw, $val ], "XstXKeywordList";
}

# Parse VertRefresh and HorizSync
sub parse_range_hz ($)
{
  my ($line) = shift;
  my (@array) = ();
  my ($val);

  push @array, shift @$line;

  foreach $val (@$line) {
    last if $val =~ /^\#/; # Start of comment
    $val =~ s/,//; # We don't need commas
    push @array, $val;
  }
  
  bless \@array, "XstXRange";
}

# parse_option
# Parses "Option" line form XF86Config.
# Arguments:
#  $line - ref to array containing the actual line split by \s. 
# Returns hash with one key (Option) containing hash with option
# name as key and option value as val.
sub parse_option ($)
{
  my $line = shift;
  my ($name, $value);
  my ($val, $bool);

  shift @$line; # Remove "Option"

  $name = shift @$line;
  $value = shift @$line;

  $name =~ s/\"//g;
  $value =~ s/\"//g;

  if ($value =~ /^(1|on|true|yes)$/i) {
    $val = 1;
    $bool = 1;
  } elsif ($value =~ /^(0|off|false|no)$/i) {
    $val = 0;
    $bool = 1;
  } else {
    $val = $value;
  }

  if ($bool) {
    $val = !$val if ($name =~ s/^No//i);

    $val = 'true' if $val;
    $val = 'false' if not $val;
  }

  bless [ $name, $val ], "XstXOption";
}

sub parse_modeline ($)
{
  my $line = shift;
  my (@array);

  shift @$line; # Dump "ModeLine" keyword.  
  my $name = shift @$line;

  $name =~ s/\"//g;
  push @array, $name;

  # TODO: make it work with "Mode"s and multiline ModeLines

  foreach (@$line) {
    push @array, $_;
  }
  
  bless \@array, "XstXModeLine";
}

sub section2config ($$$)
{
  my $config = shift;
  my $hash = shift;
  my $section = shift;

  push @{$config->{$section}}, $hash;

  if (ref ($config) eq "XstXConfig") {
    bless $config->{$section}, "XstXSection";
  }

  else {
    bless $config->{$section}, "XstXSubsection";
  }
}


sub add2section ($$)
{
  my $dest = shift;
  my $source = shift;
  my $type = ref ($source);

  if ($type eq "XstXKeyword") {
    $dest->{$$source[0]} = $$source[1];
  }

  elsif ($type eq "XstXKeywordList") {    
    push @ {$dest->{$$source[0]}}, $$source[1];
    bless $dest->{$$source[0]}, $type;
  }

  elsif ($type eq "XstXOption") {
    $dest->{'Option'}{$$source[0]} = $$source[1];
    bless $dest->{'Option'}, $type;
  }

  elsif ($type eq "XstXRange") {
    my $kw = shift @$source;
    
    foreach (@$source) { push @{$dest->{$kw}}, $_; }
    bless $dest->{$kw}, $type;
  }

  elsif ($type eq "XstXModeLine") {
    my ($name) = shift @$source;

    foreach (@$source) { push @{$dest->{'ModeLine'}{$name}}, $_; }
#    bless $dest->{'ModeLine'}{$name}, $type;
  }    
  
  else {
    # TODO: give warning
    1;
  }
}

# get_section:
# Parses Sections from XF86Config.
#
# Returns hash containg the section.
sub get_section ($$$$)
{
  my ($config, $buff, $section_desc, $section) = @_;
  my ($keywords) = $section_desc->{keywords};
  my ($options) = $section_desc->{options};
  my (@line, $ref);

  my $hash = bless {}, "XstX" . $section;
  
  while (@line = &general_parse_section ($buff)) {    
    my ($kw, $func);
    
    if ($kw = &xst_x_keyword_in_list ($line[0], keys %$keywords)) {
      $func = $$keywords{$kw};
    }
    
    elsif ($line[0] =~ /^Option/i && &xst_x_option_in_list ($line[1], @$options)) {
      $func = \&parse_option;
    }

    elsif (exists $section_desc->{$line[0]}) {
      &get_section ($hash, $buff, $section_desc->{$line[0]}, $line[0]);
    }
    
    if ($func) {
      my ($ref) = &$func (\@line);

      &add2section ($hash, $ref);
    }
  }
  
  &section2config ($config, $hash, $section);
}

sub xst_xfree4_conf_get ($$)
{
  my ($fname, $section_list) = @_;
  my ($file, $section);
  local *FILE;
  my ($config) = bless {}, "XstXConfig";

  $file = &xst_file_open_read_from_names ($fname);
  return undef if not $file;
  *FILE = $file;

  while (<FILE>)
  {
    next if &xst_ignore_line ($_);
    chomp;

    $section = &x_section_start ($_, 0, keys %$section_list);
    if ($section) {
      &get_section ($config, \*FILE, $section_list->{$section}, $section);
    }
  }

  close (FILE);

  return $config;
}



# XML Printing.

# Internal
sub x_xml_print_array ($$)
{
  my $key = shift;
  my $array = shift;

  foreach (@$array) {
    &xst_xml_print_pcdata ($key, $_);
  }
}

# Internal
sub x_xml_print_hash ($$)
{
  my $key = shift;
  my $hash = shift;
  my ($subkey, $val);
  
  foreach $subkey (keys %$hash) {
    $val = &xst_xml_quote ($hash->{$subkey});
    &xst_xml_print_line ("<$key name='$subkey' value='$val'/>");
  }
}

sub x_xml_print_section ($)
{
  my $hash = shift;
  my $section = shift;
  my ($key);

  &xst_xml_container_enter ("$section");

  foreach $key (keys %$hash) {
    my $type = ref ($hash->{$key});

    if (!$type) {
      &xst_xml_print_pcdata ($key, $$hash{$key});
    }
    
    elsif ($type eq "XstXKeywordList") {
      &x_xml_print_array ($key, $hash->{$key});
    }

    elsif ($type eq "XstXOption") {
      &x_xml_print_hash ($key, $hash->{$key});
    }

    elsif ($type eq "XstXRange") {
      &x_xml_print_array ($key, $hash->{$key});
    }

    elsif ($type eq "XstXDisplay") {
      &x_xml_print_hash ($key, $hash->{$key});
    }
    
    elsif ($type eq "XstXSubsection") {
      my ($tmp);
      
      foreach $tmp (@{$hash->{$key}}) {
        &x_xml_print_section ($tmp, $key);
      }
    }
    
    else {
      # TODO: Give warning
      1;
    }
  }  

  &xst_xml_container_leave ();  
}

1;
