#!/usr/bin/env perl
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-

# Functions for file manipulation. Find, open, read, write, backup, etc.
#
# Copyright (C) 2000-2001 Ximian, Inc.
#
# Authors: Hans Petter Jansson <hpj@ximian.com>
#          Arturo Espinosa <arturo@ximian.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.


require "___scriptsdir___/general.pl";
require "___scriptsdir___/report.pl";


# --- File operations --- #


sub xst_file_get_base_path
{
  return "/var/cache/ximian-setup-tools";
}


sub xst_file_get_tmp_path
{
  return (&xst_file_get_base_path () . "/tmp");
}


sub xst_file_get_backup_path
{
  return (&xst_file_get_base_path () . "/backup");
}


sub xst_create_path
{
  my $path;

  $path = $_[0];
  $path =~ tr/\///s;

  my @pelem = split(/\//, $path); # 'a/b/c/d/' -> 'a', 'b', 'c', 'd', ''
    
  for ($path = ""; @pelem; shift @pelem)
  {
    $path = "$path$pelem[0]";
    mkdir($path, 0770);
    $path = "$path/";
  }
}


sub xst_create_path_for_file
{
  my $path;

  $path = $_[0];
  $path =~ tr/\///s;

  my @pelem = split(/\//, $path); # 'a/b/c/d/' -> 'a', 'b', 'c', 'd', ''
    
  for ($path = ""; @pelem; shift @pelem)
  {
    if ($pelem[1] ne "")
    {
      $path = "$path$pelem[0]";
      mkdir($path, 0770);
      $path = "$path/";
    }
  }
}


$xst_backup_was_made = 0;

sub xst_backup_file
{
  my $backup_file = @_[0];
  my $backup_tool_dir = &xst_file_get_backup_path () . "/$xst_name/";

  # If this is the first backup created by this tool on this invocation,
  # rotate the backup directories and create a new, empty one.

  if (!$xst_backup_was_made)
  {
    my $i;

    if (stat ("$backup_tool_dir/9") && !stat ("$backup_tool_dir/First"))
    {
      # The first rotated-up backup is the beginning of history. It is kept forever.

      &xst_run ("mv $backup_tool_dir/9 $backup_tool_dir/First");
    }
    else
    {
      # FIXME: rm -Rf might not work on all systems.

      &xst_run ("rm -Rf $backup_tool_dir/9");
    }

    for ($i = 8; $i; $i--)
    {
      if (stat ("$backup_tool_dir/$i"))
      {
        &xst_run ("mv $backup_tool_dir/$i $backup_tool_dir/" . ($i+1));
      }
    }
    
    &xst_create_path_for_file ("$backup_tool_dir/1/");
    $xst_backup_was_made = 1;
  }

  # If the file hasn't already been backed up on this invocation, copy the
  # file to the backup directory.

  if (!stat ("$backup_tool_dir/1/$backup_file"))
  {
    &xst_create_path_for_file ("$backup_tool_dir/1/$backup_file");
    &xst_run ("cp $backup_file $backup_tool_dir/1/$backup_file");
  }
}


sub xst_open_read_from_names
{
  local *FILE;
  my $fname = "";
    
  foreach $name (@_)
  {
    if (open (FILE, "$xst_prefix/$name"))
    {
      # FIXME: Remove debug.
      print STDERR "xst_open_read_from_names:$xst_prefix/$name\n" if $xst_verbose;
      $fname = $name;
      last;
    }
  }
  
  (my $fullname = "$xst_prefix/$fname") =~ tr/\//\//s;  # '//' -> '/'	

  if ($fname eq "") 
  { 
    &xst_report_warning (99, "Could not read \[@_\]");
    return;
  }

  &xst_report_info (99, "Reading options from \[$fullname\]");
  return *FILE;
}


sub xst_open_write_from_names
{
  local *FILE;
  my $name;
  my $fullname;
    
  # Find out where it lives.
    
  for $elem (@_) { if (stat($elem) ne "") { $name = $elem; last; } }
    
  if ($name eq "")
  {
    $name = $_[0];
    (my $fullname = "$xst_prefix/$name") =~ tr/\//\//s;
    &xst_report_warning (97, "Could not find \[@_\]. Writing to \[$fullname\]");
  }
  else
  {
    (my $fullname = "$xst_prefix/$name") =~ tr/\//\//s;
    &xst_report_info (98, "Found \[$name\]. Writing to \[$fullname\]");
  }
    
  ($name = "$xst_prefix/$name") =~ tr/\//\//s;  # '//' -> '/' 
  &xst_create_path_for_file ($name);
    
  # Make a backup if the file already exists - if the user specified a prefix,
  # it might not.
    
  if (stat ($name))
  {
    &xst_backup_file ($name);
  }

  # Truncate and return filehandle.

  if (!open (FILE, ">$name"))
  {
    &xst_report_error (99, "Failed to write to \[$name\]");
    return;
  }

  return *FILE;
}


sub xst_open_filter_write_from_names
{
  local *INFILE;
  local *OUTFILE;
  my ($filename, $name, $elem);

  # Find out where it lives.

  for $elem (@_) { if (stat ($elem) ne "") { $name = $elem; last; } }

  if ($name eq "")
  {
    # If we couldn't locate the file, and have no prefix, give up.

    # If we have a prefix, but couldn't locate the file relative to '/',
    # take the first name in the array and let that be created in $prefix.

    if ($prefix eq "")
    {
      &xst_report_warning (98, "No file to patch: \[@_\]");
      return(0, 0);
    }
    else
    {
      $name = $_[0];
      (my $fullname = "$xst_prefix/$name") =~ tr/\//\//s;
      &xst_report_warning (97, "Could not find \[@_\]. Patching \[$fullname\]");
    }
  }
  else
  {
    (my $fullname = "$xst_prefix/$name") =~ tr/\//\//s;
    &xst_report_info (98, "Found \[$name\]. Patching \[$fullname\]");
  }

  ($filename) = $name =~ /.*\/(.+)$/;
  ($name = "$xst_prefix/$name") =~ tr/\//\//s;  # '//' -> '/' 
  &xst_create_path_for_file ($name);

  # Make a backup if the file already exists - if the user specified a prefix,
  # it might not.

  if (stat ($name))
  {
    &xst_backup_file ($name);
  }

  # Return filehandles. Make a copy to use as filter input. It might be
  # invalid (no source file), in which case the caller should just write to
  # OUTFILE without bothering with INFILE filtering.

  my $tmp_path = &xst_file_get_tmp_path ();

  &xst_create_path ("$tmp_path");
  unlink ("$tmp_path/$xst_name-$filename");
  &xst_run ("cp $name $tmp_path/$xst_name-$filename");

  open (INFILE, "$tmp_path/$xst_name-$filename");

  if (!open (OUTFILE, ">$name"))
  {
    &xst_report_error (99, "Failed to write to \[$name\]");
    return;
  }
    
  return (*INFILE, *OUTFILE);
}


# --- Buffer operations --- #


# Open $file and put it into @buffer, for in-line editting.
# \%buffer on success, undef on error.

sub xst_buffer_load
{
  my $file = $_[0];
  my @buffer;
  my $fd;
  
  $fd = &xst_open_read_from_names ($file);
  return undef if !$fd;

  @buffer = (<$fd>);

  return \@buffer;
}


# Take a $buffer and save it in $file. -1 is error, 0 success.

sub xst_buffer_save
{
  my ($buffer, $file) = @_;
  my $fd, $i;

  # FIXME: Remove debug.

  print STDERR "\nfile:$file\n";
  
  foreach $i (@$buffer)
  {
    print STDERR "|" . $i;
  }

  $fd = &xst_open_write_from_names ($file);
  return -1 if !$fd;

  # FIXME: Remove debug.

  foreach $i (@$buffer)
  {
    print $fd $i;
  }

  close $fd;

  return 0;
}


# Erase all empty string elements from the $buffer.

sub xst_buffer_clean
{
  my $buffer = $_[0];
  my $i;

  for ($i = 0; $i <= $#$buffer; $i++)
  {
    splice (@$buffer, $i, 1) if $$buffer[$i] eq "";
  }
}


sub xst_buffer_join_lines
{
  my $buffer = $_[0];
  my $i;

  for ($i = 0; $i <= $#$buffer; $i++)
  {
    while ($$buffer[$i] =~ /\\$/)
    {
      chomp $$buffer[$i];
      chop $$buffer[$i];
      $$buffer[$i] .= $$buffer[$i + 1];
      splice (@$buffer, $i + 1, 1);
    }
  }
}


# --- Command-line utilities --- #


# &xst_run (<command line>)
#
# Assumes the first word on the command line is the command-line utility
# to run, and tries to locate it, replacing it with its full path. The path
# is cached in a hash, to avoid searching for it repeatedly. Output
# redirection is appended, to make the utility perfectly silent. The
# preprocessed command line is run, and its exit value is returned.
#
# Example: "mkswap /dev/hda3" -> "/sbin/mkswap /dev/hda3 >/dev/null 2>/dev/null".

sub xst_run
{
  my ($tool_name, $tool_path, @argline);
  my $command;

  ($tool_name, @argline) = split(/ /, @_[0]);

  $tool_path = &xst_locate_tool ($tool_name);
  if ($tool_path eq "")
  {
    # Not found at all.
    return;
  }

  $command = "$tool_path @argline >/dev/null 2>&1";
  $command =~ s/\"/\\\"/g;
  
  return (system ("/bin/sh -c \"$command\""));
}


# &xst_locate_tool
#
# Tries to locate a command-line utility from a set of built-in paths
# and a set of user paths (found in the environment). The path (or a negative
# entry) is cached in a hash, to avoid searching for it repeatedly.

@xst_builtin_paths = ( "/sbin", "/usr/sbin", "/usr/local/sbin", "/bin",
                      "/usr/bin", "/usr/local/bin" );

%xst_tool_paths = {};

sub xst_locate_tool
{
  my $found = "";
  my @user_paths;

  $found = %xst_tool_paths->{$_[0]};
  if ($found eq "0")
  {
    # Negative cache hit. At this point, the failure has already been reported
    # once.
    return "";
  }

  if ($found eq "")
  {
    # Nothing found in cache. Look for real.

    # Extract user paths to try.

    @user_paths = ($ENV{PATH} =~ /([^:]+):/mg);

    # Try user paths.

    for $path (@user_paths)
    {
      if (-x "$path/$_[0]") { $found = "$path/$_[0]"; last; }
    }

    # Try builtin paths.

    for $path (@xst_builtin_paths)
    {
      if (-x "$path/$_[0]") { $found = "$path/$_[0]"; last; }
    }

    # Report success/failure and update cache.

    if ($found)
    {
      %xst_tool_paths->{$_[0]} = $found;
      &xst_report_info (97, "Found $_[0] tool");
    }
    else
    {
      %xst_tool_paths->{$_[0]} = "0";
      &xst_report_warning (96, "Couldn't find $_[0] tool");
    }
  }
  
  return($found);
}

1;
