#!/usr/bin/env perl
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-

# Boot manager configurator: grub-related routines.
#
# Copyright (C) 2001 Ximian, Inc.
#
# Authors: Arturo Espinosa <arturo@ximian.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.


$SCRIPTSDIR = "___scriptsdir___";
if ($SCRIPTSDIR =~ /^___scriptsdir__[_]/)
{
    $SCRIPTSDIR = ".";
    $DOTIN = ".in";
}

require "$SCRIPTSDIR/general.pl$DOTIN";
require "$SCRIPTSDIR/util.pl$DOTIN";
require "$SCRIPTSDIR/file.pl$DOTIN";
require "$SCRIPTSDIR/xml.pl$DOTIN";
require "$SCRIPTSDIR/parse.pl$DOTIN";
require "$SCRIPTSDIR/replace.pl$DOTIN";
require "$SCRIPTSDIR/partition.pl$DOTIN";


# Grub device notation converters.
sub xst_boot_grub_linux2grub
{
  my ($device_map, $dev) = @_;
  my ($fd, $line, $res, $path, $drive, $part);

  if ($dev =~ /(.*\/)?(fd[0-9]|hd|sd|scd)([a-z]*)([0-9]*)/)
  {
    $path = "/dev/";
    $path = $1 if $1 ne undef;
    $drive = $2 . $3;
    $part = $4 - 1 if $4 ne undef;
  }
  else
  {
    &xst_report ("boot_grub_convert_failed", $dev);
    return undef;
  }
  
  $fd = &xst_file_open_read_from_names ("$device_map");
  $res = undef;
  
  while ($line = <$fd>)
  {
    chomp $line;
    if ($line =~ /\(([^\)]+)\)[ \t]+$path$drive$/)
    {
      $res = $1;
      last;
    }
  }
  close $fd;
  
  if ($res eq undef)
  {
    &xst_report ("boot_grub_convert_failed", $dev);
    return undef;
  }

  $res .= ",$part" if $part ne undef;
  return $res;
}

sub xst_boot_grub_grub2linux
{
  my ($device_map, $grubdev) = @_;
  
  ($drive, $part, @add) = split (',', $grubdev);
  
  $dev = &xst_parse_split_first_str ("$device_map", "\\($drive\\)", "[ \t]+");

  $dev .= $part + 1 if $part ne undef;
  return $dev;
}

sub xst_boot_grub_clean_line
{
  my ($line) = @_;

  chomp $line;
  $line =~ s/\#.*//;
    
  $line =~ s/^[ \t]+//;
  $line =~ s/[ \t]+$//;

  return $line;
}

sub xst_boot_grub_line_is_title
{
  my ($line) = @_;

  if ($line =~ /^title[= \t][ \t]*(.*)$/)
  {
    return $1;
  }

  return undef;
}

sub xst_boot_grub_get_next_entry
{
  my ($fd) = @_;
  my ($line, $res);

  while ($line = <$fd>)
  {
    $line = &xst_boot_grub_clean_line ($line);
    $res = &xst_boot_grub_line_is_title ($line);
    last if $res ne undef;
  }
  
  return $res;
}

sub xst_boot_grub_search_entry
{
  my ($fd, $entry) = @_;
  my ($title);

  while ($title = &xst_boot_grub_get_next_entry ($fd))
  {
    return 1 if $title eq $entry;
  }

  return 0;
}

sub xst_boot_grub_get_entries
{
  my ($grub_conf) = @_;
  my ($fd, $line, @res, $title, $i);
  
  $grub_conf = [$grub_conf] if (ref $grub_conf eq undef);

  foreach $i (@$grub_conf)
  {
    $fd = &xst_file_open_read_from_names ("$i");
    last if $fd;
  }

  return undef if !$fd;
  
  push @res, $title while ($title = &xst_boot_grub_get_next_entry ($fd));
  close $fd;

  return @res;
}

sub xst_boot_grub_parse_cmd
{
  my ($grub_conf, $cmd, $entry) = @_;
  my ($line, $fd);

  $fd = &xst_file_open_read_from_names ("$grub_conf");
  return undef if !$fd;
  
  if ($entry ne undef)
  {
    return undef if not &xst_boot_grub_search_entry ($fd, $entry);
  }

  while ($line = <$fd>)
  {
    $line = &xst_boot_grub_clean_line ($line);
    next if $line eq "";
    last if $line =~ /^title[= \t]/;

    if ($line =~ /^$cmd[= \t][ \t]*(.*)/)
    {
      close $fd;
      return 1 if $1 eq "";
      return $1;
    }
  }
  close $fd;
  
  return undef;
}

sub xst_boot_grub_parse_pixmap
{
  my ($grub_conf, $device_map, $mtab) = @_;
  my ($pixmap, $grubdev, $file, $dev, $root);
  my ($mntopts, $res);

  $pixmap = &xst_boot_grub_parse_cmd ($grub_conf, "splashimage");

  $pixmap =~ /^\(([^\)]+)\)(.*)/;
  $grubdev = $1;
  $file = $2;
  
  if ($grubdev eq undef)
  {
    $file = $pixmap;
    $root = &xst_boot_grub_parse_cmd ($grub_conf, "root");
    $root =~ /^\(([^\)]+)\)/;
    $grubdev = $1;
  }
    
  $dev = &xst_boot_grub_grub2linux ($device_map, $grubdev);
  
  $mntopts = &xst_parse_split_first_array ($mtab, $dev, "[ \t]+", "[ \t]+");

  $res = $$mntopts[0] . "/$file";
  $res =~ s/\/+/\//g;

  return $res;
}

sub xst_boot_grub_parse_timeout
{
  my ($grub_conf) = @_;
  my ($timeout);

  $timeout = &xst_boot_grub_parse_cmd ($grub_conf, "timeout");
  return $timeout * 10 if $timeout ne undef;
  return 0;
}

sub xst_boot_grub_parse_prompt
{
  my ($grub_conf) = @_;
  my ($timeout);

  $timeout = &xst_boot_grub_parse_timeout ($grub_conf);
  return 1 if $timeout;
  return 0;
}

sub xst_boot_grub_parse_default
{
  my ($grub_conf) = @_;
  my ($default, @entries);

  @entries = &xst_boot_grub_get_entries ($grub_conf);
  return undef if (scalar @entries) == 0;

  $default = &xst_boot_grub_parse_cmd ($grub_conf, "default");
  $default = 0 if $default eq undef;

  return $entries[$default];
}

sub xst_boot_grub_parse_root
{
  my ($grub_conf, $entry, $device_map) = @_;
  my ($root);

  $fd = &xst_file_open_read_from_names ("$grub_conf");
  return undef if not &xst_boot_grub_search_entry ($fd, $entry);

  while ($line = <$fd>)
  {
    $line = &xst_boot_grub_clean_line ($line);
    next if $line =~ /^[ \t]*$/;
    last if &xst_boot_grub_line_is_title ($line) ne undef;

    if ($line =~ /^root \(([^\)]+)\)/)
    {
      $root = $1;
      last;
    }

    if ($line =~ /^(kernel|chainload) \(([^\)]+)\)/)
    {
      $root = $2;
    }
  }

  return &xst_boot_grub_grub2linux ($device_map, $root);
}

sub xst_boot_grub_parse_kernel_chainloader
{
  my ($grub_conf, $entry, $keyword) = @_;
  my ($cmd);

  $cmd = &xst_boot_grub_parse_cmd ($grub_conf, $keyword, $entry);
  return undef if $cmd eq undef;

  $cmd =~ s/^\([^\)]\)//;
  $cmd =~ s/[ \t].*//;

  return $cmd;
}

sub xst_boot_grub_parse_image
{
  my ($grub_conf, $entry) = @_;

  return &xst_boot_grub_parse_kernel_chainloader ($grub_conf, $entry, "kernel");
}

sub xst_boot_grub_parse_other
{
  my ($grub_conf, $entry) = @_;

  return &xst_boot_grub_parse_kernel_chainloader ($grub_conf, $entry, "chainloader");
}

sub xst_boot_grub_parse_append
{
  my ($grub_conf, $entry) = @_;
  my ($cmd);

  $cmd = &xst_boot_grub_parse_cmd ($grub_conf, "kernel", $entry);
  return undef if $cmd eq undef;

  $cmd =~ s/^[^ \t]+[ \t]+//;

  return $cmd;
}

sub xst_boot_grub_parse_type
{
  my ($grub_conf, $entry, $partition, $rootdev) = @_;
  my ($line, $res);

  $fd = &xst_file_open_read_from_names ("$grub_conf");
  return undef if not &xst_boot_grub_search_entry ($fd, $entry);

  while ($line = <$fd>)
  {
    chomp $line;
    if ($line =~ /^\#[ \t]*XstEntryType[ \t]+(.*)$/)
    {
      $res = $1;
      last;
    }
  }
  close $fd;

  if ($res eq undef)
  {
    $rootdev =~ s/.*\///;
    $res = $ {$$partition{$rootdev}}{"typestr"};
  }
  
  return $res;
}

1;

