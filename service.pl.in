#!/usr/bin/env perl
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-

# Functions for manipulating system services, like daemons and network.
#
# Copyright (C) 2002 Ximian, Inc.
#
# Authors: Carlos Garnacho Parro <garparr@teleline.es>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

$rcd_path;
$initd_path;
$SCRIPTSDIR = "___scriptsdir___";
$FILESDIR = "___filesdir___";
if ($SCRIPTSDIR =~ /^___scriptsdir__[_]/)
{
    $FILESDIR = "files";
    $SCRIPTSDIR = ".";
    $DOTIN = ".in";
}

use File::Copy;

require "$SCRIPTSDIR/file.pl$DOTIN";
require "$SCRIPTSDIR/report.pl$DOTIN";
require "$SCRIPTSDIR/service-list.pl$DOTIN";


# Where is the SysV subsystem installed?
sub xst_service_sysv_get_paths
{
  my %dist_map =
      (
       # xst_dist => [rc.X dirs location, init.d scripts location]
       "redhat-5.2"   => ["/etc/rc.d", "/etc/rc.d/init.d"],
       "redhat-6.0"   => ["/etc/rc.d", "/etc/rc.d/init.d"],
       "redhat-6.1"   => ["/etc/rc.d", "/etc/rc.d/init.d"],
       "redhat-6.2"   => ["/etc/rc.d", "/etc/rc.d/init.d"],
       "redhat-7.0"   => ["/etc/rc.d", "/etc/rc.d/init.d"],
       "redhat-7.1"   => ["/etc/rc.d", "/etc/rc.d/init.d"],
       "redhat-7.2"   => ["/etc/rc.d", "/etc/rc.d/init.d"],

       "mandrake-7.1" => ["/etc/rc.d", "/etc/rc.d/init.d"],
       "mandrake-7.2" => ["/etc/rc.d", "/etc/rc.d/init.d"],

       "debian-2.2"   => ["/etc", "/etc/init.d"],
       "debian-woody" => ["/etc", "/etc/init.d"],

       "suse-7.0"     => ["/etc/rc.d", "/etc/rc.d"],

       "turbolinux-7.0"   => ["/etc/rc.d", "/etc/rc.d/init.d"]
       );
  my $res;

  $res = $dist_map{$xst_dist};
  &xst_report ("service_sysv_unsupported", $xst_dist) if ($res eq undef);
  return @$res;
}

# THESE ARE THE FUNCTIONS WHICH EXTRACT THE CONFIGURATION FROM THE COMPUTER

# we are going to extract the name of the script
sub xst_service_sysv_get_service_name
{
	my ($service) = @_;
	
	$service =~ s/$initd_path\///;
  
	return $service;
}

# This function gets the state of the service along the runlevels,
# it also returns the average priority
sub xst_service_sysv_get_runlevels_status
{
	my ($service) = @_;
	my ($link);
	my ($runlevel, $action, $priority);
	my (@arr, @ret);
	my ($sum, $count);
	
	$sum = $count = 0;
	
	foreach $link (<$rcd_path/rc[0-6].d/[SK][0-9][0-9]$service>)
	{
		$link =~ s/$rcd_path\///;
		$link =~ /rc([0-6])\.d\/([SK])([0-9][0-9]).*/;
		($runlevel,$action,$priority)=($1,$2,$3);
		if ($action eq "S")
		{
			push @arr, $runlevel;
			$sum += $priority;
		}
		else
		{
			$sum += (100 -$priority);
		}
		$count++;
	}
	
	return (undef,99) if (scalar(@arr) eq 0);
	push @ret, { "runlevel" => \@arr };
	return (\@ret, int ($sum / $count));
}
		
	
# This function returns all the available actions for each service
sub xst_service_sysv_get_service_actions
{
	my ($service) = @_;
	my (@arr,@actions);
	my ($size,$output);
	my (@ret);
	
	$output = `$service 2>/dev/null`;
	
	# if the output doesn't have the 'usage' word in it, then isn't a valid output
	return undef unless ($output =~ /usage/i);
	
	@arr = split / /, $output;
	$size = scalar (@arr);
	
	# if the array has 0 rows, the service has no actions
	return undef if ($size eq 0);
	
	$arr[$size-1] =~ s/[\{\}]//g;

	@actions = split /\|/, $arr[size-1];
	
	push @ret, { "action" => \@actions };
	
	return \@ret;
}


# We are going to extract the information of the service
sub xst_service_sysv_get_service_info
{
	my ($service) = @_;
	my ($script, $name, $description, @actions, @runlevels);
	my %hash;
	
	# We have to check out if the service is executable	
	return undef unless (-x $service);

	$script = &xst_service_sysv_get_service_name ($service);
		
	# We have to check out if the service is in the "forbidden" list
	return undef if (&xst_service_list_service_is_forbidden ($script));

	($name, $description) = &xst_service_list_get_info ($script);
	($runlevels, $priority) = &xst_service_sysv_get_runlevels_status($script);
	$actions = &xst_service_sysv_get_service_actions ($service);

	$hash{"script"} = $script;
	$hash{"name"} = $name unless ($name eq undef);
	$hash{"description"} = $description unless ($description eq undef);
	$hash{"actions"} = $actions unless ($actions eq undef);
	$hash{"runlevels"} = $runlevels unless ($runlevels eq undef);
	$hash{"priority"} = $priority;

	return \%hash;
}


# This function gets an ordered array of the available services
sub xst_service_sysv_get_services
{
	my ($service);
	my (@arr,@ret);
	
	($rcd_path, $initd_path) = &xst_service_sysv_get_paths ();

	foreach $service (<$initd_path/*>)
	{
		my (%hash);
		$hash = &xst_service_sysv_get_service_info ($service);
		if ($hash ne undef)
		{
			my ($i,$sc);
			my (@aux);
			push @aux, $hash;
			$i = 0;
			$sc = scalar (@arr);
			while (($i < $sc) and ($arr[$i]{"priority"} <= $$hash{"priority"}))
			{
				$i++;
			}
			splice (@arr, $i, 0, @aux);
		}
	}
	
	push @ret, { "service" => \@arr };
	return \@ret;
}


# This function gets the runlevel that is in use
sub xst_service_sysv_get_default_runlevel
{
	my (@arr);
	
	@arr = split / /, `/sbin/runlevel` ;
	$arr[1] =~ s/\n//;
	
	return $arr[1];
}


# THESE ARE THE FUNCTIONS WHICH APPLY THE CHANGES MADE TO THE CONFIGURATION OF THE COMPUTER

sub xst_service_sysv_add_link
{
  my ($runlevel, $action, $priority, $service) = @_;
  my ($prio) = sprintf ("%0.2d",$priority);

  symlink ("$initd_path/$service", "$rcd_path/rc$runlevel.d/$action$prio$service");
  
  &xst_report_enter ();
  &xst_report ("service_sysv_add_link", "$rcd_path/rc$runlevel.d/$action$prio$service");
  &xst_report_leave ();
}

sub xst_service_sysv_remove_link
{
  my ($runlevel, $script) = @_;
	
  foreach $link (<$rcd_path/rc$runlevel.d/[SK][0-9][0-9]$script>)
  {
    &xst_report ("service_sysv_remove_link", "$link");
    unlink ("$link");
    &xst_report_leave ();
  }
}

sub xst_service_sysv_set_service
{
  my ($service) = @_;
  my ($script, $priority, $runlevels);
  my ($found);

  ($rcd_path, $initd_path) = &xst_service_sysv_get_paths ();

  $script = $$service{"script"};
  $priority = $$service{"priority"};
  $runlevels = $$service{"runlevels"}[0]{"runlevel"};

  # pass though all the runlevels checking if the service must be started or stopped  
  for ($i = 0; $i<=6; $i++){
    $found = 0;
    foreach $j (@$runlevels)
	{
		$found = 1 if $i == $j;
	}
	&xst_service_sysv_remove_link ($i, $script);
	if ($found ==1)
	{
	  &xst_service_sysv_add_link($i, "S", $priority, $script);
	}
	else
	{
	  &xst_service_sysv_add_link($i, "K", 100 - $priority, $script);
	}
  }
}

sub xst_service_sysv_set_services
{
	my ($services) = @_;
	
	foreach $i (@$services)
	{
		&xst_service_sysv_set_service($i);
	}
}

sub xst_service_sysv_set_conf
{
  my ($hash) = @_;
  my ($services);
  
  return unless $hash;
  $services = $$hash{"services"}[0]{"service"};
  return unless $services;
  
  &xst_service_sysv_set_services($services);
}

