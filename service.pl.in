#!/usr/bin/env perl
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-

# Functions for manipulating system services, like daemons and network.
#
# Copyright (C) 2002 Ximian, Inc.
#
# Authors: Carlos Garnacho Parro <garparr@teleline.es>,
#          Hans Petter Jansson <hpj@ximian.com>,
#          Arturo Espinosa <arturo@ximian.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

$rcd_path;
$initd_path;
$relative_path;

$SCRIPTSDIR = "___scriptsdir___";
$FILESDIR = "___filesdir___";
if ($SCRIPTSDIR =~ /^___scriptsdir__[_]/)
{
    $FILESDIR = "files";
    $SCRIPTSDIR = ".";
    $DOTIN = ".in";
}

use File::Copy;

require "$SCRIPTSDIR/file.pl$DOTIN";
require "$SCRIPTSDIR/report.pl$DOTIN";
require "$SCRIPTSDIR/service-list.pl$DOTIN";

# Where is the SysV subsystem installed?
sub gst_service_sysv_get_paths
{
  my %dist_map =
      (
       # gst_dist => [rc.X dirs location, init.d scripts location]
       "redhat-5.2"   => ["/etc/rc.d", "/etc/rc.d/init.d", "../init.d"],
       "redhat-6.0"   => ["/etc/rc.d", "/etc/rc.d/init.d", "../init.d"],
       "redhat-6.1"   => ["/etc/rc.d", "/etc/rc.d/init.d", "../init.d"],
       "redhat-6.2"   => ["/etc/rc.d", "/etc/rc.d/init.d", "../init.d"],
       "redhat-7.0"   => ["/etc/rc.d", "/etc/rc.d/init.d", "../init.d"],
       "redhat-7.1"   => ["/etc/rc.d", "/etc/rc.d/init.d", "../init.d"],
       "redhat-7.2"   => ["/etc/rc.d", "/etc/rc.d/init.d", "../init.d"],
       "redhat-7.3"   => ["/etc/rc.d", "/etc/rc.d/init.d", "../init.d"],
       "redhat-8.0"   => ["/etc/rc.d", "/etc/rc.d/init.d", "../init.d"],

       "mandrake-7.1" => ["/etc/rc.d", "/etc/rc.d/init.d", "../init.d"],
       "mandrake-7.2" => ["/etc/rc.d", "/etc/rc.d/init.d", "../init.d"],

       "debian-2.2"   => ["/etc", "/etc/init.d", "../init.d"],
       "debian-woody" => ["/etc", "/etc/init.d", "../init.d"],
       "debian-sarge" => ["/etc", "/etc/init.d", "../init.d"],

       "suse-7.0"     => ["/etc/rc.d", "/etc/rc.d", "../"],

       "turbolinux-7.0"   => ["/etc/rc.d", "/etc/rc.d/init.d", "../init.d"]
       );
  my $res;

  $res = $dist_map{$gst_dist};
  &gst_report ("service_sysv_unsupported", $gst_dist) if ($res eq undef);
  return @$res;
}

# Those runlevels that are usually used. Maybe we should add
# the current running runlevel, using the "runlevel" command.
sub gst_service_sysv_get_runlevels
{
  my %dist_map =
      (
       "redhat-5.2"     => [3, 5],
       "redhat-6.0"     => [3, 5],
       "redhat-6.1"     => [3, 5],
       "redhat-6.2"     => [3, 5],
       "redhat-7.0"     => [3, 5],
       "redhat-7.1"     => [3, 5],
       "redhat-7.2"     => [3, 5],
       "redhat-7.3"     => [3, 5],
       "redhat-8.0"     => [3, 5],

       "mandrake-7.1"   => [3, 5],
       "mandrake-7.2"   => [3, 5],

       "debian-2.2"     => [2, 3],
       "debian-woody"   => [2, 3],
       "debian-sarge"   => [2, 3],

       "suse-7.0"       => [3, 5],

       "turbolinux-7.0" => [3, 5]
       );
  my $res;

  $res = $dist_map{$gst_dist};
  &gst_report ("service_sysv_unsupported", $gst_dist) if ($res eq undef);
  return @$res;
}

# --- Plain process utilities --- #

# Get owner (login) of named process.
# FIXME: Works only on modern Linux, probably.
# FIXME: Need a version of this that examines all instances of process name.
sub gst_service_proc_get_owner
{
  my ($service) = @_;
  my ($pid, $owner);
  my $res = 0;

  &gst_report_enter ();

  # Stolen from RedHat's /etc/rc.d/init.d/functions:status
  # FIXME: Portable to other UNIXen?
  $pid = &gst_file_run_backtick ("pidof -o %PPID -x $service");
  chomp $pid;

  if ($pid)
  {
    $owner = &gst_file_run_backtick ("ps --no-headers -p $pid -o user");
  }
  else
  {
    $owner = undef;
  }

  &gst_report_leave ();
  return $owner;
}

# FIXME: Need a version of this that stops all instances of process name.
sub gst_service_proc_stop
{
  my ($service) = @_;
  my ($pid);
  my $res = 0;

  &gst_report_enter ();

  # Stolen from RedHat's /etc/rc.d/init.d/functions:status
  # FIXME: Portable to other UNIXen?
  $pid = &gst_file_run_backtick ("pidof -o %PPID -x $service");
  chomp $pid;

  if ($pid)
  {
    kill "SIGTERM", $pid;
    $res = 1;
  }

  &gst_report_leave ();
  return $res;
}

# FIXME: Need a version of this that starts all instances of process name.
sub gst_service_proc_start
{
  my ($cmd, $user) = @_;
  my ($fqsu, $fqcmd);

  $fqcmd = &gst_file_get_cmd_path ($cmd);
  $fqsu  = &gst_file_get_cmd_path ("su");

  # Can't use gst_file_run_bg here, since it clobbers the quotes.
  system ("$fqsu -c \"$fqcmd &\" $user >/dev/null 2>/dev/null");
}

sub gst_service_sysv_installed
{
  my ($service) = @_;
  my ($res, $rcd_path, $initd_path);

  &gst_report_enter ();
  
  ($rcd_path, $initd_path) = &gst_service_sysv_get_paths ();

  $res = 1;
  if (! -f "$initd_path/$service")
  {
    $res = 0;
    &gst_report ("service_sysv_not_found", $service);
  }

  &gst_report_leave ();
  return $res;
}

sub gst_service_sysv_list_dir
{
    my ($path) = @_;
    my ($service, @services);

    foreach $service (<$path/*>)
    {
        if (-x $service)
        {
            $service =~ s/.*\///;
            push @services, $service;
        }
    }

    return \@services;
}


sub gst_service_sysv_list_available
{
    my ($rcd_path, $initd_path);
    
    ($rcd_path, $initd_path) = &gst_service_sysv_get_paths ();

    return &gst_service_sysv_list_dir ($initd_path);
}

# Return 1 or 0: is the service running?
# Depends on the rc script to support the "status" arg.
# Maybe we should do something more portable.
sub gst_service_sysv_get_status
{
  my ($service) = @_;
  my ($rc_path, $initd_path, $res);
  my ($pid);

  &gst_report_enter ();

  # Stolen from RedHat's /etc/rc.d/init.d/functions:status
  # FIXME: portable to other UNIXES?
  $pid = &gst_file_run_backtick ("pidof -o %PPID -x $service");
  chomp $pid;

  if ($pid)
  {
    $res = 1;
    &gst_report ("service_status_running", $service);
  }
  else
  {
    $res = 0;
    &gst_report ("service_status_stopped", $service);
  }
    
#  ($rcd_path, $initd_path) = &gst_service_sysv_get_paths ();
#  $res = 0;
#  
#  if (-f "$initd_path/$service")
#  {
#    $res = &gst_file_run ("$initd_path/$service status")? 0 : 1;
#    &gst_report ("service_status_running", $service) if $res;
#    &gst_report ("service_status_stopped", $service) if !$res;
#  }

  &gst_report_leave ();
  return $res;
}

# If any of the passed services is running, return true.
sub gst_service_sysv_get_status_any
{
  my (@services) = @_;
  my $i;

  foreach $i (@services)
  {
    return 1 if &gst_service_sysv_get_status ($i);
  }

  return 0;
}

# Set start links and remove stop links at the usual runlevels.
# Old start link is removed, in case the priority is different from $pri.
sub gst_service_sysv_set_links_active
{
  my ($pri, $service) = @_;

  foreach $runlevel (&gst_service_sysv_get_runlevels ())
  {
    &gst_service_sysv_remove_link ($runlevel, $service);
    &gst_service_sysv_add_link ($runlevel, "S", $pri, $service);
  }
}

# Set stop links and remove start links at the usual runlevels.
sub gst_service_sysv_set_links_inactive
{
  my ($pri, $service) = @_;

  foreach $runlevel (&gst_service_sysv_get_runlevels ())
  {
    &gst_service_sysv_remove_link ($runlevel, "$service");
    &gst_service_sysv_add_link ($runlevel, "K", $pri, $service);
  }
}

# Set links for active/inactive service at the given priority.
sub gst_service_sysv_set_links
{
  my ($pri, $service, $active) = @_;

  if ($active)
  {
    &gst_service_sysv_set_links_active ($pri, $service);
  }
  else
  {
    &gst_service_sysv_set_links_inactive (100 - $pri, $service);
  }
}

# Run the init.d script for the corresponding service, with
# arg, which can be "stop", "start" or "restart".
sub gst_service_sysv_run_initd_script
{
  my ($service, $arg) = @_;
  my ($rc_path, $initd_path);
  my $str;
  my %map =
      ("restart" => "restarted",
       "stop" => "stopped",
       "start" => "started");

  &gst_report_enter ();
  
  if (!exists $map{$arg})
  {
    &gst_report ("service_sysv_op_unk", $arg);
    &gst_report_leave ();
    return -1;
  }

  $str = $map{$arg};

  ($rcd_path, $initd_path) = &gst_service_sysv_get_paths ();

  if (-f "$initd_path/$service")
  {
    if (!&gst_file_run ("$initd_path/$service $arg"))
    {
      &gst_report ("service_sysv_op_success", $service, $str);
      &gst_report_leave ();
      return 0;
    }
  }
  
  &gst_report ("service_sysv_op_failed", $service, $str);
  &gst_report_leave ();
  return -1;
}

# Start or stop the service, depending on $active. Set
# links accordingly.  $force makes this function use
# start/stop only, without considerations for restart.
# Not to be called from parse/replace tables, due to last $force
# param: use the following two functions instead.
sub gst_service_sysv_set_status_do
{
  my ($priority, $service, $active, $force) = @_;
  my ($arg, $status);

  &gst_service_sysv_set_links ($priority, $service, $active);
  
  $status = &gst_service_sysv_get_status ($service);
  if ($status && !$force)
  {
    # if it's already active and you want it active, restart.
    $arg = $active? "restart" : "stop";
  }
  else
  {
    # normal operation.
    $arg = $active? "start" : "stop";
  }

  return &gst_service_sysv_run_initd_script ($service, $arg);
}

sub gst_service_sysv_set_status
{
  my ($priority, $service, $active) = @_;

  return &gst_service_sysv_set_status_do ($priority, $service, $active, 0);
}

sub gst_service_sysv_force_status
{
  my ($priority, $service, $active) = @_;

  return &gst_service_sysv_set_status_do ($priority, $service, $active, 1);
}

sub gst_service_sysv_install_script
{
  my ($service, $file) = @_;
  my ($res, $rcd_path, $initd_path);

  ($rcd_path, $initd_path) = &gst_service_sysv_get_paths ();

  if (!copy ("$FILESDIR/$file", "$initd_path/$service"))
  {
      &gst_report ("file_copy_failed", "$FILESDIR/$file", "$initd_path/$service");
      return -1;
  }

  chmod (0755, "$initd_path/$service");

  return 0;
}

# THESE ARE THE FUNCTIONS WHICH EXTRACT THE CONFIGURATION FROM THE COMPUTER

# we are going to extract the name of the script
sub gst_service_sysv_get_service_name
{
	my ($service) = @_;
	
	$service =~ s/$initd_path\///;
  
	return $service;
}

# This function gets the state of the service along the runlevels,
# it also returns the average priority
sub gst_service_sysv_get_runlevels_status
{
	my ($service) = @_;
	my ($link);
	my ($runlevel, $action, $priority);
	my (@arr, @ret);
	my ($sum, $count);
	
	$sum = $count = 0;
	
	foreach $link (<$rcd_path/rc[0-6].d/[SK][0-9][0-9]$service>)
	{
		$link =~ s/$rcd_path\///;
		$link =~ /rc([0-6])\.d\/([SK])([0-9][0-9]).*/;
		($runlevel,$action,$priority)=($1,$2,$3);
		if ($action eq "S")
		{
			push @arr, { "number" => $runlevel,
				         "action" => "start" };
			$sum += $priority;
		}
		elsif ($action eq "K")
		{
			push @arr, { "number" => $runlevel,
			             "action" => "stop" };
			$sum += (100 -$priority);
		}
		$count++;
	}
	
	return (undef,99) if (scalar(@arr) eq 0);
	push @ret, { "runlevel" => \@arr };
	return (\@ret, int ($sum / $count));
}

# We are going to extract the information of the service
sub gst_service_sysv_get_service_info
{
	my ($service) = @_;
	my ($script, $name, $description, @actions, @runlevels);
	my %hash;
	
	# We have to check if the service is executable	
	return undef unless (-x $service);

	$script = &gst_service_sysv_get_service_name ($service);
		
	# We have to check out if the service is in the "forbidden" list
	return undef if (&gst_service_list_service_is_forbidden ($script));

	($name, $description) = &gst_service_list_get_info ($script);
	($runlevels, $priority) = &gst_service_sysv_get_runlevels_status($script);

	$hash{"script"} = $script;
	$hash{"name"} = $name unless ($name eq undef);
	$hash{"description"} = $description unless ($description eq undef);
	$hash{"runlevels"} = $runlevels unless ($runlevels eq undef);
	$hash{"priority"} = $priority;

	return \%hash;
}


# This function gets an ordered array of the available services
sub gst_service_sysv_get_services
{
	my ($service);
	my (@arr,@ret);
	
	($rcd_path, $initd_path) = &gst_service_sysv_get_paths ();

	foreach $service (<$initd_path/*>)
	{
		my (%hash);
		$hash = &gst_service_sysv_get_service_info ($service);
		if ($hash ne undef)
		{
			my ($i,$sc);
			my (@aux);
			push @aux, $hash;
			$i = 0;
			$sc = scalar (@arr);
			while (($i < $sc) and ($arr[$i]{"priority"} <= $$hash{"priority"}))
			{
				$i++;
			}
			splice (@arr, $i, 0, @aux);
		}
	}
	
	push @ret, { "service" => \@arr };
	return \@ret;
}


# This function gets the runlevel that is in use
sub gst_service_sysv_get_default_runlevel
{
	my (@arr);
	
	@arr = split / /, `/sbin/runlevel` ;
	$arr[1] =~ s/\n//;
	
	return $arr[1];
}


# THESE ARE THE FUNCTIONS WHICH APPLY THE CHANGES MADE TO THE CONFIGURATION OF THE COMPUTER

sub gst_service_sysv_add_link
{
  my ($runlevel, $action, $priority, $service) = @_;
  my ($prio) = sprintf ("%0.2d",$priority);

  symlink ("$relative_path/$service", "$rcd_path/rc$runlevel.d/$action$prio$service");
  
  &gst_report_enter ();
  &gst_report ("service_sysv_add_link", "$rcd_path/rc$runlevel.d/$action$prio$service");
  &gst_report_leave ();
}

sub gst_service_sysv_remove_link
{
  my ($runlevel, $script) = @_;
	
  foreach $link (<$rcd_path/rc$runlevel.d/[SK][0-9][0-9]$script>)
  {
    &gst_report ("service_sysv_remove_link", "$link");
    unlink ("$link");
    &gst_report_leave ();
  }
}

sub gst_service_sysv_set_service
{
  my ($service) = @_;
  my ($script, $priority, $runlevels);
  my ($action);

  ($rcd_path, $initd_path, $relative_path) = &gst_service_sysv_get_paths ();

  $script = $$service{"script"};
  $priority = $$service{"priority"};
  $runlevels = $$service{"runlevels"}[0]{"runlevel"};

  # pass though all the runlevels checking if the service must be started, stopped or removed
  for ($i = 0; $i <= 6; $i++)
  {
    &gst_service_sysv_remove_link ($i, $script);

    $action = undef;
    foreach $j (@$runlevels)
    {
      if ($i == $$j{"number"})
      {
        $found = 1;
        $action = $$j{"action"};
      }
    }
    if ($action ne undef)
    {
      if ($action eq "start")
      {
        &gst_service_sysv_add_link ($i, "S", $priority, $script);
      }
      else
      {
        &gst_service_sysv_add_link ($i, "K", 100 - $priority, $script);
      }
    }
  }
}

sub gst_service_sysv_set_services
{
	my ($services) = @_;
	
	foreach $i (@$services)
	{
		&gst_service_sysv_set_service($i);
	}
}

sub gst_service_sysv_set_conf
{
  my ($hash) = @_;
  my ($services);
  
  return unless $hash;
  $services = $$hash{"services"}[0]{"service"};
  return unless $services;
  
  &gst_service_sysv_set_services($services);
}

# gets the valid parameters for a service
sub gst_service_get_service_parameters
{
  my ($service_name) = @_;
  my ($rcd_path, $initd_path, $relative_path) = &gst_service_sysv_get_paths ();
  my ($service) = "$initd_path/$service_name";
  my (@arr, @actions, $output, $size);

  # We have to check if the service is executable	
	return undef unless (-x $service);

 	$output = `$service 2>/dev/null`;

	# if the output doesn't have the 'usage' word in it, then isn't a valid output
	return undef unless ($output =~ /usage/i);
	
	@arr = split / /, $output;
	$size = scalar (@arr);
	
	# if the array has 0 rows, the service has no actions
	return undef if ($size eq 0);
	
	$arr[$size-1] =~ s/[\{\}]//g;

	@actions = split /\|/, $arr[size-1];

  return \@actions;	
}
