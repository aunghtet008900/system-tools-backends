#!/usr/bin/env perl
#-*-perl-*-

# Simple networking configurator. Designed to be architecture- and distribution independent.
#
# Copyright (C) 2000 Helix Code, Inc.
#
# Authors: Hans Petter Jansson <hpj@helixcode.com>
#          David Lee Ludwig <davidl@wpi.edu> - Debian 2.[2|3] support.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

# Best viewed with 100 columns of width.

# WARNING: Works with Red Hat (and probably most derivates) and SuSE.
# We're more than happy to receive patches for other distributions.

# Configuration files affected:
#
# /etc/sysconfig/network
# /etc/sysconfig/network-scripts/ifcfg-*
# /etc/rc.config
# /etc/network/interfaces
# /etc/network/options

# Running programs affected/used:
#
# ifup
# ifdown



require "___scriptsdir___/be.pl";



# --- Usage text --- #

my $Usage =<<"End_of_Usage;";
Usage: networking-conf <--get | --set | --filter | --help>
                       [--prefix <location>] [--disable-immediate]
                       [--verbose] [--progress]

       Major operations (specify one of these):

       -g --get      Prints the current networking configuration to
                     standard output, as as standalone XML document. The
                     configuration is read from the host\'s system config
                     files.

       -s --set      Updates the system networking configuration from
                     a standalone XML document read from standard input.
                     The format is the same as for the document generated
                     with --get.

       -f --filter   Reads XML configuration from standard input, parses it,
                     and writes the configurator\'s impression of it back to
                     standard output. Good for debugging and parsing tests.

       -h --help     Prints this page to standard output.

          --version  Prints version information to standard output.

       Modifiers (specify any combination of these):

       -p --prefix <location>  Specifies a directory prefix where the
                     configuration is looked for or stored. When storing
                     (with --set), directories and files may be created.

          --disable-immediate  With --set, prevents the configurator from
                     running any commands that make immediate changes to
                     the system configuration. Use with --prefix to make a
                     dry run that won\'t affect your configuration.

                     With --get, suppresses running of non-vital external
                     programs that might take a long time to finish.

       -v --verbose  Turns on diagnostic messages to standard error.

          --progress Prints progress information suitable for interactive
                     frontends to standard output. The progress information
                     is printed before any XML, and consists of a decimal
                     number saying how many dots to expect, followed by a
                     newline, and a running line of dots as the operation
                     progresses, followed by a newline after the last dot.
                     The dots generated can be more or less than the
                     number indicated on the first line.

End_of_Usage;

$version = "0.1.0";

$progress_max = 5;

# --- System config file locations --- #

# We list each config file type with as many alternate locations as possible.
# They are tried in array order. First found = used.

# Right now there's only one entry per array, as I couldn't find any
# typical deviations.

@sysconfig_network_names = ( "/etc/sysconfig/network" );
@rc_config_names =         ( "/etc/rc.config" );
@network_interfaces_names = ( "/etc/network/interfaces" );
@network_options_names = ( "/etc/network/options" );

# --- Internal configuration variables --- #

# Configuration is parsed/read to, and printed/written from, these temporary variables.

$cf_networking = 0;

$cf_interface = "";
$cf_interface_list = ();
$cf_hostip = "";
$cf_netmask = "";
$cf_gateway = "";
$cf_method = "static";
$cf_onboot = 1;
$cf_forward = 0;


# --- Miscellaneous data-structure accessors --- #

# get_key_for_subkeys
#
# Given:
#   * A hash-table with its values containing references to other hash-tables,
#     which are called "sub-hash-tables".
#   * A list of possible keys (stored as strings), called the "match_list".
# this method will look through the "sub-keys" (the keys of each
# sub-hash-table) seeing if one of them matches up with an item in the
# match_list.  If so, the key will be returned.

sub get_key_for_subkeys
{
  my %hash = %{$_[0]};
  my @match_list = @{$_[1]};

  foreach $key (keys(%hash))
  {
    my %subhash = %{$hash{$key}};
    foreach $item (@match_list)
    {
      if ($subhash{$item} ne "") { return $key; }
    }
  }

  return "";
}

# get_key_for_subkey_and_subvalues
#
# Given:
#   * A hash-table with its values containing references to other hash-tables,
#     which are called "sub-hash-tables".  These sub-hash-tables contain
#     "sub-keys" with associated "sub-values".
#   * A sub-key, called the "match_key".
#   * A list of possible sub-values, called the "match_list".
# this function will look through each sub-hash-table looking for an entry
# whose:
#   * sub-key equals match_key.
#   * sub-key associated sub-value is contained in the match_list.

sub get_key_for_subkey_and_subvalues
{
  my %hash = %{$_[0]};
  my $key;
  my $match_key = $_[1];
  my @match_list = @{$_[2]};

  foreach $key (keys(%hash))
  {
    my %subhash = %{$hash{$key}};
    my $subvalue = $subhash{$match_key};

    if ($subvalue eq "") { next; }

    foreach $item (@match_list)
    {
      if ($item eq $subvalue) { return $key; }
    }
  }

  return "";
}


# is_in_list
#
# Given:
#   * A scalar value.
#   * An array.
# this function will return 1 if the scalar value is in the array, 0 otherwise.

sub is_in_list
{
  my $value = shift(@_);

  foreach my $item (@_)
  {
    if ( $value eq $item ) { return 1; }
  }

  return 0;
}


# --- Configuration file manipulation --- #

# Debian 2.[2|3]+ style /etc/network/interfaces
#
# <filtered lines>
# iface <interface> inet <static|dhcp|bootp|ppp>
#     address <ip>
#     netmask <ip mask>
#     gateway <gateway ip>
#     broadcast <broadcast ip>
#     network <network ip>
#     noauto (this is only used to not enable the interface on boot)
#     up <command to run when the interface is brought up>
#     down <command to run when the interface is brought down>
# <filtered lines>
# (more interfaces may follow)
#
# A "#" character at the very beginning of a line causes that line to be
# treated as a comment.
# A "\" character at the very end of a line causes that line to continue onto
# the next line.
#
# read_network_interfaces_into_hash will read the contents of
# /etc/network/interfaces into a hash table of references to hash tables.  For
# example:
#
# %ifaces = ("eth0" => {"method" => "dhcp"},
#            "eth1" => {"method" => "static",
#                       "address" => "192.168.0.42",
#                       "netmask" => "255.255.255.0"});
#
# The resulting hash table, %ifaces, is returned.
#
# NOTE: For more information on the format of /etc/network/interfaces, read
# the "interfaces" man page (section 5).  Also be sure to look at the example
# file in /usr/share/doc/netbase/examples/interfaces.  Both of these are
# included as part of the "netbase" package in Debian 2.[2|3].
#
# Exists: Debian 2.[2|3]
#
# Absent:

sub read_network_interfaces_into_hash
{
  local *FILE;
  my (%ifaces, $current_name, $current_iface);

  *FILE = be_open_read_from_names(@network_interfaces_names);
  if (not *FILE) { return; }

  # Build a list of all interfaces
  while (<FILE>)
  {
    # Split the current line into a list of tokens.
    @line = split(/[ \n\r\t]+/, $_);

    # Remove leading whitespace.
    if ($line[0] eq "") { shift(@line); }

    # Check to see if this line continues onto other lines.  If so, append
    # them
    while ($line[$#line] eq "\\")
    {
      # Remove the \ character.
      pop @line;

      # Read in the next line and split it into a list of tokens.
      @nextline = split(/[ \n\r\t]+/, <FILE>);

      # Remove any leading whitepage.
      if ($nextline[0] eq "") { shift(@nextline); }

      # Append @nextline to the end of @line
      push @line, @nextline;
    }

    # Make sure this line isn't a comment.
    if (be_is_line_comment_start($line[0])) { next; }

    # Check if the line specifies a new interface.
    if ($line[0] eq "iface" && not be_is_line_comment_start($line[1]))
    {
      # Make sure the device was detected via ifconfig (see "get_immediate").
      # NOTE: This will weed out any loopback or dummy interfaces.
      if (not is_in_list($line[1], @cf_interface_list))
      {
        if ($verbose) { print STDERR "Warning: $line[1] isn't an available, " .
                            "configured interface.\n"; }
        next;
      }

      # Make sure the interface is set up for IPv4/internet networking
      if ($line[2] ne "inet") { next; }

      # Also make sure there is a set configuration method.
      if ($line[3] eq "" || be_is_line_comment_start($line[3]))
      {
        if ($verbose) { print STDERR "Warning: Interface $line[1] has no " .
                            "config method.\n"; }
        next;
      }

      # Create a new hash table for this interface.
      my %iface_hash = ();

      # Set this interface to be the 'current' one.
      $current_name = $line[1];
      $current_iface = $ifaces{$current_name} = \%iface_hash;

      # Set the interface's method
      $$current_iface{"method"} = $line[3];
    }
    else  # Add an attribute to an already set interface.
    {
      # Make sure an interface has been set.
      if (not $current_iface) { next; }

      # Make sure the attribute has been properly set
      if (not $line[1]) { next; }

      # Set the attribute
      $$current_iface{$line[0]} = join(' ', $line[1..$#line]);
    }
  }

  # All done.  Clean up before returning.
  close($FILE);

  return %ifaces;
}


# Debian 2.[2|3]+ style /etc/network/interfaces
#
# (See 'read_network_interfaces_into_hash()' for information on
# /etc/network/interfaces as well as the structure of %ifaces.
#
# Takes network interface information and places them into the correct
# variables.
#
# Exists: Debian 2.[2|3]
#
# Absent:

sub read_network_interfaces
{
  my (%ifaces, $current_name, $current_iface);
  my $chosen_name;

  %ifaces = read_network_interfaces_into_hash();

  # Now, a "primary" interface will be selected.  The selection order is as
  # follows:
  #
  # * If only one interface exists, use that one.
  # * If an interface has a preset gateway, use that one.
  # * The first interface with a dynamic configuration "method" (such as "dhcp",
  #   "bootp", "ppp", etc.) will be selected.
  # * If all else fails, pick the first interface.

  # See if only one interface exists.
  if ( scalar(keys(%ifaces)) == 1 )
  {
    $chosen_name = (keys(%ifaces))[0];

    if ( $verbose )
    { print STDERR "Only one interface, $chosen_name, exists.  It is being " .
          "selected as the \"primary\" interface.\n"; }
  }

  # For that matter, do any interfaces exist at all.
  elsif ( scalar(keys(%ifaces)) == 0 )
  {
    if ($verbose) { print STDERR "Warning: No interfaces found!\n"; }
    return;
  }

  else
  {
    # Look for an interface with a preset gateway.
    $chosen_name = get_key_for_subkeys(\%ifaces, ["gateway"]);

    # If need be, look for an interface with a dynamic configuration "method".
    if ( $chosen_name eq "" )
    {
      $chosen_name = get_key_for_subkey_and_subvalues(\%ifaces, "method", ["dhcp", "bootp", "ppp"]);
    }

    # If an interface hasn't been chosen, then just pick the first available one.
    if ( $chosen_name eq "" )
    {
      $chosen_name = (keys(%ifaces))[0];
    }
  }

  # Now that a "primary" interface has been chosen, set the proper global
  # variables.
  %current_iface = %{$ifaces{$chosen_name}};

  $cf_interface = $chosen_name;
  $cf_hostip = $current_iface{"address"};
  $cf_netmask = $current_iface{"netmask"};
  $cf_gateway = $current_iface{"gateway"};
  $cf_method = $current_iface{"method"};
  if ( exists $current_iface{"noauto"} ) { $cf_onboot = 0; }
  else { $cf_onboot = 1; }
}


sub write_network_interfaces
{
  my $INFILE;
  my $OUTFILE;

  my $wrote_interface;
  my $wrote_hostip;
  my $wrote_netmask;
  my $wrote_gateway;
  my $wrote_onboot;
  my $wrote_network;
  my $wrote_broadcast;

  my $output_line;
  my @iface_lines;
  my @post_lines;
  my $use_post;

  my $cfl_network = "";
  my $cfl_broadcast = "";

  # Find and open the needed files.
  ($INFILE, $OUTFILE) = open_filter_write_from_names(@network_interfaces_names);
  if (not OUTFILE) { return; }  # No point if we can't write.

  # Generate $cfl_network and $cfl_broadcast
  $cfl_network = ip_calc_network($cf_hostip, $cf_netmask);
  $cfl_broadcast = ip_calc_broadcast($cf_hostip, $cf_netmask);

  # Write the file, preserving as much as possible from INFILE.
  while (<INFILE>)
  {
    # Split the current line into a list of tokens.
    @line = split(/[ \n\r\t]+/, $_);

    # Remove leading whitespace.
    if ($line[0] eq "") { shift(@line); }

    # Check to see if this line continues onto other lines.  If so, append
    # them.
    while ($line[$#line] eq "\\")
    {
      # Remove the \ character.
      pop @line;

      # Read in the next line and split it into a list of tokens.
      @nextline = split(/[ \n\r\t]+/, <INFILE>);

      # Remove any leading whitepage.
      if ($nextline[0] eq "") { shift(@nextline); }

      # Append @nextline to the end of @line
      push @line, @nextline;
    }

    # Check if a new interface is being defined.  If so and it's the primary
    # interface (as defined in $cf_interface), then we can start writing to
    # OUTFILE.
    if ($line[0] eq "iface")
    {
      if ($line[1] eq $cf_interface)
      {
        $current_name = $line[1];
        print OUTFILE "iface $cf_interface inet $cf_method\n";
        $wrote_interface = 1;

        next;
      }
      elsif ($current_name ne "")
      {
        $current_name = "";

        # From now on, any lines read in from INFILE will be placed in a buffer
        # called @post_lines.  These will be written to OUTFILE at a later
        # time.
        $use_post = 1;
      }
    }

    # Check to see if we're parsing through the primary interface's predefined
    # section.  If so, push wanted lines into @iface_lines (these will
    # eventually be sent to OUTFILE.)
    if ($current_name ne "")
    {
      if ($line[0] eq "address")
      {
        if ($cf_hostip ne "")
        {
          push @iface_lines, "    address $cf_hostip\n";
        }
        $wrote_hostip = 1;
      }
      elsif ($line[0] eq "netmask")
      {
        if ($cf_netmask ne "")
        {
          push @iface_lines, "    netmask $cf_netmask\n";
        }
        $wrote_netmask = 1;
      }
      elsif ($line[0] eq "gateway")
      {
        if ($cf_gateway ne "")
        {
          push @iface_lines, "    gateway $cf_gateway\n";
        }
        $wrote_gateway = 1;
      }
      elsif ($line[0] eq "onboot")
      {
        push @iface_lines, "    noauto\n";
        $wrote_onboot = 1;
      }
      elsif ($line[0] eq "network")
      {
        if ($cfl_network ne "")
        {
          push @iface_lines, "    network $cfl_network\n";
        }
        $wrote_network = 1;
      }
      elsif ($line[0] eq "broadcast")
      {
        if ($cfl_broadcast ne "")
        {
          push @iface_lines, "    broadcast $cfl_broadcast\n";
        }
        $wrote_broadcast = 1;
      }
      else
      {
        push @iface_lines, $_;
      }
    }
    else
    {
      if (not $use_post)
      {
        print OUTFILE;
      }
      else
      {
        push @post_lines, $_;
      }
    }
  }

  # Make sure that unwritten, non-empty variables are written to OUTFILE.
  if (not $wrote_interface)
  { print OUTFILE "iface $cf_interface inet $cf_method\n"; }

  if ((not $wrote_hostip) && ($cf_hostip ne ""))
  { print OUTFILE "    address $cf_hostip\n"; }

  if ((not $wrote_netmask) && ($cf_netmask ne ""))
  { print OUTFILE "    netmask $cf_netmask\n"; }

  if ((not $wrote_gateway) && ($cf_gateway ne ""))
  { print OUTFILE "    gateway $cf_gateway\n"; }

  if ((not $wrote_onboot) && ($cf_onboot eq 0))
  { print OUTFILE "    noauto\n"; }

  if ((not $wrote_network) && ($cfl_network ne ""))
  { print OUTFILE "    network $cfl_network\n"; }

  if ((not $wrote_broadcast) && ($cfl_broadcast ne ""))
  { print OUTFILE "    broadcast $cfl_broadcast\n"; }

  # Output all the rest of the lines which relate to the primary interface.
  if (($#iface_lines + 1) > 0)
  {
    foreach $output_line (@iface_lines)
    {
      print OUTFILE "$output_line";
    }
  }

  # Output any additional, preexisting interfaces.
  if (($#post_lines + 1) > 0)
  {
    foreach $output_line (@post_lines)
    {
      print OUTFILE "$output_line";
    }
  }

  # All done.  Clean up before returning.
  close(OUTFILE);
  if (*INFILE) { close(INFILE); }
}


# Debian 2.[2|3] style /etc/network/options
#
# <filtered lines>
# ip_forward=<yes|no>
# spoofprotect=<yes|no>
# syncookies=<yes|no>
# <filtered lines>
#
# Reads in relevant network options that aren't found in
# /etc/network/interfaces.  NOTE: None of these options are interface specific.
#
# Exists: Debian 2.[2|3]
#
# Absent:

sub read_network_options
{
  local *FILE;

  *FILE = be_open_read_from_names(@network_options_names);
  if (not *FILE) { return; }

  # Build a list of all interfaces
  while (<FILE>)
  {
    # Split the current line into a list of tokens.
    @line = split(/[ \n\r\t=]+/, $_);

    # Remove leading whitespace.
    if ($line[0] eq "") { shift(@line); }

    # Make sure this line isn't a comment;
    if (be_is_line_comment_start($line[0])) { next; }

    # Set any relevant global configuration variables.
    if ($line[0] eq "ip_forward" && not be_is_line_comment_start($line[1]))
    { $cf_forward = be_read_boolean($line[1]); }
  }

  # All done.  Clean up before returning.
  close(FILE);
}


sub write_network_options
{
  my $INFILE;
  my $OUTFILE;
  my $wrote_forward;

  ($INFILE, $OUTFILE) = open_filter_write_from_names(@network_options_names);
  if (not OUTFILE) { return; }  # No point if we can't write.

  # Write the file, preserving as much as possible from INFILE.
  while (<INFILE>)
  {
    # Split the current line into a list of tokens.
    @line = split(/[ \n\r\t=]+/, $_);

    # Remove leading whitespace.
    if ($line[0] eq "") { shift(@line); }

    # Modify and write-out any known variables.
    if ($line[0] eq "ip_forward")
    {
      print OUTFILE "ip_forward=" . print_boolean_yesno($cf_forward) . "\n";
      $wrote_forward = 1;
    }
    else { print OUTFILE; }
  }

  # Make sure that unwritten, non-empty variables are written to OUTFILE.
  if (not $wrote_forward)
  { print OUTFILE "ip_forward=" . print_boolean_yesno($cf_forward) . "\n"; }

  # All done.  Clean up before returning.
  close (OUTFILE);
  if (*INFILE) { close(INFILE); }
}


# Red Hat style /etc/sysconfig/network-scripts/ifcfg-*
#
# <filtered lines>
# IPADDR=<ip>
# NETMASK=<ip mask>
# NETWORK=<network ip>
# BROADCAST=<broadcast ip>
# BOOTPROTO=<bootp|dhcp|none>
# ONBOOT=<boolean>
# <filtered lines>
#
# Determines the configuration of a specific network interface. First
# argument must be the name of the interface.
#
# Exists: Red Hat [5|6].x
#
# Absent:

sub read_sysconfig_network_scripts_ifcfg
{
  local *FILE;

  # Find the file.

  *FILE = be_open_read_from_names("/etc/sysconfig/network-scripts/ifcfg-$_[0]");
  if (not *FILE) { return; }

  # Parse the file.

  while (<FILE>)
  {
    @line = split(/[ \n\r\t\"\'=]+/, $_);
    if ($line[0] eq "") { shift(@line); }  # Leading whitespace. He.

    if ($line[0] eq "IPADDR" && not be_is_line_comment_start($line[1]))
    { $cf_hostip = $line[1]; }
    elsif ($line[0] eq "NETMASK" && not be_is_line_comment_start($line[1]))
    { $cf_netmask = $line[1]; }
    elsif ($line[0] eq "BOOTPROTO" && not be_is_line_comment_start($line[1]))
    {
      if ($line[1] eq "bootp")   { $cf_method = "bootp"; }
      elsif ($line[1] eq "dhcp") { $cf_method = "dhcp"; }
      else                       { $cf_method = "static"; }
    }
    elsif ($line[0] eq "ONBOOT" && not be_is_line_comment_start($line[1]))
    { $cf_onboot = be_read_boolean($line[1]); }
  }

  close(FILE);
}


sub write_sysconfig_network_scripts_ifcfg
{
  my $INFILE;
  my $OUTFILE;
  my $wrote_hostip = 0;
  my $wrote_netmask = 0;
  my $wrote_network = 0;
  my $wrote_broadcast = 0;
  my $wrote_method = 0;
  my $wrote_onboot = 0;
  my $cfl_network = "";
  my $cfl_broadcast = "";

  # Find the file.

  ($INFILE, $OUTFILE) = open_filter_write_from_names("/etc/sysconfig/network-scripts/ifcfg-$_[0]");
  if (not OUTFILE) { return; }  # No point if we can't write.

  # Generate $cfl_network and $cfl_broadcast.

  $cfl_network = ip_calc_network($cf_hostip, $cf_netmask);
  $cfl_broadcast = ip_calc_broadcast($cf_hostip, $cf_netmask);

  # Write the file, preserving as much as possible from INFILE.

  while (<INFILE>)
  {
    @line = split(/[ \n\r\t\"\'=]+/, $_);
    if ($line[0] eq "") { shift(@line); }  # Leading whitespace. He.

    if ($line[0] eq "IPADDR")
    {
      print OUTFILE "IPADDR=$cf_hostip\n";
      $wrote_hostip = 1;
    }
    elsif ($line[0] eq "NETMASK")
    {
      print OUTFILE "NETMASK=$cf_netmask\n";
      $wrote_netmask = 1;
    }
    elsif ($line[0] eq "NETWORK")
    {
      print OUTFILE "NETWORK=$cfl_network\n";
      $wrote_network = 1;
    }
    elsif ($line[0] eq "BROADCAST")
    {
      print OUTFILE "BROADCAST=$cfl_broadcast\n";
      $wrote_broadcast = 1;
    }
    elsif ($line[0] eq "BOOTPROTO")
    {
      print OUTFILE "BOOTPROTO=$cf_method\n";
      $wrote_method = 1;
    }
    elsif ($line[0] eq "ONBOOT")
    {
      print OUTFILE join('', "ONBOOT=", print_boolean_yesno($cf_onboot), "\n");
      $wrote_onboot = 1;
    }
    else { print OUTFILE; }
  }

  if (not $wrote_hostip)    { print OUTFILE "IPADDR=$cf_hostip\n"; }
  if (not $wrote_netmask)   { print OUTFILE "NETMASK=$cf_netmask\n"; }
  if (not $wrote_network)   { print OUTFILE "NETWORK=$cfl_network\n"; }
  if (not $wrote_broadcast) { print OUTFILE "BROADCAST=$cfl_broadcast\n"; }
  if (not $wrote_method)    { print OUTFILE "BOOTPROTO=$cf_method\n"; }
  if (not $wrote_onboot)    { print OUTFILE join('', "ONBOOT=", print_boolean_yesno($cf_onboot), "\n"); }

  close(OUTFILE);
  if (*INFILE) { close(INFILE); }
}


# Red Hat style primary interface reader.
#
# Tries to figure out what the "primary" interface is, and calls
# read_sysconfig_network_scripts_ifcfg on that interface.
#
# Must run after get_immediate and read_sysconfig_network, which will
# (hopefully) provide information to identify the primary device.

sub read_primary_interface
{
  # If the interface was specified, we use that.

  if ($cf_interface ne "") { }

  # If the known-interfaces list contains only one interface, we use that.
  # This is actually not too uncommon, after weeding lo and dummy.

  elsif ($#cf_interface_list == 0) { $cf_interface = $cf_interface_list[0]; }
  
  # If we have a gateway, try to find an interface with a matching subnet, by
  # going through the interface configurations. This will fail if a gateway
  # has been configured without any interfaces, or if the gateway is on a
  # foreign, bridged subnet. Both are pretty rare conditions.

  elsif ($cf_gateway ne "")
  {
    for $elem (@cf_interface_list)
    {
      read_sysconfig_network_scripts_ifcfg($elem);
      if ($cf_netmask eq "") { next; }

      if (ip_calc_network($cf_gateway, $cf_netmask) eq ip_calc_network($cf_hostip, $cf_netmask))
      {
        $cf_interface = $elem;
	last;
      }

      $cf_hostip = "";
      $cf_netmask = "";
      $cf_method = "";
      $cf_onboot = 0;
    }
  }

  # Last ditch. Pick an interface from the list according to some built-in
  # rules.

  else
  {
    for $elem (@cf_interface_list)
    {
      if (($elem =~ /eth.*/) || ($elem =~ /hme.*/))
      {
        $cf_interface = $elem;
        last;
      }
    }
  }

  if ($cf_interface ne "") { read_sysconfig_network_scripts_ifcfg($cf_interface); }
}


sub write_primary_interface
{
  # If the primary interface is not supplied, we can't assume anything,
  # so configuration is not written.

  if ($cf_interface ne "") { write_sysconfig_network_scripts_ifcfg($cf_interface); }
  elsif ($verbose) { print STDERR "Warning: No primary interface specified - config unwritten.\n"; }
}


# Red Hat style /etc/sysconfig/network
#
# <filtered lines>
# NETWORKING=<boolean>
# FORWARD_IPV4=<boolean>
# GATEWAY=<ip>
# GATEWAYDEV=<interface>
# <filtered lines>
#
# Determines the primary network configuration. BEWARE: This is actually a
# sourced shell script. We rely on some lenience from the user (and the distro)
# to be able to parse it correctly.
#
# Exists: Red Hat [5|6].x, Caldera 2.4, TurboLinux 6.0, Mandrake 7.0
#
# Absent: SuSE 6.3, SunOS 5.7

sub read_sysconfig_network
{
  local *FILE;

  # Find the file.

  *FILE = be_open_read_from_names(@sysconfig_network_names);
  if (not *FILE) { return; }  # We didn't find it.

  # Parse the file.

  while (<FILE>)
  {
    @line = split(/[ \n\r\t\"\'=]+/, $_);
    if ($line[0] eq "") { shift(@line); }  # Leading whitespace. He.

    if ($line[0] eq "NETWORKING" && not be_is_line_comment_start($line[1]))
    { $cf_networking = be_read_boolean($line[1]); }
    elsif ($line[0] eq "FORWARD_IPV4" && not be_is_line_comment_start($line[1]))
    { $cf_forward = be_read_boolean($line[1]); }
    elsif ($line[0] eq "GATEWAY" && not be_is_line_comment_start($line[1]))
    { $cf_gateway = $line[1]; }
    elsif ($line[0] eq "GATEWAYDEV" && not be_is_line_comment_start($line[1]))
    { $cf_interface = $line[1]; }
  }

  close(FILE);
}


sub write_sysconfig_network
{
  my $INFILE;
  my $OUTFILE;
  my $wrote_networking = 0;
  my $wrote_forward = 0;
  my $wrote_gateway = 0;
  my $wrote_interface = 0;

  # Find the file.

  ($INFILE, $OUTFILE) = open_filter_write_from_names(@sysconfig_network_names);
  if (not OUTFILE) { return; }  # No point if we can't write.

  # Write the file, preserving as much as possible from INFILE.

  while (<INFILE>)
  {
    @line = split(/[ \n\r\t\"\'=]+/, $_);
    if ($line[0] eq "") { shift(@line); }  # Leading whitespace. He.

    if ($line[0] eq "NETWORKING")
    {
      print OUTFILE join('', "NETWORKING=", print_boolean_yesno($cf_networking), "\n");
      $wrote_networking = 1;
    }
    elsif ($line[0] eq "FORWARD_IPV4")
    {
      print OUTFILE join('', "FORWARD_IPV4=", print_boolean_truefalse($cf_forward), "\n");
      $wrote_forward = 1;
    }
    elsif ($line[0] eq "GATEWAY")
    {
      print OUTFILE "GATEWAY=$cf_gateway\n";
      $wrote_gateway = 1;
    }
    elsif ($line[0] eq "GATEWAYDEV")
    {
      print OUTFILE "GATEWAYDEV=$cf_interface\n";
      $wrote_interface = 1;
    }
    else { print OUTFILE; }
  }

  if (not $wrote_networking)
  { print OUTFILE join('', "NETWORKING=", print_boolean_yesno($cf_networking), "\n"); }
  if (not $wrote_forward)
  { print OUTFILE join('', "FORWARD_IPV4=", print_boolean_truefalse($cf_forward), "\n"); }
  if (not $wrote_gateway)
  { print OUTFILE "GATEWAY=$cf_gateway\n"; }
  if (not $wrote_interface)
  { print OUTFILE "GATEWAYDEV=$cf_interface\n"; }

  close(OUTFILE);
  if (*INFILE) { close(INFILE); }
}


# SuSE style /etc/rc.config
#
# <filtered lines>
# FQHOSTNAME="<fully qualified hostname>"
# SEARCHLIST="<space separated list of searchdomains>"
# NAMESERVER="<space separated list of nameservers>"
# <filtered lines>
#
# Determines the local hostname.domain, searchdomains and nameservers.
# BEWARE: This is actually a sourced shell script. We rely on some lenience
# from the user (and the distro) to be able to parse it correctly. The file
# is read by SuSE configuration tools and translated to NET-3 config files
# at strategic times.
#
# Exists: SuSE 6.3
#
# Absent: Red Hat 6.x, Caldera 2.4, TurboLinux 6.0, Mandrake 7.0, SunOS 5.7

sub read_rc_config
{
  local *FILE;

  # Find the file.

  *FILE = be_open_read_from_names(@rc_config_names);
  if (not *FILE) { return; }  # We didn't find it.

  # Parse the file.

  while (<FILE>)
  {
    @line = split(/[ \n\r\t\"\'=]+/, $_);  # Handles quoted arguments.
    if ($line[0] eq "") { shift(@line); }  # Leading whitespace. He.

    if ($line[0] eq "NETDEV_0" && not be_is_line_comment_start($line[1]))
    {
      $cf_interface = $line[1];
    }
    elsif ($line[0] eq "IPADDR_0")
    {
      $cf_hostip = $line[1];
    }
    elsif ($line[0] eq "IFCONFIG_0")
    {
      shift @line;

      while (@line)
      {
        if (be_is_line_comment_start($line[0])) { last; }
	
	if ($line[0] eq "broadcast")
	{
	  # Calculate this ourselves.

	  shift @line;
	  shift @line;
	}
	elsif ($line[0] eq "netmask")
	{
	  $cf_netmask = $line[1];
	  shift @line;
	  shift @line;
	}
	elsif ($line[0] eq "bootp")
	{
	  $cf_method = "bootp";
	  last;
	}
	elsif ($line[0] =~ /dhcp.*/)
	{
	  $cf_method = "dhcp";
	  last;
	}
        elsif ($line[0] ne "") { $cf_hostip = $line[0]; shift @line; }
	else { shift @line; }
      }
    }
  }

  close(FILE);
}


# SuSE /etc/rc.config likes all env arguments in double quotes. Since we're
# really nice guys, we conform to that.

sub write_rc_config
{
  my $INFILE;
  my $OUTFILE;
  my $wrote_ipaddr = 0;
  my $wrote_netdev = 0;
  my $wrote_ifconfig = 0;
  my $cfl_broadcast = "";

  # Find the file.

  ($INFILE, $OUTFILE) = open_filter_write_from_names(@rc_config_names);
  if (not OUTFILE) { return; }  # No point if we can't write.

  # Generate broadcast address.
  
  $cfl_broadcast = ip_calc_broadcast($cf_hostip, $cf_netmask);

  # Write the file, preserving as much as possible from INFILE.

  while (<INFILE>)
  {
    @line = split(/[ \n\r\t\"\'=]+/, $_);
    if ($line[0] eq "IPADDR_0")
    {
      print OUTFILE "IPADDR_0=\"$cf_hostip\"\n";
      $wrote_ipaddr = 1;
    }
    elsif ($line[0] eq "NETDEV_0")
    {
      print OUTFILE "NETDEV_0=\"$cf_interface\"\n";
      $wrote_netdev = 1;
    }
    elsif ($line[0] eq "IFCONFIG_0")
    {
      if ($cf_method eq "dhcp") { print OUTFILE "IFCONFIG_0=\"dhcpclient\"\n"; }
      elsif ($cf_method eq "bootp") { print OUTFILE "IFCONFIG_0=\"bootp\"\n"; }
      else { print OUTFILE "IFCONFIG_0=\"$cf_hostip broadcast $cfl_broadcast netmask $cf_netmask\"\n"; }
      $wrote_ifconfig = 1;
    }
    else
    {
      print OUTFILE;
    }
  }

  if (not $wrote_ipaddr)   { print OUTFILE "IPADDR_0=\"$cf_hostip\"\n"; }
  if (not $wrote_netdev)   { print OUTFILE "NETDEV_0=\"$cf_interface\"\n"; }
  if (not $wrote_ifconfig)
  {
    if ($cf_method eq "dhcp") { print OUTFILE "IFCONFIG_0=\"dhcpclient\"\n"; }
    elsif ($cf_method eq "bootp") { print OUTFILE "IFCONFIG_0=\"bootp\"\n"; }
    else { print OUTFILE "IFCONFIG_0=\"$cf_hostip broadcast $cfl_broadcast netmask $cf_netmask\"\n"; }
  }

  close(OUTFILE);
  if (*INFILE) { close(INFILE); }
}


# --- XML printing --- #


sub xml_print
{
  my $cfl_interface = be_xml_plain_to_entities(\$cf_interface);
  my $cfl_hostip = be_xml_plain_to_entities(\$cf_hostip);
  my $cfl_netmask = be_xml_plain_to_entities(\$cf_netmask);
  my $cfl_gateway = be_xml_plain_to_entities(\$cf_gateway);
  my $cfl_method = be_xml_plain_to_entities(\$cf_method);

  print "<?xml version='1.0' encoding='ISO-8859-1' standalone='yes'?>\n";
  print "<!DOCTYPE networking []>\n\n";
  print "<networking>\n";
  be_xml_enter ();

  be_xml_vspace ();
  be_xml_indent (); print "<!-- Configuration starts here -->\n";
  be_xml_vspace ();

  # Hostname, domain, search domains, nameservers.

  be_xml_indent ();
  if ($cf_onboot) { print "<enabled state='yes'/>\n"; }
  else            { print "<enabled state='no'/>\n"; }

  be_xml_vspace ();

  if ($cfl_interface ne "") { be_xml_indent (); print "<primaryinterface>$cfl_interface</primaryinterface>\n"; }
  if ($cfl_hostip ne "") { be_xml_indent (); print "<hostip>$cfl_hostip</hostip>\n"; }
  if ($cfl_netmask ne "") { be_xml_indent (); print "<netmask>$cfl_netmask</netmask>\n"; }
  if ($cfl_gateway ne "") { be_xml_indent (); print "<gateway>$cfl_gateway</gateway>\n"; }
  be_xml_vspace ();
  if ($cfl_method ne "") { be_xml_indent (); print "<method>$cfl_method</method>\n"; }
  be_xml_vspace ();

  be_xml_vspace ();
  be_xml_indent (); print "<!-- You shouldn't have to modify anything below this line -->\n";
  be_xml_vspace ();

  be_xml_indent (); 
  if ($cf_forward) { print "<forward state='yes'/>\n"; }
  else             { print "<forward state='no'/>\n"; }

  be_xml_vspace ();
  be_xml_indent (); print "<!-- You cannot modify anything below this line -->\n";
  be_xml_vspace ();

  for $elem (@cf_interface_list)
  {
    $elem = be_xml_plain_to_entities(\$elem);
    if ($elem ne $cfl_interface)  # Hack: Don't list primary interface here.
    { be_xml_indent (); print "<knowninterface>$elem</knowninterface>\n"; }
  }

  be_xml_vspace ();
  be_xml_indent (); print "<!-- End of configuration -->\n";
  be_xml_vspace ();

  be_xml_leave ();
  print "</networking>\n";
}


# --- Get (read) config --- #


sub get_immediate
{
  my $if_cmd;
  my $iftext;
  my @list;

  # Get a list of all interfaces, both configured and unconfigured.
  # Should work on both GNU and Solaris.

  $if_cmd = be_locate_tool("ifconfig");
  $iftext = `$if_cmd -a 2>/dev/null`;

  @list = ($iftext =~ /^([a-z0-9]+)[ :\t].*/mg);

  if (not @list)
  {
    if ($be_verbose) { print STDERR "Warning: Couldn't find any network devices.\n"; }
    return(0);
  }
  
  # Remove loopback and dummy interfaces from the list.
  
  for $elem (@list)
  {
    if (!($elem =~ /^(lo)|(dummy).*/)) { push(@cf_interface_list, $elem); }
  }
}


sub get
{
  if ($be_progress) { $| = 1; print $progress_max . "\n"; }

  if ($be_verbose) { print STDERR "Getting system configuration, generating XML output.\n"; }

  if ($be_verbose) { print STDERR "Finding interfaces.\n"; }
  get_immediate;

  read_rc_config; be_print_progress ();
  read_sysconfig_network; be_print_progress ();
  read_network_interfaces; be_print_progress ();
  read_network_options; be_print_progress ();
  read_primary_interface; be_print_progress ();

  if ($be_verbose) { print STDERR "Printing XML.\n"; }
  if ($be_progress) { print "\n"; }
  xml_print ();
}


# --- Set (write) config --- #


sub set_immediate
{
  my $ifup_cmd;
  my $ifdown_cmd;
  
  $ifup_cmd = be_locate_tool("ifup");
  $ifdown_cmd = be_locate_tool("ifdown");
  
  # Restart primary interface, so configuration can take effect.

  if ($ifup_cmd ne "" && $ifdown_cmd ne "")
  {
    # Found ifup and ifdown utilities.

    if ($cf_interface ne "")
    {
      if (!(system "$ifdown_cmd $cf_interface >/dev/null 2>/dev/null" &&
            system "$ifup_cmd $cf_interface >/dev/null 2>/dev/null"))
      {
        if ($be_verbose) { print STDERR "Warning: Could not configure interface. Are you root?\n"; }
      }
      elsif ($be_verbose)
      {
        print STDERR "Primary interface configured.\n";
      }
    }
    elsif ($be_verbose)
    {
      print STDERR "Warning: No primary interface given.\n";
    }
  }
  elsif ($be_verbose)
  {
    print STDERR "Warning: No interface control utilities found.\n";
  }
}


sub set
{
  if ($be_verbose) { print STDERR "Setting system configuration from XML input.\n"; }

  if ($be_verbose) { print STDERR "Parsing XML.\n"; }
  be_xml_parse ();

  $cf_networking = 1;  # This should really be calculated from the old value
                       # and $cf_onboot. This hack will make it work, possibly
                       # with a few extra boot messages, if the user doesn't
                       # have a network.

  write_rc_config;
  write_sysconfig_network;
  write_network_interfaces;
  write_network_options;
  write_primary_interface;

  if ($be_do_immediate)
  {
    if ($be_verbose) { print STDERR "Changing running configuration via local utilities.\n"; }
    set_immediate;
  }
}


# --- Filter config: XML in, XML out --- #


sub filter
{
  be_xml_parse ();
  xml_print ();
}


# --- Main --- #

# Process options.

while (@ARGV)
{
  if    ($ARGV[0] eq "--get"    || $ARGV[0] eq "-g") { be_set_operation("get"); }
  elsif ($ARGV[0] eq "--set"    || $ARGV[0] eq "-s") { be_set_operation("set"); }
  elsif ($ARGV[0] eq "--filter" || $ARGV[0] eq "-f") { be_set_operation("filter"); }
  elsif ($ARGV[0] eq "--help"   || $ARGV[0] eq "-h") { print $Usage; exit(0); }
  elsif ($ARGV[0] eq "--version")                    { print "$version\n"; exit(0); }
  elsif ($ARGV[0] eq "--prefix" || $ARGV[0] eq "-p")
  {
    if ($be_prefix ne "")
    {
      print STDERR "Error: You may specify --prefix only once.\n\n";
      print STDERR $Usage; exit(1);
    }

    $be_prefix = $ARGV[1];

    if ($be_prefix eq "")
    {
      print STDERR "Error: You must specify an argument to the --prefix option.\n\n";
      print STDERR $Usage; exit(1);
    }

    shift @ARGV;  # For the argument.
  }
  elsif ($ARGV[0] eq "--disable-immediate")           { $be_do_immediate = 0; }
  elsif ($ARGV[0] eq "--verbose" || $ARGV[0] eq "-v") { $be_verbose = 1; }
  elsif ($ARGV[0] eq "--progress")                    { $be_progress = 1; }
  else
  {
    print STDERR "Error: Unrecognized option '$ARGV[0]'.\n\n";
    print STDERR $Usage; exit(1);
  }

  shift @ARGV;
}


# Do our thing.

if    ($be_operation eq "get")    { get; }
elsif ($be_operation eq "set")    { set; }
elsif ($be_operation eq "filter") { filter; }
else
{
  print STDERR "Error: No operation specified.\n\n";
  print STDERR $Usage; exit(1);
}

