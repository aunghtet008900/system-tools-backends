#!/usr/bin/env perl
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-

# Boot manager configurator. Designed to be architecture and distribution independent.
#
# Copyright (C) 2000-2001 Ximian, Inc.
#
# Authors: Tambet Ingo <tambet@ximian.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.


require "___scriptsdir___/general.pl";
require "___scriptsdir___/util.pl";
require "___scriptsdir___/file.pl";
require "___scriptsdir___/xml.pl";
require "___scriptsdir___/parse.pl";
require "___scriptsdir___/replace.pl";


sub xst_boot_parse_global_kw
{
  my ($file, $key) = @_;
  my $fd;

  $fd = &xst_file_open_read_from_names ($file);

  while (<$fd>)
  {
    chomp;
    s/^[ \t]+//;
    next if (/^\#/ || /^$/);
    last if (/^(image|other)/);

    if ($key eq $_)
    {
      close $fd;
      return 1;
    }
  }

  close $fd;
  return undef;
}


sub xst_boot_parse_global
{
  my ($file, $key) = @_;
  my ($fd, @line, $re);

  $re = "[ \t]*=[ \t]*";
  $fd = &xst_file_open_read_from_names ($file);

  while (($line = <$fd>))
  {
    chomp $line;
    $line =~ s/^[ \t]+//;
    $line = &xst_parse_process_sh_line ($line);
    
    next if ($line eq "");
    last if ($line =~ /^(image|other)/);
    @line = split ($re, $line, 2);

    if (shift (@line) eq $key)
    {
      close $fd;
      return $line[0];
    }
  }

  close $fd;
  return undef;
}


sub xst_boot_parse_images
{
  my $file = $_[0];
  my ($fd, @line, $found, $hash, @images);
  my ($key, $val, $line);

  $found = -1;
  $fd = &xst_file_open_read_from_names ($file);

  while (($line = <$fd>))
  {
    chomp $line;
    $line =~ s/^[ \t]+//;

    $found++ if ($line =~ /^(image|other)/);
    next if $found < 0;
    
    if ($line =~ /^\#[ \t]*(\w+)/)
    {
      next if $1 ne "XstPartitionType";

      $line =~ s/^\#[ \t]*//;
    }

    $line = &xst_parse_process_sh_line ($line);
    next if ($line =~ /^$/);
    
    @line = split ("[ \t]*=[ \t]*", $line, 2);    
    $key = $line[0];
    $val = $line[1];
    $val =~ s/^[ \t]+//;
    $val =~ s/\"//g;    
    $val =~ s/[ \t]+$//;

    $images[$found]{$key} = $val;
  }

  close $fd;
  return \@images;
}


sub xst_boot_set_global_kw
{
  my ($file, $key) = @_;
  my ($buff, $i, $found);
  my $lineno = 0;
  
  $buff = &xst_file_buffer_load ($file);
  $found = 0;

  foreach $i (@$buff)
  {
    if (&xst_ignore_line ($i))
    {
      $lineno++;
      next;
    }

    if ($i =~ /^[ \t]*$key/)
    {
      $found++;
      last;
    }

    if ($i =~ /^[ \t]*(image|other)/)
    {
      $lineno--; # "pop" it back
      last;
    }
    $lineno++;
  }

  # Not found, let's add
  if (!$found)
  {
    # pop back empty lines
    while ($lineno > 0 && $$buff[$lineno] =~ /^\s*$/)
    {
      $lineno--;
    }
    
    $$buff[$lineno] .= $key . "\n";
  } 
  
  &xst_file_buffer_clean ($buff);
  return &xst_file_buffer_save ($buff, $file);
}

sub xst_boot_set_global
{
  my ($file, $key, $val) = @_;
  my ($buff, $i, $found);
  my $quote = '"';
  my $lineno = 0;

  # quote globals with spaces if neccecary (append=mem=128 param2=122)
  if ($val =~ /^\S+\s+\S+/ && !($val =~ /^\".+\"/)) {
    $val = $quote . $val . $quote;
  }

  # Stupid, but neccecary hack, append lines ALWAYS need to be quoted.
  $val = $quote . $val . $quote if $key =~ /image/;  
  
  $buff = &xst_file_buffer_load ($file);
  $found = 0;

  foreach $i (@$buff)
  {
    if (&xst_ignore_line ($i))
    {
      $lineno++;
      next;
    }

    if ($i =~ /^[ \t]*(image|other)/)
    {
      $lineno--;
      last;
    }
    
    if ($i =~ /^[ \t]*$key([ \t]*=[ \t]*)/)
    {
      $found++;
      $op = $1;

      chomp $i;
      
      $pre_space = $1 if $i =~ s/^([ \t]+)//;
      $post_comment = $1 if $i =~ s/([ \t]*\#.*)//;

      $i = $pre_space . $key . $op . $val . $post_comment . "\n";
      last;
    }
    
    $lineno++;
  }

  if (!$found)
  {
    # pop back empty lines
    while ($lineno > 0 && $$buff[$lineno] =~ /^\s*$/)
    {
      $lineno--;
    }
    
    $$buff[$lineno] .= $key . " = " . $val . "\n";
  }
  
  &xst_file_buffer_clean ($buff);
  return &xst_file_buffer_save ($buff, $file);
}


sub xst_boot_del_global
{
  my ($file, $key) = @_;
  my ($buff, $i);

  $buff = &xst_file_buffer_load ($file);

  foreach $i (@$buff)
  {
    last if ($i =~ /^[ \t]*(image|other)/);
    
    if ($i =~ /^[ \t]*$key/)
    {
      $i = "";
      last;
    }
  }
  
  &xst_file_buffer_clean ($buff);
  return &xst_file_buffer_save ($buff, $file);
}


# Scans @buff until finds first line which looks like image.
# Returns line number or -1 if no image found.
sub xst_boot_conf_find_image
{
  my ($buff, $lineno) = @_;
  my $i;

  for (;$lineno <= $#$buff; $lineno++)
  {
    $i = $$buff[$lineno];

    return $lineno if ($i =~ /^[ \t]*(image)|(other)[ \t]*=[ \t]*\S+/);
  }

  # Not found.
  return -1;
}


# Returns 1 if $image is in the beginning of @buff. -1  if not.
sub xst_boot_conf_is_image
{
  my ($image, @buff) = @_;
  my ($name, $key, $i, $label);
  
  $name = 0;
  $name = 'image' if exists $$image{'image'};
  $name = 'other' if exists $$image{'other'};

  return -1 if (!$name);

  $key = $$image{$name};
  $label = $$image{'label'};

  $i = $buff[0];
  # image line isn't the one we are looking for.
  return -1 if (!($i =~ /^[ \t]*$name[ \t]*=[ \t]*$key\s+/));
  
  foreach $i (@buff)
  {
    # image line matched, now label matched too.
    return 1 if ($i =~ /^[ \t]*label[ \t]*=[ \t]*$label\s+/);
  }

  # Couldn't find label line.
  return -1;
}


# Deletes lines from $buff starting from $lineno till the next image
# or till end of the file if no more images left.
sub xst_boot_conf_delete_image
{
  my ($buff, $lineno) = @_;
  my ($end, $i);

  $end = &xst_boot_conf_find_image ($buff, $lineno + 1);
  if ($end < 0)
  {
    $end = $#$buff;
  }

  for ($i = $lineno; $i < $end; $i++)
  {
    $$buff[$i] = "";
  }

  return $buff;
}


# Edit image in $buff which starts at $lineno. Get changes from $image.
sub xst_boot_conf_edit_image
{
  my ($image, $buff, $lineno) = @_;
  my ($end, $i, $found, $line, $key);
  my ($pre_space, $post_comment, $value);

  $end = &xst_boot_conf_find_image ($buff, $lineno + 1);
  if ($end < 0)
  {
    $end = $#$buff + 1;
  }

  for ($lineno; $lineno < $end; $lineno++)
  {
    $found = 0;
    $line = \$$buff[$lineno];

    $pre_space = $post_comment = "";
    chomp $$line;
    $pre_space = $1 if $$line =~ s/^([ \t]+)//;
    $post_comment = $1 if $$line =~ s/([ \t]*[\#].*)//;
    
    foreach $key (keys %$image)
    {
      # Something like 'label = linunx'
      if ($$line =~ /^$key([ \t]*)=([ \t]*)(\S+)/)
      {
        $found++;
        $value = $$image{$key};
        $value = "\"$value\"" if ($value =~ /[ \t]/);
        $value = "\"$value\"" if ($key =~ /append/); # Stupid hack to quote append= values.

        $$line = $pre_space . $key . $1 . "=" . $2 . $value . $post_comment . "\n";
        $$line = "# " . $$line if $key eq "XstPartitionType";
        delete $$image{$key};        
      }
      # Something like 'read-only' (ie keyword)
      elsif ($$line =~ /^$key$/)
      {
        $found++;
        $$line = $pre_space . $key . $post_comment . "\n";
        delete $$image{$key};
      }
      last if $found;
    }

    $$line = "" if !$found;
  }

  # Add new fields.
  foreach $key (keys %$image)
  {
    $value = $$image{$key};
    $value = "\"$value\"" if ($value =~ /[ \t]/);
    
    $line = "";
    $line = "# " if $key eq "XstPartitionType";
    $line .= "\t$key";
    
    $line .= " = " . $value if $value;
    $line .= "\n";

    $$buff[$end -1] .= $line;
  }
    
  return $buff;
}


# Add $image to the end of $buff.
sub xst_boot_conf_add_image
{
  my ($image, $buff) = @_;
  my ($line, $key, $value);

  # Image line
  $value = 0;
  $value = 'image' if exists $$image{'image'};
  $value = 'other' if exists $$image{'other'};

  return if !$value;

  $line = $value . " = " . $$image{$value} . "\n";
  push @$buff, $line;
  delete $$image{$value};

  # Parameters for image
  foreach $key (keys %$image)
  {
    $value = $$image{$key};
    $value = "\"$value\"" if ($value =~ /[ \t]/);

    $line = "";
    $line = "# " if $key eq "XstPartitionType";
    $line .= "\t$key";
    
    $line .= " = " . $value if $value;
    $line .= "\n";

    push @$buff, $line;
  }
}


sub xst_boot_conf_set_images
{
  my ($file, $key, $images) = @_;
  my ($buff, $lineno, $found, $image);

  return if ($#$images <= 0);
  
  $buff = &xst_file_buffer_load ($file);
  &xst_file_buffer_join_lines ($buff);

  $lineno = &xst_boot_conf_find_image ($buff, 0);
  while ($lineno > 0)
  {
    $found = 0;
    foreach $image (@$images)
    {
      $found = &xst_boot_conf_is_image ($image, @$buff[$lineno .. $#$buff]);
      if ($found > 0)
      {
        # Found image, change it if neccecary,
        # remove %image from @images and find new image.
        $buff = &xst_boot_conf_edit_image ($image, $buff, $lineno);
        $image = undef;
        last;
      }
    }

    # Found image wasn't in our @images list: delete.
    $buff = &xst_boot_conf_delete_image ($buff, $lineno) if ($found < 0);

    # Search new image line.
    $lineno = &xst_boot_conf_find_image ($buff, $lineno + 1);
  }

  # At this point @images contains only new images, let's add them.
  foreach $image (@$images)
  {
    &xst_boot_conf_add_image ($image, $buff);
  }

  &xst_file_buffer_clean ($buff);
  return &xst_file_buffer_save ($buff, $file);
}


sub xst_boot_replace_from_table
{
  my ($fn, $table, $values_hash) = @_;
  my ($key, $proc, @param);
  my ($i, @cp, $res, $res2);

  foreach $i (@$table)
  {
    @cp = @$i;
    $key = shift (@cp);
    if (exists $$values_hash{$key})
    {
      $proc = shift (@cp);
      $cp[0] = $$fn{$cp[0]} if $cp[0] ne undef;
      push (@cp, $$values_hash{$key});
      
      $res = -1 if &$proc (@cp);
    }
    else
    {
      &xst_boot_del_global ("/etc/lilo.conf", $key);
    }
  }

  return $res;
}


sub xst_boot_conf_set
{
  my $values_hash = $_[0];

  my %dist_map =
  (
   "redhat-6.0" => "redhat-6.2",
   "redhat-6.1" => "redhat-6.2",
   "redhat-6.2" => "redhat-6.2",
   "redhat-7.0" => "redhat-6.2",
   "redhat-7.1" => "redhat-6.2",
   
   "mandrake-7.2" => "redhat-6.2",
   
   "debian-2.2"   => "redhat-6.2",
   "debian-woody" => "redhat-6.2",

   "suse-7.0"     => "redhat-6.2",

   "turbolinux-7.0" => "redhat-6.2"
  );
  
  my %dist_tables =
	 (
	  "redhat-6.2" => {
	    fn => {
		 LILO_CONF => "/etc/lilo.conf"},
	    table => [
                [ 'prompt',   \&xst_boot_set_global_kw, LILO_CONF, 'prompt' ],
                [ 'lba32',    \&xst_boot_set_global_kw, LILO_CONF, 'lba32' ],
                [ 'root',     \&xst_boot_set_global, LILO_CONF, 'root' ],
                [ 'delay',    \&xst_boot_set_global, LILO_CONF, 'delay' ],
                [ 'timeout',  \&xst_boot_set_global, LILO_CONF, 'timeout' ],
                [ 'default',  \&xst_boot_set_global, LILO_CONF, 'default' ],
                [ 'append',   \&xst_boot_set_global, LILO_CONF, 'append' ],
                [ 'boot',     \&xst_boot_set_global, LILO_CONF, 'boot' ],
                [ 'map',      \&xst_boot_set_global, LILO_CONF, 'map' ],
                [ 'install',  \&xst_boot_set_global, LILO_CONF, 'install' ],
                [ 'keytable', \&xst_boot_set_global, LILO_CONF, 'keytable' ],
                [ 'images',   \&xst_boot_conf_set_images, LILO_CONF, 'image' ],
			    ] 
				 }
	  );

  my $table = $dist_map{$xst_dist};
  return undef if !$table
;
  return &xst_boot_replace_from_table ($ {$dist_tables{$table}}{"fn"},
						  $ {$dist_tables{$table}}{"table"}, $values_hash);

}


sub xst_boot_conf_get
{
  my %dist_map =
  (
   "redhat-6.0" => "redhat-6.2",
   "redhat-6.1" => "redhat-6.2",
   "redhat-6.2" => "redhat-6.2",
   "redhat-7.0" => "redhat-6.2",
   "redhat-7.1" => "redhat-6.2",
   
   "mandrake-7.2" => "redhat-6.2",
   
   "debian-2.2"   => "redhat-6.2",
   "debian-woody" => "redhat-6.2",

   "suse-7.0"     => "redhat-6.2",

   "turbolinux-7.0" => "redhat-6.2"
   );
  
  my %dist_tables =
	 (
	  "redhat-6.2" => {
	    fn => {
        LILO_CONF => "/etc/lilo.conf" },
	    table => [
                [ 'prompt',   \&xst_boot_parse_global_kw, LILO_CONF, 'prompt' ],
                [ 'lba32',    \&xst_boot_parse_global_kw, LILO_CONF, 'lba32' ],
                [ 'root',     \&xst_boot_parse_global, LILO_CONF, 'root' ],
                [ 'delay',    \&xst_boot_parse_global, LILO_CONF, 'delay' ],
                [ 'timeout',  \&xst_boot_parse_global, LILO_CONF, 'timeout' ],
                [ 'default',  \&xst_boot_parse_global, LILO_CONF, 'default' ],
                [ 'append',   \&xst_boot_parse_global, LILO_CONF, 'append' ],
                [ 'boot',     \&xst_boot_parse_global, LILO_CONF, 'boot' ],
                [ 'map',      \&xst_boot_parse_global, LILO_CONF, 'map' ],
                [ 'install',  \&xst_boot_parse_global, LILO_CONF, 'install' ],
                [ 'keytable', \&xst_boot_parse_global, LILO_CONF, 'keytable' ],
                [ 'images',   \&xst_boot_parse_images, LILO_CONF ],
                ] 
                  }
    );
  
  my $table = $dist_map{$xst_dist};
  return undef if !$table;
  
  return &xst_parse_from_table ($ {$dist_tables{$table}}{"fn"},
                                $ {$dist_tables{$table}}{"table"});
}
