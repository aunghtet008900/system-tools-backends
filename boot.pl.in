#!/usr/bin/env perl
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-

# Boot manager configurator. Designed to be architecture and distribution independent.
#
# Copyright (C) 2000-2001 Ximian, Inc.
#
# Authors: Tambet Ingo <tambet@ximian.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.


require "___scriptsdir___/general.pl";
require "___scriptsdir___/util.pl";
require "___scriptsdir___/file.pl";
require "___scriptsdir___/xml.pl";
require "___scriptsdir___/parse.pl";
require "___scriptsdir___/replace.pl";


sub xst_boot_parse_global_kw
{
  my ($file, $key) = @_;
  my $fd;

  $fd = &xst_open_read_from_names ($file);

  while (<$fd>)
  {
    chomp;
    s/^[ \t]+//;
    next if (/^\#/ || /^$/);
    last if (/^(image|other)/);

    if ($key eq $_)
    {
      close $fd;
      return 1;
    }
  }

  close $fd;
  return undef;
}


sub xst_boot_parse_global
{
  my ($file, $key) = @_;
  my ($fd, @line, $re);

  $re = "[ \t]*=[ \t]*";
  $fd = &xst_open_read_from_names ($file);

  while (<$fd>)
  {
    chomp;
    s/^[ \t]+//;
    next if (/^\#/ || /^$/);
    last if (/^(image|other)/);
    @line = split ($re, $_, 2);

    if (shift (@line) eq $key)
    {
      close $fd;
      return $line[0];
    }
  }

  close $fd;
  return undef;
}


sub xst_boot_parse_images
{
  my $file = $_[0];
  my ($fd, @line, $found, $hash, @images);
  my ($key, $val);

  $found = -1;
  $fd = &xst_open_read_from_names ($file);

  while (<$fd>)
  {
    chomp;
    s/^[ \t]+//;

    $found++ if (/^(image|other)/);
    next if $found < 0;
    
    next if (/^$/);
    if (/^\#[ \t]*(\w+)/)
    {
      next if $1 ne "XstPartitionType";

      s/^\#[ \t]*//;
    }
    
    @line = split ("[ \t]*=[ \t]*", $_, 2);    
    $key = $line[0];
    $val = $line[1];

    $images[$found]{$key} = $val;
  }

  close $fd;
  return \@images;
}


sub xst_boot_set_global_kw
{
  my ($file, $key) = @_;
  my $buff, $i, $found;

  $buff = &xst_buffer_load ($file);
  $found = 0;

  foreach $i (@$buff)
  {
    $pre_space = $post_comment = "";
    
    chomp $i;
    $pre_space = $1 if $i =~ s/^([ \t]+)//;
    $post_comment = $1 if $i =~ s/([ \t]*\#.*)//;

    if ($i =~ /^(image|other)/)
    {
      $i = $key . "\n" . $pre_space . $i . $post_comment . "\n";
      last;
    }
    
    if ($i ne "")
    {
      $found = 1 if ($key eq $i);
    }

    $i = $pre_space . $i . $post_comment . "\n";

    last if $found;
  }
  
  &xst_buffer_clean ($buff);
  return &xst_buffer_save ($buff, $file);
}


sub xst_boot_set_global
{
  my ($file, $key, $val) = @_;
  my $buff, $i, $found;

  $buff = &xst_buffer_load ($file);
  $found = 0;

  foreach $i (@$buff)
  {
    $pre_space = $post_comment = "";
    
    chomp $i;
    $pre_space = $1 if $i =~ s/^([ \t]+)//;
    $post_comment = $1 if $i =~ s/([ \t]*\#.*)//;

    if ($i =~ /^(image|other)/)
    {
      $i = "$key=$val\n" . $pre_space . $i . $post_comment . "\n";
      last;
    }
    
    if ($i ne "")
    {
      if ($i =~ /$key([ \t]*=[ \t]*)/)
      {
        $i = $key . $1 . $val;
        $found = 1;
      }
    }

    $i = $pre_space . $i . $post_comment . "\n";

    last if $found;
  }
  
  &xst_buffer_clean ($buff);
  return &xst_buffer_save ($buff, $file);
}


sub xst_boot_del_global
{
  my ($file, $key) = @_;
  my $buff, $i;

  $buff = &xst_buffer_load ($file);

  foreach $i (@$buff)
  {
    last if ($i =~ /^[ \t]*(image|other)/);
    
    if ($i =~ /^[ \t]*$key/)
    {
      $i = "";
      last;
    }
  }
  
  &xst_buffer_clean ($buff);
  return &xst_buffer_save ($buff, $file);
}


sub xst_boot_conf_del_images
{
  my ($fn, $images) = @_;
  
  $buf = &xst_buffer_load ($fn);

  $found = 1;
  foreach $i (@$buf)
  {
    if ($i =~ /^[ \t]*(image|other)[ \t]*=[ \t]*([\S]+)/)
    {
      $found = 0;
      foreach $a (@$images)
      {
        %hash = %$a;

        $found = 1 if (exists $hash{$1} && $hash{$1} eq $2);
      }
    }
    
    next if ($found);

    $i = "";
  }

  &xst_buffer_clean ($buf);
  return &xst_buffer_save ($buf, $fn);
}


sub xst_boot_conf_set_images
{
  my ($fn, $key, $images) = @_;
  my %hash, $i, @tmp_images;

  @tmp_images = @$images;
  
  foreach $i (@tmp_images)
  {
    %hash = %$i;
    &xst_boot_conf_replace_image ($fn, %hash);
  }
  &xst_boot_conf_del_images ($fn, $images);
}


sub xst_boot_conf_replace_image
{
  my ($file, %image) = @_;
  my $buff, $i, $found;
  my $pre_space, $post_comment;
  my @line, $key, $op, $txt;

  $buff = &xst_buffer_load ($file);
  &xst_buffer_join_lines ($buff);
  
  $found = 0;

  $name = 'image' if exists $image{'image'};
  $name = 'other' if exists $image{'other'};

  foreach $i (@$buff)
  {
    if ($i =~ /$name[ \t]*=[ \t]*$image{$name}\s+/) # Found the image.
    {
      $found++;
      next;
    }
    
    if ($i =~ /(image|other)/ && $found == 1) # Next image, let's add pending stuff.
    {
      delete $image{$name};
      $found++;
      foreach $key (keys %image)
      {
        $txt = "$key\n" unless $image{$key};
        $txt = "$key = $image{$key}\n" if $image{$key};
        
        if ($key eq "XstPartitionType") { $txt = "\t# " . $txt; }
        else { $txt = "\t". $txt; }

        $i = $txt . $i;
      }
      last;
    }
    
    next if ($found != 1);

    $pre_space = $post_comment = "";
    
    chomp $i;
    $pre_space = $1 if $i =~ s/^([ \t]+)//;
    $post_comment = $1 if $i =~ s/([ \t]*[\#;].*)//;

    # Special case: #XstPartitionType
    if ($i eq "" && $post_comment =~ /\#[ \t]*XstPartitionType/)
    {
      $i = $post_comment;
      $i =~ s/\#[ \t]*//;
      $pre_space .= "# ";
      $post_comment = "";
    }
    
    @line = split (/([ \t]*=[ \t]*)/, $i, 2);

    $key = shift @line;
    $op = shift @line;

    if (exists $image{$key} && $image{$key})
    {
      $i = $pre_space . $key . $op . $image{$key} . $post_comment . "\n";
      delete $image{$key};
      next;
    }

    elsif (exists $image{$key} && !$image{$key})
    {
      $i = $pre_space . $key . $post_comment . "\n";
      delete $image{$key};
      next;
    }   

    elsif ($i ne "") # Delete unknown "junk"... yes, we are cruel!
                     # We can do that cause on reading we include all lines, no matter what.
    {
      $i = "";
      next;
    }
    
    else
    {
      $i = $pre_space . $i . $post_comment . "\n";
    }
  }

  if (keys %image && $found) #end of file reached, let's add pending tags.
  {
    delete $image{$name};
    foreach $key (keys %image)
    {
      $i = "$key\n" unless $image{$key};
      $i = "$key = $image{$key}\n" if $image{$key};

      if ($key eq "XstPartitionType") { $i = "\t# " . $i; }
      else { $i = "\t". $i; }
      
      push @$buff, $i;
    }
  }

  elsif (!$found) # We didn't find image, lets add it to the end of file.
  {
    push @$buff, "\n$name=$image{$name}\n";
    delete $image{$name};
    
    foreach $key (keys %image)
    {
      $i = "$key\n" unless $image{$key};
      $i = "$key = $image{$key}\n" if $image{$key};

      if ($key eq "XstPartitionType") { $i = "\t# " . $i; }
      else { $i = "\t". $i; }
      
      push @$buff, $i;
    }
  }
  
  &xst_buffer_clean ($buff);
  return &xst_buffer_save ($buff, $file);
}


sub xst_boot_replace_from_table
{
  my ($fn, $table, $values_hash) = @_;
  my ($key, $proc, @param);
  my ($i, @cp, $res, $res2);

  foreach $i (@$table)
  {
    @cp = @$i;
    $key = shift (@cp);
    if (exists $$values_hash{$key})
    {
      $proc = shift (@cp);
      $cp[0] = $$fn{$cp[0]} if $cp[0] ne undef;
      push (@cp, $$values_hash{$key});
      
      $res = -1 if &$proc (@cp);
    }
    else
    {
      &xst_boot_del_global ("/etc/lilo.conf", $key);
    }
  }

  return $res;
}


sub xst_boot_conf_set
{
  my $values_hash = $_[0];

  my %dist_map =
  (
   "redhat-6.0" => "redhat-6.2",
   "redhat-6.1" => "redhat-6.2",
   "redhat-6.2" => "redhat-6.2",
   "redhat-7.0" => "redhat-6.2"
  );
  
  my %dist_tables =
	 (
	  "redhat-6.2" => {
	    fn => {
		 LILO_CONF => "/etc/lilo.conf"},
	    table => [
                [ 'prompt',  \&xst_boot_set_global_kw, LILO_CONF, 'prompt' ],
                [ 'lba32',   \&xst_boot_set_global_kw, LILO_CONF, 'lba32' ],
                [ 'root',    \&xst_boot_set_global, LILO_CONF, 'root' ],
                [ 'delay',   \&xst_boot_set_global, LILO_CONF, 'delay' ],
                [ 'timeout', \&xst_boot_set_global, LILO_CONF, 'timeout' ],
                [ 'default', \&xst_boot_set_global, LILO_CONF, 'default' ],
                [ 'append',  \&xst_boot_set_global, LILO_CONF, 'append' ],
                [ 'boot',    \&xst_boot_set_global, LILO_CONF, 'boot' ],
                [ 'map',     \&xst_boot_set_global, LILO_CONF, 'map' ],
                [ 'install', \&xst_boot_set_global, LILO_CONF, 'install' ],
                [ 'images',  \&xst_boot_conf_set_images, LILO_CONF, 'image' ],
			    ] 
				 }
	  );

  my $table = $dist_map{$xst_dist};
  return undef if !$table;

  return &xst_boot_replace_from_table ($ {$dist_tables{$table}}{"fn"},
						  $ {$dist_tables{$table}}{"table"}, $values_hash);

}


sub xst_boot_conf_get
{
  my %dist_map =
  (
   "redhat-6.0" => "redhat-6.2",
   "redhat-6.1" => "redhat-6.2",
   "redhat-6.2" => "redhat-6.2",
   "redhat-7.0" => "redhat-6.2"
   );
  
  my %dist_tables =
	 (
	  "redhat-6.2" => {
	    fn => {
		 LILO_CONF => "/etc/lilo.conf" },
	    table => [
                [ 'prompt',  \&xst_boot_parse_global_kw, LILO_CONF, 'prompt' ],
                [ 'lba32',   \&xst_boot_parse_global_kw, LILO_CONF, 'lba32' ],
                [ 'root',    \&xst_boot_parse_global, LILO_CONF, 'root' ],
                [ 'delay',   \&xst_boot_parse_global, LILO_CONF, 'delay' ],
                [ 'timeout', \&xst_boot_parse_global, LILO_CONF, 'timeout' ],
                [ 'default', \&xst_boot_parse_global, LILO_CONF, 'default' ],
                [ 'append',  \&xst_boot_parse_global, LILO_CONF, 'append' ],
                [ 'boot',    \&xst_boot_parse_global, LILO_CONF, 'boot' ],
                [ 'map',     \&xst_boot_parse_global, LILO_CONF, 'map' ],
                [ 'install', \&xst_boot_parse_global, LILO_CONF, 'install' ],
                [ 'images',  \&xst_boot_parse_images, LILO_CONF ],
                ] 
                  }
    );
  
  my $table = $dist_map{$xst_dist};
  return undef if !$table;
  
  return &xst_parse_from_table ($ {$dist_tables{$table}}{"fn"},
                                $ {$dist_tables{$table}}{"table"});
}
