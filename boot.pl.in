#!/usr/bin/env perl
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-

# Boot manager configurator. Designed to be architecture and distribution independent.
#
# Copyright (C) 2000-2001 Ximian, Inc.
#
# Authors: Tambet Ingo <tambet@ximian.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.


require "___scriptsdir___/general.pl";
require "___scriptsdir___/util.pl";
require "___scriptsdir___/file.pl";
require "___scriptsdir___/xml.pl";
require "___scriptsdir___/parse.pl";
require "___scriptsdir___/replace.pl";


sub xst_boot_parse_global_kw
{
  my ($file, $key) = @_;
  my $fd;

  $fd = &xst_open_read_from_names ($file);

  while (<$fd>)
  {
    chomp;
    s/^[ \t]+//;
    next if (/^\#/ || /^$/);
    last if (/^(image|other)/);

    if ($key eq $_)
    {
      close $fd;
      return 1;
    }
  }

  close $fd;
  return undef;
}


sub xst_boot_parse_global
{
  my ($file, $key) = @_;
  my ($fd, @line, $re);

  $re = "[ \t]*=[ \t]*";
  $fd = &xst_open_read_from_names ($file);

  while (<$fd>)
  {
    chomp;
    s/^[ \t]+//;
    next if (/^\#/ || /^$/);
    last if (/^(image|other)/);
    @line = split ($re, $_, 2);

    if (shift (@line) eq $key)
    {
      close $fd;
      return $line[0];
    }
  }

  close $fd;
  return undef;
}


sub xst_boot_parse_images
{
  my $file = $_[0];
  my ($fd, @line, $re, $found, $hash, @images);
  my ($key, $val);

  $found = -1;
  $re = "[ \t]*=[ \t]*";
  $fd = &xst_open_read_from_names ($file);

  while (<$fd>)
  {
    chomp;
    s/^[ \t]+//;
    next if (/^\#/ || /^$/); # Remove comments

    @line = split ($re, $_, 2);
    
    if ($line[0] =~ /^(image|other)/)
    {
      $found++;
    }

    next if $found < 0;

    $key = $line[0];
    $val = $line[1];

    $images[$found]{$key} = $val;
  }

  close $fd;
  return \@images;
}


sub xst_boot_set_global_kw
{
  my ($file, $key) = @_;
  my $buff, $i, $found;

  $buff = &xst_buffer_load ($file);
  $found = 0;

  foreach $i (@$buff)
  {
    $pre_space = $post_comment = "";
    
    chomp $i;
    $pre_space = $1 if $i =~ s/^([ \t]+)//;
    $post_comment = $1 if $i =~ s/([ \t]*\#.*)//;

    if ($i =~ /^(image|other)/)
    {
      $i = $key . "\n" . $pre_space . $i . $post_comment . "\n";
      last;
    }
    
    if ($i ne "")
    {
      $found = 1 if ($key eq $i);
    }

    $i = $pre_space . $i . $post_comment . "\n";

    last if $found;
  }
  
  &xst_buffer_clean ($buff);
  return &xst_buffer_save ($buff, $file);
}


sub xst_boot_set_global
{
  my ($file, $key, $val) = @_;
  my $buff, $i, $found;

  $buff = &xst_buffer_load ($file);
  $found = 0;

  foreach $i (@$buff)
  {
    $pre_space = $post_comment = "";
    
    chomp $i;
    $pre_space = $1 if $i =~ s/^([ \t]+)//;
    $post_comment = $1 if $i =~ s/([ \t]*\#.*)//;

    if ($i =~ /^(image|other)/)
    {
      $i = "$key=$val\n" . $pre_space . $i . $post_comment . "\n";
      last;
    }
    
    if ($i ne "")
    {
      if ($i =~ /$key([ \t]*=[ \t]*)/)
      {
        $i = $key . $1 . $val;
        $found = 1;
      }
    }

    $i = $pre_space . $i . $post_comment . "\n";

    last if $found;
  }
  
  &xst_buffer_clean ($buff);
  return &xst_buffer_save ($buff, $file);
}


sub xst_boot_del_global
{
  my ($file, $key) = @_;
  my $buff, $i;

  $buff = &xst_buffer_load ($file);

  foreach $i (@$buff)
  {
    last if ($i =~ /^[ \t]*(image|other)/);
    
    if ($i =~ /^[ \t]*$key/)
    {
      $i = "";
      last;
    }
  }
  
  &xst_buffer_clean ($buff);
  return &xst_buffer_save ($buff, $file);
}
  

sub xst_boot_conf_set_images
{
  my ($fn, $key, $images) = @_;
  my ($image_name, $image_val, $current);
  my ($i, $a);

  foreach $i (@$images)
  {
    $image_name = 'image' if $$i{'image'};
    $image_name = 'other' if $$i{'other'};

    foreach $a (keys (%$i))
    {      
      &xst_boot_conf_replace_image ($fn, $image_name, $$i{$image_name}, $a, $$i{$a});
    }
  }
}


sub xst_boot_conf_replace_image
{
  my ($file, $image_name, $image_val, $var, $value) = @_;
  my ($fd, @line, @res);
  my $buff, $i, $found_flag;
  my $pre_space, $post_comment, $sec_save;
  my $line_key, $val;

  $buff = &xst_buffer_load ($file);

  &xst_buffer_join_lines ($buff);

  $found_flag = 0;
  
  foreach $i (@$buff)
  {
    $pre_space = $post_comment = "";
    
    chomp $i;
    $pre_space = $1 if $i =~ s/^([ \t]+)//;
    $post_comment = $1 if $i =~ s/([ \t]*[\#;].*)//;
    
    if ($i ne "")
    {
	 if ($i =~ /[ \t]*$image_name[ \t]*=[ \t]*$image_val$/i)
	 {
	   $i =~ s/([ \t]*$image_name[ \t]*=[ \t]*$image_val)//i;
	   $sec_save = $1;
	   $found_flag = 1;
	 }

	 if ($found_flag)
	 {
	   if ($i =~ /\[[ \t]*[^ \t\]]+[ \t]*\]/)
	   {
		$i = "\t$var = $value\n$i";
		$found_flag = 2;
	   }

	   if ($found_flag && $i =~ /^$var[ \t]*=/i)
	   {
		$i =~ s/^($var[ \t]*=[ \t]*).*/\1$value/i;
		$found_flag = 2;
	   }
	 }
    }

    if ($found_flag && $sec_save ne "")
    {
	 $i = $sec_save . $i;
	 $sec_save = "";
    }
    
    $i = $pre_space . $i . $post_comment . "\n";
    last if $found_flag == 2;
  }

  if (!$found_flag)
  {
    push @$buff, "$image_name = $image_val\n";
    push @$buff, "\t$var = $value\n";
  }

  &xst_buffer_clean ($buff);
  return &xst_buffer_save ($buff, $file);
}


sub xst_boot_replace_from_table
{
  my ($fn, $table, $values_hash) = @_;
  my ($key, $proc, @param);
  my ($i, @cp, $res, $res2);

  foreach $i (@$table)
  {
    @cp = @$i;
    $key = shift (@cp);
    if (exists $$values_hash{$key})
    {
      $proc = shift (@cp);
      $cp[0] = $$fn{$cp[0]} if $cp[0] ne undef;
      push (@cp, $$values_hash{$key});
      
      $res = -1 if &$proc (@cp);
    }
    else
    {
      &xst_boot_del_global ("/home/tambeti/lilo.conf", $key);
    }
  }

  return $res;
}


sub xst_boot_conf_set
{
  my $values_hash = $_[0];

  my %dist_map =
  (
   "redhat-6.0" => "redhat-6.2",
   "redhat-6.1" => "redhat-6.2",
   "redhat-6.2" => "redhat-6.2",
   "redhat-7.0" => "redhat-7.0"
  );
  
  my %dist_tables =
	 (
	  "redhat-6.2" => {
	    fn => {
		 LILO_CONF => "/home/tambeti/lilo.conf"},
	    table => [
                [ prompt,  \&xst_boot_set_global_kw, LILO_CONF, prompt ],
                [ root,    \&xst_boot_set_global, LILO_CONF, root ],
                [ delay,   \&xst_boot_set_global, LILO_CONF, delay ],
                [ timeout, \&xst_boot_set_global, LILO_CONF, timeout ],
                [ default, \&xst_boot_set_global, LILO_CONF, default ],
                [ images,  \&xst_boot_conf_set_images, LILO_CONF, image ],
			    ] 
				 }
	  );

  my $table = $dist_map{$xst_dist};
  return undef if !$table;

  return &xst_boot_replace_from_table ($ {$dist_tables{$table}}{"fn"},
						  $ {$dist_tables{$table}}{"table"}, $values_hash);

}


sub xst_boot_conf_get
{
  my %dist_map =
  (
   "redhat-6.0" => "redhat-6.2",
   "redhat-6.1" => "redhat-6.2",
   "redhat-6.2" => "redhat-6.2",
   "redhat-7.0" => "redhat-6.2"
   );
  
  my %dist_tables =
	 (
	  "redhat-6.2" => {
	    fn => {
		 LILO_CONF => "/home/tambeti/lilo.conf" },
	    table => [
                [ 'prompt',  \&xst_boot_parse_global_kw, LILO_CONF, 'prompt' ],
                [ 'lba32',   \&xst_boot_parse_global_kw, LILO_CONF, 'lba32' ],
                [ 'root',    \&xst_boot_parse_global, LILO_CONF, 'root' ],
                [ 'delay',   \&xst_boot_parse_global, LILO_CONF, 'delay' ],
                [ 'timeout', \&xst_boot_parse_global, LILO_CONF, 'timeout' ],
                [ 'default', \&xst_boot_parse_global, LILO_CONF, 'default' ],
                [ 'append',  \&xst_boot_parse_global, LILO_CONF, 'append' ],
                [ 'boot',    \&xst_boot_parse_global, LILO_CONF, 'boot' ],
                [ 'map',     \&xst_boot_parse_global, LILO_CONF, 'map' ],
                [ 'install', \&xst_boot_parse_global, LILO_CONF, 'install' ],
                [ 'images',  \&xst_boot_parse_images, LILO_CONF ],
                ] 
                  }
    );
  
  my $table = $dist_map{$xst_dist};
  return undef if !$table;
  
  return &xst_parse_from_table ($ {$dist_tables{$table}}{"fn"},
                                $ {$dist_tables{$table}}{"table"});
}
