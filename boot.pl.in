#!/usr/bin/env perl
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-

# Boot manager configurator. Designed to be architecture and distribution independent.
#
# Copyright (C) 2000-2001 Ximian, Inc.
#
# Authors: Tambet Ingo     <tambet@ximian.com>
#          Arturo Espinosa <arturo@ximian.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.


$SCRIPTSDIR = "___scriptsdir___";
if ($SCRIPTSDIR =~ /^___scriptsdir__[_]/)
{
    $SCRIPTSDIR = ".";
    $DOTIN = ".in";
}

require "$SCRIPTSDIR/general.pl$DOTIN";
require "$SCRIPTSDIR/util.pl$DOTIN";
require "$SCRIPTSDIR/file.pl$DOTIN";
require "$SCRIPTSDIR/xml.pl$DOTIN";
require "$SCRIPTSDIR/util.pl$DOTIN";
require "$SCRIPTSDIR/parse.pl$DOTIN";
require "$SCRIPTSDIR/replace.pl$DOTIN";
require "$SCRIPTSDIR/boot-grub.pl$DOTIN";
require "$SCRIPTSDIR/boot-lilo.pl$DOTIN";

# ----------------------------------------------------------------------------
# Fix functions.
#
# The main reason for these functions is to add default values to xml so the
# frontend doesn't have to know anything about lilo or its defaults.

sub xst_boot_fix_default
{
  my ($hash) = @_;
  my ($entries, $found, $entry);
  
  $entries = $$hash{"entry"};
  return unless $entries;
  
  # 'default'
  if (exists ($$hash{"default"}))
  {
    # Check if valid
    foreach $entry (@$entries)
    {
      if ($$hash{"default"} eq $$entry{"label"})
      {
        $found = 1;
        last;
      }
    }
    delete $$hash{"default"} unless $found;
  }
  
  if (not exists ($$hash{"default"}))
  {
    # No 'default', let's add
    foreach $entry (@$entries)
    {
      if ($$hash{"key"} == 0)
      {
        $$hash{"default"} = $$entry{"label"};
        last;
      }
    }
  }
}

# Internal. Should be run after fix_entries.
sub xst_boot_fix_globals
{
  my ($hash) = @_;
  
  return unless $hash;
  &xst_boot_fix_default ($hash);
}

# Internal
sub xst_boot_fix_entry
{
  my ($entry) = @_;
  my ($name);
  
  return unless $entry;

  $name = $$entry{"image"} if exists $$entry{"image"};
  $name = $$entry{"other"} if (!$name && exists $$entry{"other"});
    
  # Remove entries without entry identifier 'entry' or 'other'.
  unless ($name) {
    undef $entry;
    return;
  }

  # Add 'label' field which is optional in lilo.conf
  unless (exists $$entry{"label"})
  {
    $$entry{"label"} = $1 if ($name =~ /\S+\/(\S+)$/);
  }
}

# Internal
sub xst_boot_fix_entries
{
  my ($hash) = @_;
  my ($entries, $entry);

  return unless $hash;

  $entries = $$hash{"entry"};
  return unless $entries;

  foreach $entry (@$entries)
  {
    &xst_boot_fix_entry ($entry);
  }
}

sub xst_boot_fix
{
  my ($hash) = @_;
  
  return unless $hash;
  
  &xst_boot_fix_entries ($hash);
  &xst_boot_fix_globals ($hash);
}

# --------------------------------------------------------

sub xst_boot_entries_get
{
  my ($partition) = @_;
  my (%dist_attrib, @res, %fn, @entries, $entry);
  my ($dist, $value, $file, $proc);
  my ($entry, $j, $key, $tmp);

  %dist_attrib = &xst_boot_get_entry_parse_table ();
  %fn = %{$dist_attrib{"fn"}};
  $proc = $dist_attrib{"entries_get"};
  @entries = &$proc (\%fn);

  $ {$dist_attrib{"fn"}}{"PARTITION"} = $partition;

  $key = 0;
  foreach $entry (@entries)
  {
    foreach $j (keys (%fn))
    {
      $tmp = &xst_parse_expand ($fn{$j}, "key", $key);
      $ {$dist_attrib{"fn"}}{$j} = &xst_parse_expand ($tmp, "label", $entry);
    }

    $entry = &xst_parse_from_table ($dist_attrib{"fn"},
                                    $dist_attrib{"table"});
    push @res, $entry;
    $key ++;
  }

  return \@res;
}


sub xst_boot_conf_get
{
  my %dist_map =
  (
   "redhat-6.0" => "redhat-6.2",
   "redhat-6.1" => "redhat-6.2",
   "redhat-6.2" => "redhat-6.2",
   "redhat-7.0" => "redhat-6.2",
   "redhat-7.1" => "redhat-6.2",
   "redhat-7.2" => "redhat-7.2",
   
   "mandrake-7.1" => "redhat-6.2",
   "mandrake-7.2" => "mandrake-7.2",
   
   "debian-2.2"   => "redhat-6.2",
   "debian-woody" => "redhat-6.2",

   "suse-7.0"     => "redhat-6.2",

   "turbolinux-7.0" => "redhat-6.2"
   );
  
  my %dist_tables =
      (
       "redhat-6.2" =>
       {
         fn =>
         {
           LILO_CONF => "/etc/lilo.conf"
         },
         table =>
             [
              [ "partition", \&xst_partition_scan_info ],
              [ "pixmapsup", \&xst_parse_trivial,             0 ],
              [ "timeout",   \&xst_boot_lilo_parse_global,    LILO_CONF, "timeout" ],
              [ "prompt",    \&xst_boot_lilo_parse_global_kw, LILO_CONF, "prompt"  ],
              [ "default",   \&xst_boot_lilo_parse_global,    LILO_CONF, "default" ],
              [ "entry",     \&xst_boot_lilo_parse_entries,   LILO_CONF, "%partition%" ],
              ] 
       },

       "redhat-7.2" =>
       {
         fn =>
         {
           GRUB_CONF  => ["/boot/grub/grub.conf", "/boot/grub/menu.lst", "/etc/grub.conf"],
           DEVICE_MAP => "/boot/grub/device.map",
           MTAB       => "/etc/mtab"
         },
         table =>
             [
              [ "partition", \&xst_partition_scan_info ],
              [ "pixmapsup", \&xst_parse_trivial,           1 ],
              [ "pixmap",    \&xst_boot_grub_parse_pixmap,  [GRUB_CONF, DEVICE_MAP, MTAB] ],
              [ "timeout",   \&xst_boot_grub_parse_timeout, GRUB_CONF ],
              [ "prompt",    \&xst_boot_grub_parse_prompt,  GRUB_CONF ],
              [ "default",   \&xst_boot_grub_parse_default, GRUB_CONF ],
              [ "entry",     \&xst_boot_entries_get,        "%partition%" ],
              ] 
       },

       "mandrake-7.2" =>
       {
         fn =>
         {
           GRUB_CONF  => ["/boot/grub/grub.conf", "/boot/grub/menu.lst", "/etc/grub.conf"],
           DEVICE_MAP => "/boot/grub/device.map"
         },
         table =>
             [
              [ "partition", \&xst_partition_scan_info ],
              [ "pixmapsup", \&xst_parse_trivial,           0 ],
              [ "timeout",   \&xst_boot_grub_parse_timeout, GRUB_CONF ],
              [ "prompt",    \&xst_boot_grub_parse_prompt,  GRUB_CONF ],
              [ "default",   \&xst_boot_grub_parse_default, GRUB_CONF ],
              [ "entry",     \&xst_boot_entries_get,        "%partition%" ],
              ] 
       }
       );
  
  my $table = $dist_map{$main::xst_dist};
  if (!$table)
  {
      &xst_report ("platform_no_table", $main::xst_dist);
      return undef;
  }
  
  return &xst_parse_from_table ($ {$dist_tables{$table}}{"fn"},
                                $ {$dist_tables{$table}}{"table"});
}

sub xst_boot_get_entry_parse_table
{
  my %dist_map =
      (
       "redhat-7.2"   => "redhat-7.2",
       "mandrake-7.2" => "redhat-7.2"
       );

  my %dist_tables =
      (
       "redhat-7.2" =>
       {
         entries_get => \&xst_boot_grub_get_entries_fn,
         fn =>
         {
           KEY        => "#key#",
           LABEL      => "#label#",
           GRUB_CONF  => ["/boot/grub/grub.conf", "/boot/grub/menu.lst", "/etc/grub.conf"],
           DEVICE_MAP => "/boot/grub/device.map",
           MTAB       => "/etc/mtab"
         },
         table =>
             [
              ["key",    \&xst_parse_trivial,          [KEY]],
              ["label",  \&xst_parse_trivial,          [LABEL]],
              ["root",   \&xst_boot_grub_parse_root,   [GRUB_CONF, KEY]],
              ["type",   \&xst_boot_grub_parse_type,   [GRUB_CONF, KEY, PARTITION], "%root%"],
              ["image",  \&xst_boot_grub_parse_image,  [GRUB_CONF, DEVICE_MAP, MTAB, KEY]],
              ["other",  \&xst_boot_grub_parse_other,  [GRUB_CONF, DEVICE_MAP, MTAB, KEY]],
              ["append", \&xst_boot_grub_parse_append, [GRUB_CONF, KEY]]
              ]
                }
       );

  my $dist = $dist_map{$xst_dist};
  return %{$dist_tables{$dist}} if $dist;

  &xst_report ("platform_no_table", $xst_dist);
  return undef;
}

sub xst_boot_entry_set
{
  my ($dist_attrib, $values_hash) = @_;
  my ($j, %fn, $res);

  %fn = %{$$dist_attrib{"fn"}};

  foreach $j (keys (%fn))
  {
    $fn{$j} = &xst_parse_expand ($ {$$dist_attrib{"fn"}}{$j}, "key", $$values_hash{"key"});
  }
  
  return &xst_replace_from_table (\%fn, $$dist_attrib{"table"}, $values_hash);
}

sub xst_boot_entries_set
{
  my ($entries) = @_;
  my (%dist_attrib, %fn, @old, @new, @del);
  my ($i, $proc, $entry);
  my ($tmp, $res);

  %dist_attrib = &xst_boot_get_entry_replace_table ();
  %fn = %{$dist_attrib{"fn"}};

  foreach $entry (@$entries)
  {
    $new[$$entry{"key"}] = $entry;
  }
  $proc = $dist_attrib{"entries_get"};
  @old = &$proc (\%fn);
  
  for ($i = 0; $i < &xst_max (scalar @old, scalar @$entries); $i++)
  {
    if ($new[$i] ne undef)
    {
      $tmp = &xst_boot_entry_set (\%dist_attrib, $new[$i]);
      $res = $tmp if !$res;
    }
    else
    {
      push @del, $i;
    }
  }

  # Delete all old entries that are not in the hash.
  $proc = $dist_attrib{"entries_del"};
  $tmp = &$proc (\%fn, \@del);
  $res = $tmp if !$res;

  return $res;
}
    
sub xst_boot_conf_set
{
  my $values_hash = $_[0];

  my %dist_map =
  (
   "redhat-6.0" => "redhat-6.2",
   "redhat-6.1" => "redhat-6.2",
   "redhat-6.2" => "redhat-6.2",
   "redhat-7.0" => "redhat-6.2",
   "redhat-7.1" => "redhat-6.2",
   "redhat-7.2" => "redhat-7.2",

   "mandrake-7.1" => "redhat-6.2",
   "mandrake-7.2" => "mandrake-7.2",
   
   "debian-2.2"   => "redhat-6.2",
   "debian-woody" => "redhat-6.2",

   "suse-7.0"     => "redhat-6.2",

   "turbolinux-7.0" => "redhat-6.2"
  );
  
  my %dist_tables =
      (
       "redhat-6.2" => {
         fn => { LILO_CONF => "/etc/lilo.conf"},
         table => [
                   [ "timeout", \&xst_boot_lilo_replace_global,    LILO_CONF, "timeout" ],
                   [ "prompt",  \&xst_boot_lilo_replace_global_kw, LILO_CONF, "prompt"  ],
                   [ "default", \&xst_boot_lilo_replace_global,    LILO_CONF, "default" ],
                   [ "entry",   \&xst_boot_lilo_entries_set,       LILO_CONF ],
                   ] 
                     },
       
       "redhat-7.2" =>
       {
         fn =>
         {
           GRUB_CONF  => "/boot/grub/grub.conf",
           DEVICE_MAP => "/boot/grub/device.map",
           MTAB       => "/etc/mtab"
         },
         table =>
             [
              [ "pixmap",  \&xst_boot_grub_replace_pixmap,  [GRUB_CONF, DEVICE_MAP, MTAB] ],
              [ "timeout", \&xst_boot_grub_replace_timeout,  GRUB_CONF ],
              [ "prompt",  \&xst_boot_grub_replace_prompt,   GRUB_CONF ],
              [ "default", \&xst_boot_grub_replace_default,  GRUB_CONF ],
              [ "entry",   \&xst_boot_entries_set ],
              ] 
       },

       "mandrake-7.2" =>
       {
         fn =>
         {
           GRUB_CONF  => "/boot/grub/menu.lst",
           DEVICE_MAP => "/boot/grub/device.map"
         },
         table =>
             [
              [ "timeout", \&xst_boot_grub_replace_timeout, GRUB_CONF ],
              [ "prompt",  \&xst_boot_grub_replace_prompt,  GRUB_CONF ],
              [ "default", \&xst_boot_grub_replace_default, GRUB_CONF ],
              [ "entry",   \&xst_boot_entries_set ],
              ] 
       }
       );

  my $table = $dist_map{$main::xst_dist};
  if (!$table)
  {
      &xst_report ("platform_no_table", $main::xst_dist);
      return undef;
  }
  
  return &xst_replace_from_table ($ {$dist_tables{$table}}{"fn"},
                                  $ {$dist_tables{$table}}{"table"}, $values_hash);

}

sub xst_boot_get_entry_replace_table
{
  my %dist_map =
      (
       "redhat-7.2"   => "redhat-7.2",
       "mandrake-7.2" => "redhat-7.2"
       );

  my %dist_tables =
      (
       "redhat-7.2" =>
       {
         entries_get => \&xst_boot_grub_get_entries_fn,
         entries_del => \&xst_boot_grub_remove_entries,
         fn =>
         {
           KEY        => "#key#",
           GRUB_CONF  => "/boot/grub/grub.conf",
           DEVICE_MAP => "/boot/grub/device.map",
           MTAB       => "/etc/mtab"
         },
         table =>
             [
              # label has to go first, because it creates the entry if non-existent.
              ["label",  \&xst_boot_grub_replace_label,  [GRUB_CONF, KEY]],
              ["root",   \&xst_boot_grub_replace_root,   [GRUB_CONF, KEY]],
              ["type",   \&xst_boot_grub_replace_type,   [GRUB_CONF, KEY]],
              ["image",  \&xst_boot_grub_replace_image,  [GRUB_CONF, DEVICE_MAP, MTAB, KEY]],
              ["other",  \&xst_boot_grub_replace_other,  [GRUB_CONF, DEVICE_MAP, MTAB, KEY]],
              ["append", \&xst_boot_grub_replace_append, [GRUB_CONF, KEY]]
              ]
                }
       );

  my $dist = $dist_map{$xst_dist};
  return %{$dist_tables{$dist}} if $dist;

  &xst_report ("platform_no_table", $xst_dist);
  return undef;
}


