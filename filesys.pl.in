#!/usr/bin/env perl
#-*- Mode: perl; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-

# Working with filesystems, both local and networked.
#
# Copyright (C) 2000-2001 Ximian, Inc.
#
# Authors: Hans Petter Jansson <hpj@ximian.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU Library General Public License as published
# by the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU Library General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

require "___scriptsdir___/file.pl";
require "___scriptsdir___/parse.pl";
require "___scriptsdir___/xml.pl";


# --- Utilities --- #

# Merge items in hash B missing in A into A.
sub merge_hashes
{
  my ($ha, $hb) = @_;
  my $key;

  foreach $key (keys %$hb)
  {
    $$ha{$key} = $$hb{$key} if !exists $$ha{$key};
  }
}

sub xst_filesys_translate_ext2_device_to_label  # device
{
  my ($device) = @_;
  my $label;
  my $e2label_tool;
  local *E2LABEL_FD;

  $e2label_tool = &xst_file_locate_tool ("e2label");
  if ($e2label_tool eq "") { return undef; }

  open (E2LABEL_FD, "/bin/sh -c \"$e2label_tool $device\" 2>/dev/null |");
  $label = <E2LABEL_FD>;
  chomp $label;
  close (E2LABEL_FD);

  return $label;
}


# --- filesys_info; information on a particular filesystem --- #


sub xst_filesys_info_new
{
  my $info = {};
  my $opthash = {};

  $$info{'options'} = $opthash;
  return ($info);
}

# Make a deep copy of a filesys_info struct.
#
# Returns a newly allocated filesys_info, identical to the argument.

sub xst_filesys_info_dup           # filesys_info
{
  my $orig = $_[0];
  my $dup;

  $dup = { %$orig };
  $$dup{'options'} = { $$orig{'options'} };

  return $dup;
}

# Merge options in B missing in A inot A.
sub xst_filesys_info_merge_options
{
  my ($info_a, $info_b) = @_;
  my ($opt_a, $opt_b, $key);

  $opt_a = $$info_a{'options'};
  $opt_b = $$info_b{'options'};

  &merge_hashes ($opt_a, $opt_b);
}

# Merge stuff in B missing in A into A.
sub xst_filesys_info_merge
{
  my ($info_a, $info_b) = @_;
  my $key;

  &merge_hashes ($info_a, $info_b);
  &xst_filesys_info_merge_options ($info_a, $info_b);
}

# Generic set function for filesys_info properties. We need this to
# delete keys if they don't have meaningful values, otherwise an empty
# value could override a perfectly good value in a merge.

sub xst_filesys_info_set           # filesys_info, key, value
{
  my ($filesys_info, $key, $value) = @_;
  
  if ($value eq "")
  {
    delete $filesys_info->{$key};
  }
  else
  {
    $filesys_info->{$key} = $value;
  }
}

sub xst_filesys_info_get_device        # filesys_info
{
  return $_[0]->{'device'};
}

sub xst_filesys_info_set_device        # filesys_info, device
{
  &xst_filesys_info_set ($_[0], 'device', $_[1]);
}

sub xst_filesys_info_get_label         # filesys_info
{
  return $_[0]->{'label'};
}

sub xst_filesys_info_set_label         # filesys_info, label
{
  &xst_filesys_info_set ($_[0], 'label', $_[1]);
}

sub xst_filesys_info_get_network_host  # filesys_info
{
  return $_[0]->{'network_host'};
}

sub xst_filesys_info_set_network_host  # filesys_info, network_host
{
  &xst_filesys_info_set ($_[0], 'network_host', $_[1]);
}

sub xst_filesys_info_get_network_path  # filesys_info
{
  return $_[0]->{'network_path'};
}

sub xst_filesys_info_set_network_path  # filesys_info, network_path
{
  &xst_filesys_info_set ($_[0], 'network_path', $_[1]);
}

sub xst_filesys_info_get_uuid          # filesys_info
{
  return $_[0]->{'uuid'};
}

sub xst_filesys_info_set_uuid          # filesys_info, uuid
{
  &xst_filesys_info_set ($_[0], 'uuid', $_[1]);
}

sub xst_filesys_info_get_point         # filesys_info
{
  return $_[0]->{'point'};
}

sub xst_filesys_info_set_point         # filesys_info, point
{
  &xst_filesys_info_set ($_[0], 'point', $_[1]);
}

sub xst_filesys_info_get_fs            # filesys_info
{
  return $_[0]->{'fs'};
}

sub xst_filesys_info_set_fs            # filesys_info, fs
{
  &xst_filesys_info_set ($_[0], 'fs', $_[1]);
}

sub xst_filesys_info_get_dump          # filesys_info
{
  return $_[0]->{'dump'};
}

sub xst_filesys_info_set_dump          # filesys_info, dump
{
  &xst_filesys_info_set ($_[0], 'dump', $_[1]);
}

sub xst_filesys_info_get_priority      # filesys_info
{
  return $_[0]->{'priority'};
}

sub xst_filesys_info_set_priority      # filesys_info, priority
{
  &xst_filesys_info_set ($_[0], 'priority', $_[1]);
}

sub xst_filesys_info_get_mounted       # filesys_info
{
  return $_[0]->{'mounted'};
}

sub xst_filesys_info_set_mounted       # filesys_info, boolean
{
  &xst_filesys_info_set ($_[0], 'mounted', $_[1]);
}

sub xst_filesys_info_get_permanent     # filesys_info
{
  return $_[0]->{'permanent'};
}

sub xst_filesys_info_set_permanent     # filesys_info, boolean
{
  &xst_filesys_info_set ($_[0], 'permanent', $_[1]);
}

sub xst_filesys_info_get_detected      # filesys_info
{
  return $_[0]->{'detected'};
}

sub xst_filesys_info_set_detected      # filesys_info, boolean
{
  &xst_filesys_info_set ($_[0], 'detected', $_[1]);
}

sub xst_filesys_info_get_option      # filesys_info, option
{
  return $_[0]->{'options'}{$_[1]};
}

# We can't delete keys with no values here, since most fs options don't
# have values (i.e. they key's presence constitutes a boolean).

sub xst_filesys_info_set_option        # filesys_info, option, value
{
  $_[0]->{'options'}{$_[1]} = $_[2];
}


# --- filesys_table; multiple instances of filesys_info --- #


sub xst_filesys_table_new
{
  my @array;
  return \@array;
}

# Make a deep copy of a filesys_table struct.
#
# Returns a newly allocated filesys_table, identical to the argument.

sub xst_filesys_table_dup          # filesys_table
{
  my $orig = $_[0];
  my $dup = &xst_filesys_table_new ();
  my $i;

  foreach $i (@$orig)
  {
    &xst_filesys_table_add ($dup, &xst_filesys_info_dup ($i));
  }

  return $dup;
}

# Add a filesys_info reference to a filesys_table. Note: This function
# does not check for uniqueness, which lets you add several references
# to the same filesys_info.

sub xst_filesys_table_add          # filesys_table, filesys_info
{
  my ($table, $info) = @_;

  push @$table, $info;
}

# Ensure that a filesys_info reference exists in a filesys_table. If it
# doesn't, it will be added. If it does, no action will be taken.

sub xst_filesys_table_ensure       # filesys_table, filesys_info
{
  my ($table, $info) = @_;
  my $i;

  foreach $i (@$table)
  {
    return if ($i eq $info);
  }

  &xst_filesys_table_add ($table, $info);
}

# Remove a filesys_info reference from a filesys_table.

sub xst_filesys_table_remove       # filesys_table, filesys_info
{
  my ($table, $info) = @_;
  my $i;

  if ($info == undef) { return; }

  for ($i = 0; $i < @$table; $i++)
  {
    if (@$table [$i] eq $info)
    {
      @$table = (@$table [0 .. $i - 1], @$table [$i + 1 .. @$table - 1]);
      return;
    }
  }

  &xst_debug_print_line ("Entry to remove [" . $info . "] not found in filesys_table.");
}

# Find and return a reference to a filesys_info in a filesys_table
# based on keytype and key.
#
# keytype :- [device | label | uuid | point]

sub xst_filesys_table_find         # filesys_table, keytype, key
{
  my ($table, $keytype, $key) = @_;
  my $i;
  
  foreach $i (@$table)
  {
    return $i if ($i->{$keytype} eq $key);
  }

  &xst_debug_print_line ("Entry [" . $keytype . " -> " . $key . "] not found in filesys_table.");
  return undef;
}

# The key_generator is a ref to a func that takes a filesys_info and returns
# a unique key for it. This allows some abstraction over merging.

sub xst_filesys_table_to_hash
{
  my ($table, $key_generator) = @_;
  my %hash, $i;

  foreach $i (@$table)
  {
    $hash{&$key_generator ($i)} = $i;
  }

  return \%hash;
}

# The converse. No ref to function here, thankfuly.

sub xst_filesys_hash_to_table
{
  my ($hash) = @_;
  my ($outtab, $key);
  
  $outtab = &xst_filesys_table_new ();
  foreach $key (keys %$hash)
  {
    &xst_filesys_table_add ($outtab, $$hash{$key});
  }

  return $outtab;
}

# Merges filesys tables A and B, resolving conflicts by giving priority to A.
# Any entries in A not in B are preserved. This can also be described as
# "salting" one table with another.
#
# Returns a newly allocated table C, which is a superset of A and B.

sub xst_filesys_table_merge_superset  # filesys_table A, filesys_table B, key_generator
{
  my ($intab_a, $intab_b, $key_generator) = @_;
  my ($hash_c, $hash_b, $key);
  my $outtab;

  $outtab = &xst_filesys_table_dup ($intab_a);
  $hash_c = &xst_filesys_table_to_hash ($outtab, $key_generator);
  $hash_b = &xst_filesys_table_to_hash ($intab_b, $key_generator);

  foreach $key (keys %$hash_b)
  {
    if (exists $$hash_c{$key})
    {
      &xst_filesys_info_merge ($$hash_c{$key}, $$hash_b{$key});
    }
    else
    {
      $$hash_c{$key} = &xst_filesys_info_dup ($$hash_b{$key});
    }
  }

  return &xst_filesys_hash_to_table ($hash_c);
}

# Merges filesys tables A and B, resolving conflicts by giving priority to A.
# Any entries in A not in B are dropped.
#
# Returns a newly allocated table C, which is a subset of A and B.

sub xst_filesys_table_merge_subset    # filesys_table A, filesys_table B
{
  my ($intab_a, $intab_b, $key_generator) = @_;
  my ($hash_c, $hash_b, $key);
  my $outtab;

  $outtab = &xst_filesys_table_dup ($intab_a);
  $hash_c = &xst_filesys_table_to_hash ($outtab, $key_generator);
  $hash_b = &xst_filesys_table_to_hash ($intab_b, $key_generator);

  foreach $key (keys %$hash_b)
  {
    if (exists $$hash_c{$key})
    {
      &xst_filesys_info_merge ($$hash_c{$key}, $$hash_b{$key});
    }
    else
    {
      delete $$hash_c{$key};
    }
  }

  return &xst_filesys_hash_to_table ($hash_c);
}

# Called to indicate that entries in a filesys table are mounted.

sub xst_filesys_table_set_mounted_true  # filesys_table
{
  my ($table) = @_;
  foreach $i (@$table)
  {
    &xst_filesys_info_set_mounted ($i, 1);
  }
}

# Called to indicate that entries in a filesys table are permanent.

sub xst_filesys_table_set_permanent_true  # filesys_table
{
  my ($table) = @_;
  foreach $i (@$table)
  {
    &xst_filesys_info_set_permanent ($i, 1);
  }
}

# Called to indicate that entries in a filesys table have been detected,
# e.g. by a network or bus scanner, and were not specified in any part of
# the user's configuration.

sub xst_filesys_table_set_detected_true  # filesys_table
{
  my ($table) = @_;
  foreach $i (@$table)
  {
    &xst_filesys_info_set_detected ($i, 1);
  }
}

# --- Parsing --- #


# Get all instances from fstab-style file. Returns a filesys_table.
#
# This is not done in smaller, atomic funcs that get single options
# per disk device, due to the fact that a device is identified either
# by its label, uuid or device node, and a label can be made to look
# like a device node. For each device, we need to specify the kind of
# key(s) used, and making a special-format string for that (which could
# be passed to option readers) would be a bad hack.

sub xst_filesys_parse_fstab  # filename
{
  my ($file) = @_;
  my ($fd, $table);

  $fd = &xst_file_open_read_from_names ($file);
  return undef if !$fd;

  $table = &xst_filesys_table_new ();

  while (($_ = &xst_parse_chomp_line_hash_comment ($fd)) != -1)
  {
    # Each line is in the following format:
    # <device> <mount point> <filesystem> <options> <dump flag> <fsck priority>
    my @line = split /[ \t]+/, $$_;
    next if (@line < 6);
    my ($device, $point, $fs, $options, $dump, $fsck) = @line;

    my $fsi = &xst_filesys_info_new ();

    # <device> expands to "LABEL=<label>", "UUID=<uuid>" or "<device node>".
    if    ($device =~ /^LABEL=(.*)/i) { &xst_filesys_info_set_label  ($fsi, $1); }
    elsif ($device =~ /^UUID=(.*)/i)  { &xst_filesys_info_set_uuid   ($fsi, $1); }
    else
    {
      &xst_filesys_info_set_device ($fsi, $device);

      # We know only the device node. Try to get label too.
      if ($fs eq "ext2" || $fs eq "auto")
      {
        &xst_filesys_info_set_label ($fsi, &xst_filesys_translate_ext2_device_to_label ($device));
      }
      # Network filesystem devices can be separated into remote host and remote path.
      elsif ($fs eq "nfs")
      {
        $device =~ /([^:]+):(.+)/;
        &xst_filesys_info_set_network_host ($fsi, $1);
        &xst_filesys_info_set_network_path ($fsi, $2);
      }
      elsif ($fs eq "smbfs")
      {
        $device =~ /[\\\/]*([^\\\/]+)[\\\/]+(.+)/;
        &xst_filesys_info_set_network_host ($fsi, $1);
        &xst_filesys_info_set_network_path ($fsi, $2);
      }
    }

    # <options> expands to "<option>[,<option>[,...]]".
    my @optlist = split /[,]/, $options;

    foreach $option (@optlist)
    {
      # <option> expands to "<key>[=<value>]". <key> == "defaults" is ignored.
      my ($key, $value) = split /[=]/, $option;
      next if ($key eq "" || $key eq "defaults");

      &xst_filesys_info_set_option ($fsi, $key, $value);
    }

    # <mount point>, <fs>, <dump flag> and <fsck priority> are verbatim.
    &xst_filesys_info_set_point    ($fsi, $point);
    &xst_filesys_info_set_fs       ($fsi, $fs);
    &xst_filesys_info_set_dump     ($fsi, $dump);
    &xst_filesys_info_set_priority ($fsi, $fsck);

    # Link it in.
    &xst_filesys_table_add ($table, $fsi);
  }

  close $fd;
  return $table;
}

# Get all instances from mtab-style file. Returns a filesys_table.

sub xst_filesys_parse_mtab  # filename
{
  my ($file) = @_;
  my ($fd, $table);

  $fd = &xst_file_open_read_from_names ($file);
  return undef if !$fd;

  $table = &xst_filesys_table_new ();

  while (($_ = &xst_parse_chomp_line_hash_comment ($fd)) != -1)
  {
    # Columns are separated by one, and only one, space. The presence of one or
    # more blank values is indicated by a string of several spaces.
    my @line = split /[ ]/, $$_;

    # Each line is in the following format:
    # <device> <mount point> <filesystem> <options> <dump flag> <fsck priority>
    next if (@line < 6);
    my ($device, $point, $fs, $options, $dump, $fsck) = @line;

    my $fsi = &xst_filesys_info_new ();

    # <device> expands to "<device node>" (unlike fstab, which has dev|label|uuid).
    # <mount point>, <fs>, <dump flag> and <fsck priority> are verbatim.
    &xst_filesys_info_set_device   ($fsi, $device);
    &xst_filesys_info_set_point    ($fsi, $point);
    &xst_filesys_info_set_fs       ($fsi, $fs);
    &xst_filesys_info_set_dump     ($fsi, $dump);
    &xst_filesys_info_set_priority ($fsi, $fsck);

    # <options> expands to "<option>[,<option>[,...]]".
    my @optlist = split /[,]/, $options;

    foreach $option (@optlist)
    {
      # <option> expands to "<key>[=<value>]". <key> == "defaults" is ignored.
      my ($key, $value) = split /[=]/, $option;
      next if ($key eq "" || $key eq "defaults");

      &xst_filesys_info_set_option ($fsi, $key, $value);
    }

    # If we have an ext2 device, try to get its label. This is very useful
    # for matching/table merging.
    if ($fs eq "ext2")
    {
      &xst_filesys_info_set_label ($fsi, &xst_filesys_translate_ext2_device_to_label ($device));
    }
    # Network filesystem devices can be separated into remote host and remote path.
    elsif ($fs eq "nfs")
    {
      $device =~ /([^:]+):(.+)/;
      &xst_filesys_info_set_network_host ($fsi, $1);
      &xst_filesys_info_set_network_path ($fsi, $2);
    }
    elsif ($fs eq "smbfs")
    {
      $device =~ /[\\\/]*([^\\\/]+)[\\\/]+(.+)/;
      &xst_filesys_info_set_network_host ($fsi, $1);
      &xst_filesys_info_set_network_path ($fsi, $2);
    }

    # Link it in.
    &xst_filesys_table_add ($table, $fsi);
  }

  close $fd;
  return $table;
}
